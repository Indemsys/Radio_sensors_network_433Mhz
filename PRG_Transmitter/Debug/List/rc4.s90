///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR      26/Oct/2021  17:01:07
// Copyright 1996-2021 IAR Systems AB.
//
//    Source file  =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\rc4.c
//    Command line =  
//        -f C:\Users\aly\AppData\Local\Temp\EW92E1.tmp
//        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\rc4.c
//        --cpu=m8 -ms -o
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj
//        -lCN
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        -lB
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        --initializers_in_flash --no_cross_call --no_clustering --no_tbaa
//        --debug -DENABLE_BIT_DEFINITIONS -e --eeprom_size 512 --clib -Ohz)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List\rc4.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME rc4

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC rc4_crypt
        PUBLIC rc4_setup
        PUBLIC rc4state

// D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\rc4.c
//    1 /*
//    2  *  An implementation of the ARC4 algorithm
//    3  *
//    4  *  Copyright (C) 2001-2003  Christophe Devine
//    5  *
//    6  *  This program is free software; you can redistribute it and/or modify
//    7  *  it under the terms of the GNU General Public License as published by
//    8  *  the Free Software Foundation; either version 2 of the License, or
//    9  *  (at your option) any later version.
//   10  *
//   11  *  This program is distributed in the hope that it will be useful,
//   12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
//   13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   14  *  GNU General Public License for more details.
//   15  *
//   16  *  You should have received a copy of the GNU General Public License
//   17  *  along with this program; if not, write to the Free Software
//   18  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//   19  */
//   20 
//   21 #include "rc4.h"
//   22 

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   23 t_rc4_state rc4state;
rc4state:
        DS8 258
//   24 

        RSEG `CODE`:CODE:NOROOT(1)
//   25 void rc4_setup(unsigned char *key,  unsigned char length )
rc4_setup:
        CODE
//   26 {
        RCALL   ?PROLOGUE4_L09
        MOVW    R21:R20, R17:R16
        MOV     R19, R18
        LDI     R16, 0
        STS     rc4state, R16
//   27     unsigned int  i;
//   28     unsigned char j, k, a;
//   29     unsigned char *m;
//   30 
//   31     rc4state.x = 0;
//   32     rc4state.y = 0;
        STS     (rc4state + 1), R16
//   33     m = rc4state.m;
//   34 
//   35     for( i = 0; i < 256; i++ )
        LDI     R17, 0
        LDI     R24, 0
        LDI     R25, 1
//   36     {
//   37         m[i] = i;
??rc4_setup_0:
        LDI     R30, LOW(rc4state)
        LDI     R31, (rc4state) >> 8
        ADD     R30, R16
        ADC     R31, R17
        STD     Z+2, R16
//   38     }
        SUBI    R16, 255
        SBCI    R17, 255
        SBIW    R25:R24, 1
        BRNE    ??rc4_setup_0
//   39 
//   40     j = k = 0;
        LDI     R18, 0
        LDI     R22, 0
//   41 
//   42     for( i = 0; i < 256; i++ )
        LDI     R16, 0
        LDI     R17, 0
        LDI     R24, 0
        LDI     R25, 1
//   43     {
//   44         a = m[i];
??rc4_setup_1:
        LDI     R30, LOW(rc4state)
        LDI     R31, (rc4state) >> 8
        ADD     R30, R16
        ADC     R31, R17
        LDD     R2, Z+2
//   45         j = (unsigned char) ( j + a + key[k] );
        CLR     R1
        MOVW    R27:R26, R21:R20
        ADD     R26, R18
        ADC     R27, R1
        LD      R23, X
        MOV     R0, R2
        ADD     R0, R23
        ADD     R22, R0
//   46         m[i] = m[j]; 
        LDI     R26, LOW(rc4state)
        LDI     R27, (rc4state) >> 8
        ADD     R26, R22
        ADC     R27, R1
        ADIW    R27:R26, 2
        LD      R23, X
        SBIW    R27:R26, 2
        STD     Z+2, R23
//   47         m[j] = a;
        MOVW    R31:R30, R27:R26
        STD     Z+2, R2
//   48         k++;
//   49         if(k >= length ) k = 0;
        INC     R18
        CP      R18, R19
        BRCS    ??rc4_setup_2
        LDI     R18, 0
//   50     }
??rc4_setup_2:
        SUBI    R16, 255
        SBCI    R17, 255
        SBIW    R25:R24, 1
        BRNE    ??rc4_setup_1
//   51 }
        REQUIRE ?Subroutine0
        ;               // Fall through to label ?Subroutine0

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine0:
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//   52 

        RSEG `CODE`:CODE:NOROOT(1)
//   53 void rc4_crypt(unsigned char *data, unsigned int length )
rc4_crypt:
        CODE
//   54 {
        RCALL   ?PROLOGUE4_L09
        MOVW    R21:R20, R17:R16
        LDS     R16, rc4state
//   55     unsigned int  i; 
//   56     unsigned char x, y, a, b;
//   57     unsigned char  *m;
//   58 
//   59     x = rc4state.x;
//   60     y = rc4state.y;
        LDS     R22, (rc4state + 1)
//   61     m = rc4state.m;
//   62 
//   63     for( i = 0; i < length; i++ )
        LDI     R24, 0
        LDI     R25, 0
        RJMP    ??rc4_crypt_0
//   64     {
//   65         x = (unsigned char) ( x + 1 ); a = m[x];
??rc4_crypt_1:
        INC     R16
        LDI     R17, 0
        LDI     R30, LOW(rc4state)
        LDI     R31, (rc4state) >> 8
        ADD     R30, R16
        ADC     R31, R17
        LDD     R0, Z+2
//   66         y = (unsigned char) ( y + a );
        ADD     R22, R0
//   67         m[x] = b = m[y];
        LDI     R30, LOW(rc4state)
        LDI     R31, (rc4state) >> 8
        ADD     R30, R22
        ADC     R31, R17
        LDD     R23, Z+2
        LDI     R26, LOW(rc4state)
        LDI     R27, (rc4state) >> 8
        ADD     R26, R16
        ADC     R27, R17
        ADIW    R27:R26, 2
        ST      X, R23
//   68         m[y] = a;
        STD     Z+2, R0
//   69         data[i] ^= m[(unsigned char) ( a + b )];
        ADD     R0, R23
        LDI     R30, LOW(rc4state)
        LDI     R31, (rc4state) >> 8
        ADD     R30, R0
        ADC     R31, R17
        LDD     R17, Z+2
        MOVW    R31:R30, R21:R20
        ADD     R30, R24
        ADC     R31, R25
        LD      R23, Z
        EOR     R23, R17
        ST      Z, R23
//   70     }
        ADIW    R25:R24, 1
??rc4_crypt_0:
        CP      R24, R18
        CPC     R25, R19
        BRCS    ??rc4_crypt_1
//   71 
//   72     rc4state.x = x;
        STS     rc4state, R16
//   73     rc4state.y = y;
        STS     (rc4state + 1), R22
//   74 }
        RJMP    ?Subroutine0

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        END
// 
// 218 bytes in segment CODE
//   6 bytes in segment INITTAB
// 258 bytes in segment NEAR_Z
// 
// 218 bytes of CODE memory (+ 6 bytes shared)
// 258 bytes of DATA memory
//
//Errors: none
//Warnings: none
