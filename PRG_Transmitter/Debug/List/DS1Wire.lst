###############################################################################
#
# IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR       26/Oct/2021  17:01:07
# Copyright 1996-2021 IAR Systems AB.
#
#    Source file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\DS1Wire.c
#    Command line =  
#        -f C:\Users\aly\AppData\Local\Temp\EW92E3.tmp
#        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\DS1Wire.c
#        --cpu=m8 -ms -o
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj
#        -lCN
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
#        -lB
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
#        --initializers_in_flash --no_cross_call --no_clustering --no_tbaa
#        --debug -DENABLE_BIT_DEFINITIONS -e --eeprom_size 512 --clib -Ohz)
#    Locale       =  Russian_RUS.1251
#    List file    =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List\DS1Wire.lst
#    Object file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj\DS1Wire.r90
#
###############################################################################

D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\DS1Wire.c
      1          #include <ioavr.h>

   \                                 In  segment ABSOLUTE, at 0x32
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   union <unnamed> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   union <unnamed> volatile __io _A_PIND
   \                     _A_PIND:
   \   00000000                      DS8 1
      2          #include <inavr.h>
      3          #include <string.h>
      4          #include "DS1Wire.h"
      5          
      6          /*! \brief  Perform a 1-Wire search
      7          *
      8          *  This function shows how the D1W_SearchRom function can be used to
      9          *  discover all slaves on the bus. It will also CRC check the 64 bit
     10          *  identifiers.
     11          *
     12          *  \param  devices Pointer to an array of type D1W_device. The discovered
     13          *                  devices will be placed from the beginning of this array.
     14          *
     15          *  \param  len     The length of the device array. (Max. number of elements).
     16          *
     17          *
     18          *  \retval SEARCH_SUCCESSFUL   Search completed successfully.
     19          *  \retval SEARCH_CRC_ERROR    A CRC error occured. Probably because of noise
     20          *                              during transmission.
     21          */

   \                                 In  segment CODE, align 2, keep-with-next
     22          unsigned char DS1W_SearchBuses(D1W_device * devices, unsigned char len)
   \                     DS1W_SearchBuses:
     23          {
   \   00000000   ....               RCALL   ?PROLOGUE6_L09
   \   00000002                      REQUIRE ?Register_R4_is_cg_reg
   \   00000002                      REQUIRE ?Register_R5_is_cg_reg
   \   00000002   01D8               MOVW    R27:R26, R17:R16
     24            unsigned char i, j;
     25            unsigned char presence;
     26            unsigned char * newID;
     27            unsigned char * currentID;
     28            unsigned char lastDeviation;
     29            unsigned char numDevices;
     30          
     31            // Initialize all addresses as zero, on bus 0 (does not exist).
     32            for (i = 0; i < len; i++)
   \   00000004   E080               LDI     R24, 0
   \   00000006   C00F               RJMP    ??DS1W_SearchBuses_0
     33            {
     34              for (j = 0; j < 8; j++)
   \                     ??DS1W_SearchBuses_1:
   \   00000008   E040               LDI     R20, 0
   \   0000000A   E008               LDI     R16, 8
   \   0000000C   E018               LDI     R17, 8
   \   0000000E   E050               LDI     R21, 0
     35              {
     36                devices[i].id[j] = 0x00;
   \                     ??DS1W_SearchBuses_2:
   \   00000010   9F81               MUL     R24, R17
   \   00000012   01FD               MOVW    R31:R30, R27:R26
   \   00000014   0DE0               ADD     R30, R0
   \   00000016   1DF1               ADC     R31, R1
   \   00000018   0FE4               ADD     R30, R20
   \   0000001A   1FF5               ADC     R31, R21
   \   0000001C   8350               ST      Z, R21
     37              }
   \   0000001E   9543               INC     R20
   \   00000020   950A               DEC     R16
   \   00000022   F7B1               BRNE    ??DS1W_SearchBuses_2
     38            }
   \   00000024   9583               INC     R24
   \                     ??DS1W_SearchBuses_0:
   \   00000026   1782               CP      R24, R18
   \   00000028   F378               BRCS    ??DS1W_SearchBuses_1
     39          
     40            // Find the buses with slave devices.
     41            presence = D1W_DetectPresence();
   \   0000002A   ....               RCALL   D1W_DetectPresence
     42          
     43            numDevices = 0;
   \   0000002C   2444               CLR     R4
     44            newID = devices[0].id;
   \   0000002E   01CD               MOVW    R25:R24, R27:R26
     45          
     46            // Go through all buses with slave devices.
     47            lastDeviation = 0;
   \   00000030   2455               CLR     R5
     48            currentID = newID;
   \   00000032   019D               MOVW    R19:R18, R27:R26
     49            if (presence) // Devices available on this bus.
   \   00000034   2300               TST     R16
   \   00000036   F091               BREQ    ??DS1W_SearchBuses_3
     50            {
     51              // Do slave search  and place identifiers in the array.
     52              do
     53              {
     54                memcpy(newID, currentID, 8);
   \                     ??DS1W_SearchBuses_4:
   \   00000038   E048               LDI     R20, 8
   \   0000003A   E050               LDI     R21, 0
   \   0000003C   018C               MOVW    R17:R16, R25:R24
   \   0000003E   ....               RCALL   memcpy
     55                D1W_DetectPresence();
   \   00000040   ....               RCALL   D1W_DetectPresence
     56                lastDeviation = D1W_SearchRom(newID, lastDeviation);
   \   00000042   2D25               MOV     R18, R5
   \   00000044   018C               MOVW    R17:R16, R25:R24
   \   00000046   ....               RCALL   D1W_SearchRom
   \   00000048   2E50               MOV     R5, R16
     57                currentID = newID;
   \   0000004A   019C               MOVW    R19:R18, R25:R24
     58                numDevices++;
     59                newID=devices[numDevices].id;
   \   0000004C   9443               INC     R4
   \   0000004E   E008               LDI     R16, 8
   \   00000050   9E40               MUL     R4, R16
   \   00000052   01CD               MOVW    R25:R24, R27:R26
   \   00000054   0D80               ADD     R24, R0
   \   00000056   1D91               ADC     R25, R1
     60              }
     61              while(lastDeviation != D1W_ROM_SEARCH_FINISHED);
   \   00000058   2055               TST     R5
   \   0000005A   F771               BRNE    ??DS1W_SearchBuses_4
     62            }
     63          
     64            // Go through all the devices and do CRC check.
     65            for (i = 0; i < numDevices; i++)
   \                     ??DS1W_SearchBuses_3:
   \   0000005C   E080               LDI     R24, 0
   \   0000005E   C001               RJMP    ??DS1W_SearchBuses_5
   \                     ??DS1W_SearchBuses_6:
   \   00000060   9583               INC     R24
   \                     ??DS1W_SearchBuses_5:
   \   00000062   1584               CP      R24, R4
   \   00000064   F450               BRCC    ??DS1W_SearchBuses_7
     66            {
     67              // If any id has a crc error, return error.
     68              if(D1W_CheckRomCRC(devices[i].id) != D1W_CRC_OK)
   \   00000066   E008               LDI     R16, 8
   \   00000068   9F80               MUL     R24, R16
   \   0000006A   018D               MOVW    R17:R16, R27:R26
   \   0000006C   0D00               ADD     R16, R0
   \   0000006E   1D11               ADC     R17, R1
   \   00000070   ....               RCALL   D1W_CheckRomCRC
   \   00000072   3001               CPI     R16, 1
   \   00000074   F3A9               BREQ    ??DS1W_SearchBuses_6
     69              {
     70                return SEARCH_CRC_ERROR;
   \   00000076   E001               LDI     R16, 1
   \   00000078   C001               RJMP    ??DS1W_SearchBuses_8
     71              }
     72            }
     73            // Else, return Successful.
     74            return SEARCH_SUCCESSFUL;
   \                     ??DS1W_SearchBuses_7:
   \   0000007A   E000               LDI     R16, 0
   \                     ??DS1W_SearchBuses_8:
   \   0000007C   E0E6               LDI     R30, 6
   \   0000007E   ....               RJMP    ?EPILOGUE_B6_L09
     75          }
     76          
     77          /*! \brief  Find the first device of a family based on the family id
     78          *
     79          *  This function returns a pointer to a device in the device array
     80          *  that matches the specified family.
     81          *
     82          *  \param  familyID    The 8 bit family ID to search for.
     83          *
     84          *  \param  devices     An array of devices to search through.
     85          *
     86          *  \param  size        The size of the array 'devices'
     87          *
     88          *  \return A pointer to a device of the family.
     89          *  \retval NULL    if no device of the family was found.
     90          */

   \                                 In  segment CODE, align 2, keep-with-next
     91          D1W_device * DS1W_FindFamily(unsigned char familyID, D1W_device * devices, unsigned char size)
   \                     DS1W_FindFamily:
     92          {
     93            unsigned char i = 0;
   \   00000000   E040               LDI     R20, 0
   \   00000002   C003               RJMP    ??DS1W_FindFamily_0
     94          
     95            // Search through the array.
     96            while (i < size)
     97            {
     98              // Return the pointer if there is a family id match.
     99              if ((*devices).id[0] == familyID)
    100              {
    101                return devices;
    102              }
    103              devices++;
   \                     ??DS1W_FindFamily_1:
   \   00000004   5F28               SUBI    R18, 248
   \   00000006   4F3F               SBCI    R19, 255
    104              i++;
   \   00000008   9543               INC     R20
   \                     ??DS1W_FindFamily_0:
   \   0000000A   1741               CP      R20, R17
   \   0000000C   F430               BRCC    ??DS1W_FindFamily_2
   \   0000000E   01F9               MOVW    R31:R30, R19:R18
   \   00000010   8150               LD      R21, Z
   \   00000012   1750               CP      R21, R16
   \   00000014   F7B9               BRNE    ??DS1W_FindFamily_1
   \   00000016   0189               MOVW    R17:R16, R19:R18
   \   00000018   9508               RET
    105            }
    106            // Else, return NULL.
    107            return NULL;
   \                     ??DS1W_FindFamily_2:
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   E010               LDI     R17, 0
   \   0000001E   9508               RET
    108          }
    109          
    110          
    111          /*! \brief  Read the temperature from a DS1820 temperature sensor.
    112          *
    113          *  This function will start a conversion and read back the temperature
    114          *  from a DS1820 temperature sensor.
    115          *
    116          *
    117          *  \param  id  The 64 bit identifier of the DS1820.
    118          *
    119          *  \return The 16 bit signed temperature read from the DS1820.
    120          */

   \                                 In  segment CODE, align 2, keep-with-next
    121          signed int DS1820_ReadTemperature(unsigned char * id)
   \                     DS1820_ReadTemperature:
    122          {
   \   00000000   01B8               MOVW    R23:R22, R17:R16
    123            signed int temperature;
    124          
    125            // Reset, presence.
    126            if (!D1W_DetectPresence())
   \   00000002   ....               RCALL   D1W_DetectPresence
   \   00000004   2300               TST     R16
   \   00000006   F051               BREQ    ??DS1820_ReadTemperature_0
    127            {
    128              return DS1820_ERROR; // Error
    129            }
    130            // Match the id found earlier.
    131            D1W_MatchRom(id);
   \   00000008   018B               MOVW    R17:R16, R23:R22
   \   0000000A   ....               RCALL   D1W_MatchRom
    132            // Send start conversion command.
    133            D1W_SendByte(DS1820_START_CONVERSION);
   \   0000000C   E404               LDI     R16, 68
   \   0000000E   ....               RCALL   D1W_SendByte
    134            // Wait until conversion is finished.
    135            // Bus line is held low until conversion is finished.
    136            while (!D1W_ReadBit())
   \                     ??DS1820_ReadTemperature_1:
   \   00000010   ....               RCALL   D1W_ReadBit
   \   00000012   2300               TST     R16
   \   00000014   F3E9               BREQ    ??DS1820_ReadTemperature_1
    137            {
    138          
    139            }
    140            // Reset, presence.
    141            if(!D1W_DetectPresence())
   \   00000016   ....               RCALL   D1W_DetectPresence
   \   00000018   2300               TST     R16
   \   0000001A   F419               BRNE    ??DS1820_ReadTemperature_2
    142            {
    143              return -1000; // Error
   \                     ??DS1820_ReadTemperature_0:
   \   0000001C   E108               LDI     R16, 24
   \   0000001E   EF1C               LDI     R17, 252
   \   00000020   9508               RET
    144            }
    145            // Match id again.
    146            D1W_MatchRom(id);
   \                     ??DS1820_ReadTemperature_2:
   \   00000022   018B               MOVW    R17:R16, R23:R22
   \   00000024   ....               RCALL   D1W_MatchRom
    147            // Send READ SCRATCHPAD command.
    148            D1W_SendByte(DS1820_READ_SCRATCHPAD);
   \   00000026   EB0E               LDI     R16, 190
   \   00000028   ....               RCALL   D1W_SendByte
    149            // Read only two first bytes (temperature low, temperature high)
    150            // and place them in the 16 bit temperature variable.
    151            temperature = D1W_ReceiveByte();
   \   0000002A   ....               RCALL   D1W_ReceiveByte
   \   0000002C   2F50               MOV     R21, R16
    152            temperature |= (D1W_ReceiveByte() << 8);
    153          
    154            return temperature;
   \   0000002E   ....               RCALL   D1W_ReceiveByte
   \   00000030   2F10               MOV     R17, R16
   \   00000032   2F05               MOV     R16, R21
   \   00000034   9508               RET
    155          }
    156          
    157          
    158          /*! \brief  Set the wiper position of a DS2890.
    159          *
    160          *  This function initializes the DS2890 by enabling the charge pump. It then
    161          *  changes the wiper position.
    162          *
    163          *  \param  position    The new wiper position.
    164          *
    165          *  \param  id          The 64 bit identifier of the DS2890.
    166          */

   \                                 In  segment CODE, align 2, keep-with-next
    167          void DS2890_SetWiperPosition(unsigned char position, unsigned char * id)
   \                     DS2890_SetWiperPosition:
    168          {
   \   00000000   2F50               MOV     R21, R16
   \   00000002   01B9               MOVW    R23:R22, R19:R18
    169            // Reset, presence.
    170            if(!D1W_DetectPresence())
   \   00000004   ....               RCALL   D1W_DetectPresence
   \   00000006   2300               TST     R16
   \   00000008   F0E9               BREQ    ??DS2890_SetWiperPosition_0
    171            {
    172              return;
    173            }
    174            //Match id.
    175            D1W_MatchRom(id);
   \   0000000A   018B               MOVW    R17:R16, R23:R22
   \   0000000C   ....               RCALL   D1W_MatchRom
    176          
    177            // Send Write control register command.
    178            D1W_SendByte(DS2890_WRITE_CONTROL_REGISTER);
   \   0000000E   E505               LDI     R16, 85
   \   00000010   ....               RCALL   D1W_SendByte
    179          
    180            // Write 0x4c to control register to enable charge pump.
    181            D1W_SendByte(0x4c);
   \   00000012   E40C               LDI     R16, 76
   \   00000014   ....               RCALL   D1W_SendByte
    182          
    183            // Check that the value returned matches the value sent.
    184            if (D1W_ReceiveByte() != 0x4c)
   \   00000016   ....               RCALL   D1W_ReceiveByte
   \   00000018   340C               CPI     R16, 76
   \   0000001A   F4A1               BRNE    ??DS2890_SetWiperPosition_0
    185            {
    186              return;
    187            }
    188          
    189            // Send release code to update control register.
    190            D1W_SendByte(DS2890_RELEASE_CODE);
   \   0000001C   E906               LDI     R16, 150
   \   0000001E   ....               RCALL   D1W_SendByte
    191          
    192            // Check that zeros are returned to ensure that the operation was
    193            // successful.
    194            if (D1W_ReceiveByte() == 0xff)
   \   00000020   ....               RCALL   D1W_ReceiveByte
   \   00000022   3F0F               CPI     R16, 255
   \   00000024   F079               BREQ    ??DS2890_SetWiperPosition_0
    195            {
    196              return;
    197            }
    198          
    199            // Reset, presence.
    200            if (!D1W_DetectPresence())
   \   00000026   ....               RCALL   D1W_DetectPresence
   \   00000028   2300               TST     R16
   \   0000002A   F061               BREQ    ??DS2890_SetWiperPosition_0
    201            {
    202              return;
    203            }
    204          
    205            // Match id.
    206            D1W_MatchRom(id);
   \   0000002C   018B               MOVW    R17:R16, R23:R22
   \   0000002E   ....               RCALL   D1W_MatchRom
    207          
    208            // Send the Write Position command.
    209            D1W_SendByte(DS2890_WRITE_POSITION);
   \   00000030   E00F               LDI     R16, 15
   \   00000032   ....               RCALL   D1W_SendByte
    210          
    211            // Send the new position.
    212            D1W_SendByte(position);
   \   00000034   2F05               MOV     R16, R21
   \   00000036   ....               RCALL   D1W_SendByte
    213          
    214            // Check that the value returned matches the value sent.
    215            if (D1W_ReceiveByte() != position)
   \   00000038   ....               RCALL   D1W_ReceiveByte
   \   0000003A   1705               CP      R16, R21
   \   0000003C   F419               BRNE    ??DS2890_SetWiperPosition_0
    216            {
    217              return;
    218            }
    219          
    220            // Send release code to update wiper position.
    221            D1W_SendByte(DS2890_RELEASE_CODE);
   \   0000003E   E906               LDI     R16, 150
   \   00000040   ....               RCALL   D1W_SendByte
    222          
    223            // Check that zeros are returned to ensure that the operation was
    224            // successful.
    225            if (D1W_ReceiveByte() == 0xff)
   \   00000042   ....               RCALL   D1W_ReceiveByte
    226            {
    227              return;
    228            }
    229          }
   \                     ??DS2890_SetWiperPosition_0:
   \   00000044   9508               RET
    230          
    231          /*! \brief  Sends one byte of data on the 1-Wire(R) bus(es).
    232          *
    233          *  This function automates the task of sending a complete byte
    234          *  of data on the 1-Wire bus(es).
    235          *
    236          *  \param  data    The data to send on the bus(es).
    237          *
    238          */

   \                                 In  segment CODE, align 2, keep-with-next
    239          void D1W_SendByte(unsigned char data)
   \                     D1W_SendByte:
    240          {
   \   00000000   2F30               MOV     R19, R16
    241            unsigned char temp;
    242            unsigned char i;
    243          
    244            // Do once for each bit
    245            for (i = 0; i < 8; i++)
   \   00000002   E028               LDI     R18, 8
    246            {
    247              // Determine if lsb is '0' or '1' and transmit corresponding
    248              // waveform on the bus.
    249              temp = data & 0x01;
    250              if (temp)
   \                     ??D1W_SendByte_0:
   \   00000004   FB30               BST     R19, 0
   \   00000006   F416               BRTC    ??D1W_SendByte_1
    251              {
    252                D1W_WriteBit1();
   \   00000008   ....               RCALL   D1W_WriteBit1
   \   0000000A   C001               RJMP    ??D1W_SendByte_2
    253              }
    254              else
    255              {
    256                D1W_WriteBit0();
   \                     ??D1W_SendByte_1:
   \   0000000C   ....               RCALL   D1W_WriteBit0
    257              }
    258              // Right shift the data to get next bit.
    259              data >>= 1;
   \                     ??D1W_SendByte_2:
   \   0000000E   9536               LSR     R19
    260            }
   \   00000010   952A               DEC     R18
   \   00000012   F7C1               BRNE    ??D1W_SendByte_0
    261          }
   \   00000014   9508               RET
    262          
    263          
    264          /*! \brief  Receives one byte of data from the 1-Wire(R) bus.
    265          *
    266          *  This function automates the task of receiving a complete byte
    267          *  of data from the 1-Wire bus.
    268          *
    269          *  \return     The byte read from the bus.
    270          */

   \                                 In  segment CODE, align 2, keep-with-next
    271          unsigned char D1W_ReceiveByte(void)
   \                     D1W_ReceiveByte:
    272          {
    273            unsigned char data;
    274            unsigned char i;
    275          
    276            // Clear the temporary input variable.
    277            data = 0x00;
   \   00000000   E040               LDI     R20, 0
    278          
    279            // Do once for each bit
    280            for (i = 0; i < 8; i++)
   \   00000002   E038               LDI     R19, 8
    281            {
    282              // Shift temporary input variable right.
    283              data >>= 1;
   \                     ??D1W_ReceiveByte_0:
   \   00000004   9546               LSR     R20
    284              // Set the msb if a '1' value is read from the bus.
    285              // Leave as it is ('0') else.
    286              if (D1W_ReadBit())
   \   00000006   ....               RCALL   D1W_ReadBit
   \   00000008   2300               TST     R16
   \   0000000A   F009               BREQ    ??D1W_ReceiveByte_1
    287              {
    288                // Set msb
    289                data |= 0x80;
   \   0000000C   6840               ORI     R20, 0x80
    290              }
    291            }
   \                     ??D1W_ReceiveByte_1:
   \   0000000E   953A               DEC     R19
   \   00000010   F7C9               BRNE    ??D1W_ReceiveByte_0
    292            return data;
   \   00000012   2F04               MOV     R16, R20
   \   00000014   9508               RET
    293          }
    294          
    295          
    296          /*! \brief  Sends the SKIP ROM command to the 1-Wire bus(es).
    297          *
    298          */

   \                                 In  segment CODE, align 2, keep-with-next
    299          void D1W_SkipRom(void)
   \                     D1W_SkipRom:
    300          {
    301            // Send the SKIP ROM command on the bus.
    302            D1W_SendByte(D1W_ROM_SKIP);
   \   00000000   EC0C               LDI     R16, 204
   \   00000002   ....               RJMP    D1W_SendByte
    303          }
    304          
    305          
    306          /*! \brief  Sends the READ ROM command and reads back the ROM id.
    307          *
    308          *  \param  romValue    A pointer where the id will be placed.
    309          *
    310          */

   \                                 In  segment CODE, align 2, keep-with-next
    311          void D1W_ReadRom(unsigned char * romValue)
   \                     D1W_ReadRom:
    312          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
    313            unsigned char bytesLeft = 8;
    314          
    315            // Send the READ ROM command on the bus.
    316            D1W_SendByte(D1W_ROM_READ);
   \   00000002   E303               LDI     R16, 51
   \   00000004   ....               RCALL   D1W_SendByte
   \   00000006   E058               LDI     R21, 8
    317          
    318            // Do 8 times.
    319            while (bytesLeft > 0)
    320            {
    321              // Place the received data in memory.
    322              *romValue++ = D1W_ReceiveByte();
   \                     ??D1W_ReadRom_0:
   \   00000008   ....               RCALL   D1W_ReceiveByte
   \   0000000A   9301               ST      Z+, R16
    323              bytesLeft--;
    324            }
   \   0000000C   955A               DEC     R21
   \   0000000E   F7E1               BRNE    ??D1W_ReadRom_0
    325          }
   \   00000010   9508               RET
    326          
    327          
    328          /*! \brief  Sends the MATCH ROM command and the ROM id to match against.
    329          *
    330          *  \param  romValue    A pointer to the ID to match against.
    331          *
    332          */

   \                                 In  segment CODE, align 2, keep-with-next
    333          void D1W_MatchRom(unsigned char * romValue)
   \                     D1W_MatchRom:
    334          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
    335            unsigned char bytesLeft = 8;
    336          
    337            // Send the MATCH ROM command.
    338            D1W_SendByte(D1W_ROM_MATCH);
   \   00000002   E505               LDI     R16, 85
   \   00000004   ....               RCALL   D1W_SendByte
   \   00000006   E048               LDI     R20, 8
    339          
    340            // Do once for each byte.
    341            while (bytesLeft > 0)
    342            {
    343              // Transmit 1 byte of the ID to match.
    344              D1W_SendByte(*romValue++);
   \                     ??D1W_MatchRom_0:
   \   00000008   9101               LD      R16, Z+
   \   0000000A   ....               RCALL   D1W_SendByte
    345              bytesLeft--;
    346            }
   \   0000000C   954A               DEC     R20
   \   0000000E   F7E1               BRNE    ??D1W_MatchRom_0
    347          }
   \   00000010   9508               RET
    348          
    349          
    350          /*! \brief  Sends the SEARCH ROM command and returns 1 id found on the
    351          *          1-Wire(R) bus.
    352          *
    353          *  \param  bitPattern      A pointer to an 8 byte char array where the
    354          *                          discovered identifier will be placed. When
    355          *                          searching for several slaves, a copy of the
    356          *                          last found identifier should be supplied in
    357          *                          the array, or the search will fail.
    358          *
    359          *  \param  lastDeviation   The bit position where the algorithm made a
    360          *                          choice the last time it was run. This argument
    361          *                          should be 0 when a search is initiated. Supplying
    362          *                          the return argument of this function when calling
    363          *                          repeatedly will go through the complete slave
    364          *                          search.
    365          *
    366          *  \return The last bit position where there was a discrepancy between slave addresses the last time this function was run. Returns D1W_ROM_SEARCH_FAILED if an error was detected (e.g. a device was connected to the bus during the search), or D1W_ROM_SEARCH_FINISHED when there are no more devices to be discovered.
    367          *
    368          *  \note   See main.c for an example of how to utilize this function.
    369          */

   \                                 In  segment CODE, align 2, keep-with-next
    370          unsigned char D1W_SearchRom(unsigned char * bitPattern, unsigned char lastDeviation)
   \                     D1W_SearchRom:
    371          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
   \   00000002   2F62               MOV     R22, R18
    372            unsigned char currentBit = 1;
   \   00000004   E041               LDI     R20, 1
    373            unsigned char newDeviation = 0;
   \   00000006   E070               LDI     R23, 0
    374            unsigned char bitMask = 0x01;
   \   00000008   E051               LDI     R21, 1
    375            unsigned char bitA;
    376            unsigned char bitB;
    377          
    378            // Send SEARCH ROM command on the bus.
    379            D1W_SendByte(D1W_ROM_SEARCH);
   \   0000000A   EF00               LDI     R16, 240
   \   0000000C   ....               RCALL   D1W_SendByte
    380          
    381            // Walk through all 64 bits.
    382            while (currentBit <= 64)
    383            {
    384              // Read bit from bus twice.
    385              bitA = D1W_ReadBit();
   \                     ??D1W_SearchRom_0:
   \   0000000E   ....               RCALL   D1W_ReadBit
   \   00000010   2F30               MOV     R19, R16
    386              bitB = D1W_ReadBit();
   \   00000012   ....               RCALL   D1W_ReadBit
    387          
    388              if (bitA && bitB)
   \   00000014   2333               TST     R19
   \   00000016   F021               BREQ    ??D1W_SearchRom_1
   \   00000018   2300               TST     R16
   \   0000001A   F011               BREQ    ??D1W_SearchRom_1
    389              {
    390                // Both bits 1 (Error).
    391                newDeviation = D1W_ROM_SEARCH_FAILED;
    392                return newDeviation;
   \   0000001C   EF0F               LDI     R16, 255
   \   0000001E   9508               RET
    393              }
    394              else if (bitA ^ bitB)
   \                     ??D1W_SearchRom_1:
   \   00000020   8110               LD      R17, Z
   \   00000022   2F25               MOV     R18, R21
   \   00000024   9520               COM     R18
   \   00000026   2E03               MOV     R0, R19
   \   00000028   2600               EOR     R0, R16
   \   0000002A   F021               BREQ    ??D1W_SearchRom_2
    395              {
    396                // Bits A and B are different. All devices have the same bit here.
    397                // Set the bit in bitPattern to this value.
    398                if (bitA)
   \   0000002C   2333               TST     R19
   \   0000002E   F421               BRNE    ??D1W_SearchRom_3
    399                {
    400                  (*bitPattern) |= bitMask;
    401                }
    402                else
    403                {
    404                  (*bitPattern) &= ~bitMask;
   \   00000030   2312               AND     R17, R18
   \   00000032   C00C               RJMP    ??D1W_SearchRom_4
    405                }
    406              }
    407              else // Both bits 0
    408              {
    409                // If this is where a choice was made the last time,
    410                // a '1' bit is selected this time.
    411                if (currentBit == lastDeviation)
   \                     ??D1W_SearchRom_2:
   \   00000034   1746               CP      R20, R22
   \   00000036   F411               BRNE    ??D1W_SearchRom_5
    412                {
    413                  (*bitPattern) |= bitMask;
   \                     ??D1W_SearchRom_3:
   \   00000038   2B15               OR      R17, R21
   \   0000003A   C008               RJMP    ??D1W_SearchRom_4
    414                }
    415                // For the rest of the id, '0' bits are selected when
    416                // discrepancies occur.
    417                else if (currentBit > lastDeviation)
   \                     ??D1W_SearchRom_5:
   \   0000003C   1764               CP      R22, R20
   \   0000003E   F410               BRCC    ??D1W_SearchRom_6
    418                {
    419                  (*bitPattern) &= ~bitMask;
   \   00000040   2312               AND     R17, R18
    420                  newDeviation = currentBit;
   \   00000042   C003               RJMP    ??D1W_SearchRom_7
    421                }
    422                // If current bit in bit pattern = 0, then this is
    423                // out new deviation.
    424                else if ( !(*bitPattern & bitMask))
   \                     ??D1W_SearchRom_6:
   \   00000044   2F01               MOV     R16, R17
   \   00000046   2305               AND     R16, R21
   \   00000048   F409               BRNE    ??D1W_SearchRom_4
    425                {
    426                  newDeviation = currentBit;
   \                     ??D1W_SearchRom_7:
   \   0000004A   2F74               MOV     R23, R20
   \                     ??D1W_SearchRom_4:
   \   0000004C   8310               ST      Z, R17
    427                }
    428                // IF the bit is already 1, do nothing.
    429                else
    430                {
    431          
    432                }
    433              }
    434          
    435          
    436              // Send the selected bit to the bus.
    437              if ((*bitPattern) & bitMask)
   \   0000004E   2315               AND     R17, R21
   \   00000050   F011               BREQ    ??D1W_SearchRom_8
    438              {
    439                D1W_WriteBit1();
   \   00000052   ....               RCALL   D1W_WriteBit1
   \   00000054   C001               RJMP    ??D1W_SearchRom_9
    440              }
    441              else
    442              {
    443                D1W_WriteBit0();
   \                     ??D1W_SearchRom_8:
   \   00000056   ....               RCALL   D1W_WriteBit0
    444              }
    445          
    446              // Increment current bit.
    447              currentBit++;
   \                     ??D1W_SearchRom_9:
   \   00000058   9543               INC     R20
    448          
    449              // Adjust bitMask and bitPattern pointer.
    450              bitMask <<= 1;
   \   0000005A   0F55               LSL     R21
    451              if (!bitMask)
   \   0000005C   F411               BRNE    ??D1W_SearchRom_10
    452              {
    453                bitMask = 0x01;
   \   0000005E   E051               LDI     R21, 1
    454                bitPattern++;
   \   00000060   9631               ADIW    R31:R30, 1
    455              }
    456            }
   \                     ??D1W_SearchRom_10:
   \   00000062   3441               CPI     R20, 65
   \   00000064   F2A0               BRCS    ??D1W_SearchRom_0
    457            return newDeviation;
   \   00000066   2F07               MOV     R16, R23
   \   00000068   9508               RET
    458          }
    459          

   \                                 In  segment CODE, align 2, keep-with-next
    460          unsigned char D1W_ComputeCRC8(unsigned char inData, unsigned char seed)
   \                     D1W_ComputeCRC8:
    461          {
    462            unsigned char bitsLeft;
    463            unsigned char temp;
    464          
    465            for (bitsLeft = 8; bitsLeft > 0; bitsLeft--)
   \   00000000   E028               LDI     R18, 8
    466            {
    467              temp = ((seed ^ inData) & 0x01);
    468              if (temp == 0)
   \                     ??D1W_ComputeCRC8_0:
   \   00000002   2F31               MOV     R19, R17
   \   00000004   9536               LSR     R19
   \   00000006   7011               ANDI    R17, 0x01
   \   00000008   2F41               MOV     R20, R17
   \   0000000A   2F10               MOV     R17, R16
   \   0000000C   7011               ANDI    R17, 0x01
   \   0000000E   2741               EOR     R20, R17
   \   00000010   2F13               MOV     R17, R19
   \   00000012   F011               BREQ    ??D1W_ComputeCRC8_1
    469              {
    470                seed >>= 1;
    471              }
    472              else
    473              {
    474                seed ^= 0x18;
    475                seed >>= 1;
    476                seed |= 0x80;
   \   00000014   E83C               LDI     R19, 140
   \   00000016   2713               EOR     R17, R19
    477              }
    478              inData >>= 1;
   \                     ??D1W_ComputeCRC8_1:
   \   00000018   9506               LSR     R16
    479            }
   \   0000001A   952A               DEC     R18
   \   0000001C   F791               BRNE    ??D1W_ComputeCRC8_0
    480            return seed;
   \   0000001E   2F01               MOV     R16, R17
   \   00000020   9508               RET
    481          }
    482          
    483          

   \                                 In  segment CODE, align 2, keep-with-next
    484          unsigned char D1W_CheckRomCRC(unsigned char * romValue)
   \                     D1W_CheckRomCRC:
    485          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
    486            unsigned char i;
    487            unsigned char crc8 = 0;
   \   00000002   E010               LDI     R17, 0
    488          
    489            for (i = 0; i < 7; i++)
   \   00000004   E057               LDI     R21, 7
    490            {
    491              crc8 = D1W_ComputeCRC8(*romValue, crc8);
   \                     ??D1W_CheckRomCRC_0:
   \   00000006   9101               LD      R16, Z+
   \   00000008   ....               RCALL   D1W_ComputeCRC8
   \   0000000A   2F10               MOV     R17, R16
    492              romValue++;
    493            }
   \   0000000C   955A               DEC     R21
   \   0000000E   F7D9               BRNE    ??D1W_CheckRomCRC_0
    494            if (crc8 == (*romValue))
   \   00000010   8100               LD      R16, Z
   \   00000012   1710               CP      R17, R16
   \   00000014   F411               BRNE    ??D1W_CheckRomCRC_1
    495            {
    496              return D1W_CRC_OK;
   \   00000016   E001               LDI     R16, 1
   \   00000018   9508               RET
    497            }
    498            return D1W_CRC_ERROR;
   \                     ??D1W_CheckRomCRC_1:
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   9508               RET
    499          }
    500          
    501          /*! \brief Initialization of the one wire bus(es). (Software only driver)
    502          *
    503          *  This function initializes the 1-Wire bus(es) by releasing it and
    504          *  waiting until any presence sinals are finished.
    505          *
    506          *  \param  pins    A bitmask of the buses to initialize.
    507          */

   \                                 In  segment CODE, align 2, keep-with-next
    508          void D1W_Init(void)
   \                     D1W_Init:
    509          {
    510            D1W_RELEASE_BUS;
   \   00000000   988C               CBI     0x11, 0x04
   \   00000002   9894               CBI     0x12, 0x04
    511            // The first rising edge can be interpreted by a slave as the end of a
    512            // Reset pulse. Delay for the required reset recovery time (H) to be
    513            // sure that the real reset is interpreted correctly.
    514            __delay_cycles(D1W_DELAY_H_STD_MODE);
   \   00000004   E70C               LDI     R16, 124
   \   00000006   E017               LDI     R17, 7
   \   00000008   5001               SUBI    R16, 1
   \   0000000A   4010               SBCI    R17, 0
   \   0000000C   F7E9               BRNE    $-4
   \   0000000E   C000               RJMP    $+2
    515          }
   \   00000010   9508               RET
   \   00000012                      REQUIRE _A_DDRD
   \   00000012                      REQUIRE _A_PORTD
    516          
    517          
    518          /*! \brief  Write a '1' bit to the bus(es). (Software only driver)
    519          *
    520          *  Generates the waveform for transmission of a '1' bit on the 1-Wire
    521          *  bus.
    522          *
    523          *  \param  pins    A bitmask of the buses to write to.
    524          */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   BF0F               OUT     0x3F, R16
   \   00000002   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    525          void D1W_WriteBit1(void)
   \                     D1W_WriteBit1:
    526          {
    527            unsigned char intState;
    528          
    529            // Disable interrupts.
    530            intState = __save_interrupt();
   \   00000000   B70F               IN      R16, 0x3F
    531            __disable_interrupt();
   \   00000002   94F8               CLI
    532          
    533            // Drive bus low and delay.
    534            D1W_PULL_BUS_LOW;
   \   00000004   9A8C               SBI     0x11, 0x04
   \   00000006   9894               CBI     0x12, 0x04
    535            __delay_cycles(D1W_DELAY_A_STD_MODE);
   \   00000008   E11B               LDI     R17, 27
   \   0000000A   951A               DEC     R17
   \   0000000C   F7F1               BRNE    $-2
   \   0000000E   C000               RJMP    $+2
    536          
    537            // Release bus and delay.
    538            D1W_RELEASE_BUS;
   \   00000010   988C               CBI     0x11, 0x04
   \   00000012   9894               CBI     0x12, 0x04
    539            __delay_cycles(D1W_DELAY_B_STD_MODE);
   \   00000014   EC1A               LDI     R17, 202
   \   00000016   C000               RJMP    $+2
   \   00000018   951A               DEC     R17
   \   0000001A   F7E9               BRNE    $-4
   \   0000001C   0000               NOP
    540          
    541            // Restore interrupts.
    542            __restore_interrupt(intState);
   \   0000001E   ....               RJMP    ?Subroutine0
   \   00000020                      REQUIRE _A_DDRD
   \   00000020                      REQUIRE _A_PORTD
    543          }
    544          
    545          
    546          /*! \brief  Write a '0' to the bus(es). (Software only driver)
    547          *
    548          *  Generates the waveform for transmission of a '0' bit on the 1-Wire(R)
    549          *  bus.
    550          *
    551          *  \param  pins    A bitmask of the buses to write to.
    552          */

   \                                 In  segment CODE, align 2, keep-with-next
    553          void D1W_WriteBit0(void)
   \                     D1W_WriteBit0:
    554          {
    555            unsigned char intState;
    556          
    557            // Disable interrupts.
    558            intState = __save_interrupt();
   \   00000000   B70F               IN      R16, 0x3F
    559            __disable_interrupt();
   \   00000002   94F8               CLI
    560          
    561            // Drive bus low and delay.
    562            D1W_PULL_BUS_LOW;
   \   00000004   9A8C               SBI     0x11, 0x04
   \   00000006   9894               CBI     0x12, 0x04
    563            __delay_cycles(D1W_DELAY_C_STD_MODE);
   \   00000008   EB1D               LDI     R17, 189
   \   0000000A   C000               RJMP    $+2
   \   0000000C   951A               DEC     R17
   \   0000000E   F7E9               BRNE    $-4
   \   00000010   C000               RJMP    $+2
    564          
    565            // Release bus and delay.
    566            D1W_RELEASE_BUS;
   \   00000012   988C               CBI     0x11, 0x04
   \   00000014   9894               CBI     0x12, 0x04
    567            __delay_cycles(D1W_DELAY_D_STD_MODE);
   \   00000016   E311               LDI     R17, 49
   \   00000018   951A               DEC     R17
   \   0000001A   F7F1               BRNE    $-2
    568          
    569            // Restore interrupts.
    570            __restore_interrupt(intState);
   \   0000001C                      REQUIRE ?Subroutine0
   \   0000001C                      REQUIRE _A_DDRD
   \   0000001C                      REQUIRE _A_PORTD
   \   0000001C                      ;               // Fall through to label ?Subroutine0
    571          }
    572          
    573          
    574          /*! \brief  Read a bit from the bus(es). (Software only driver)
    575          *
    576          *  Generates the waveform for reception of a bit on the 1-Wire(R) bus(es).
    577          *
    578          *  \return A bitmask of the buses where a '1' was read.
    579          */

   \                                 In  segment CODE, align 2, keep-with-next
    580          unsigned char D1W_ReadBit(void)
   \                     D1W_ReadBit:
    581          {
    582            unsigned char intState;
    583            unsigned char bitsRead;
    584          
    585            // Disable interrupts.
    586            intState = __save_interrupt();
   \   00000000   B71F               IN      R17, 0x3F
    587            __disable_interrupt();
   \   00000002   94F8               CLI
    588          
    589            // Drive bus low and delay.
    590            D1W_PULL_BUS_LOW;
   \   00000004   9A8C               SBI     0x11, 0x04
   \   00000006   9894               CBI     0x12, 0x04
    591            __delay_cycles(D1W_DELAY_A_STD_MODE);
   \   00000008   E10B               LDI     R16, 27
   \   0000000A   950A               DEC     R16
   \   0000000C   F7F1               BRNE    $-2
   \   0000000E   C000               RJMP    $+2
    592          
    593            // Release bus and delay.
    594            D1W_RELEASE_BUS;
   \   00000010   988C               CBI     0x11, 0x04
   \   00000012   9894               CBI     0x12, 0x04
    595            __delay_cycles(D1W_DELAY_E_STD_MODE);
   \   00000014   E20B               LDI     R16, 43
   \   00000016   950A               DEC     R16
   \   00000018   F7F1               BRNE    $-2
   \   0000001A   C000               RJMP    $+2
    596          
    597            // Sample bus and delay.
    598            bitsRead = D1W_PIN & D1W_BUS;
   \   0000001C   B300               IN      R16, 0x10
    599            __delay_cycles(D1W_DELAY_F_STD_MODE);
   \   0000001E   EA2D               LDI     R18, 173
   \   00000020   C000               RJMP    $+2
   \   00000022   952A               DEC     R18
   \   00000024   F7E9               BRNE    $-4
   \   00000026   C000               RJMP    $+2
    600          
    601            // Restore interrupts.
    602            __restore_interrupt(intState);
   \   00000028   BF1F               OUT     0x3F, R17
    603          
    604            return bitsRead;
   \   0000002A                      REQUIRE ?Subroutine1
   \   0000002A                      REQUIRE _A_DDRD
   \   0000002A                      REQUIRE _A_PORTD
   \   0000002A                      REQUIRE _A_PIND
   \   0000002A                      ;               // Fall through to label ?Subroutine1
    605          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   7100               ANDI    R16, 0x10
   \   00000002   9508               RET
    606          
    607          
    608          /*! \brief  Send a Reset signal and listen for Presence signal. (software
    609          *  only driver)
    610          *
    611          *  Generates the waveform for transmission of a Reset pulse on the
    612          *  1-Wire(R) bus and listens for presence signals.
    613          *
    614          *  \param  pins    A bitmask of the buses to send the Reset signal on.
    615          *
    616          *  \return A bitmask of the buses where a presence signal was detected.
    617          */

   \                                 In  segment CODE, align 2, keep-with-next
    618          unsigned char D1W_DetectPresence(void)
   \                     D1W_DetectPresence:
    619          {
    620            unsigned char intState;
    621            unsigned char presenceDetected;
    622          
    623            // Disable interrupts.
    624            intState = __save_interrupt();
   \   00000000   B71F               IN      R17, 0x3F
    625            __disable_interrupt();
   \   00000002   94F8               CLI
    626          
    627            // Drive bus low and delay.
    628            D1W_PULL_BUS_LOW;
   \   00000004   9A8C               SBI     0x11, 0x04
   \   00000006   9894               CBI     0x12, 0x04
    629            __delay_cycles(D1W_DELAY_H_STD_MODE);
   \   00000008   E72C               LDI     R18, 124
   \   0000000A   E037               LDI     R19, 7
   \   0000000C   5021               SUBI    R18, 1
   \   0000000E   4030               SBCI    R19, 0
   \   00000010   F7E9               BRNE    $-4
   \   00000012   C000               RJMP    $+2
    630          
    631            // Release bus and delay.
    632            D1W_RELEASE_BUS;
   \   00000014   988C               CBI     0x11, 0x04
   \   00000016   9894               CBI     0x12, 0x04
    633            __delay_cycles(D1W_DELAY_I_STD_MODE);
   \   00000018   ED0D               LDI     R16, 221
   \   0000001A   C000               RJMP    $+2
   \   0000001C   950A               DEC     R16
   \   0000001E   F7E9               BRNE    $-4
   \   00000020   C000               RJMP    $+2
    634          
    635            // Sample bus to detect presence signal and delay.
    636            presenceDetected = ((~D1W_PIN) & D1W_BUS);
   \   00000022   B300               IN      R16, 0x10
    637            __delay_cycles(D1W_DELAY_J_STD_MODE);
   \   00000024   E624               LDI     R18, 100
   \   00000026   E036               LDI     R19, 6
   \   00000028   5021               SUBI    R18, 1
   \   0000002A   4030               SBCI    R19, 0
   \   0000002C   F7E9               BRNE    $-4
   \   0000002E   C000               RJMP    $+2
    638          
    639            // Restore interrupts.
    640            __restore_interrupt(intState);
   \   00000030   BF1F               OUT     0x3F, R17
    641          
    642            return presenceDetected;
   \   00000032   9500               COM     R16
   \   00000034   ....               RJMP    ?Subroutine1
   \   00000036                      REQUIRE _A_DDRD
   \   00000036                      REQUIRE _A_PORTD
   \   00000036                      REQUIRE _A_PIND
    643          }
    644          

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   D1W_CheckRomCRC
        0      2   -> D1W_ComputeCRC8
      0      2   D1W_ComputeCRC8
      0      2   D1W_DetectPresence
      0      2   D1W_Init
      0      2   D1W_MatchRom
        0      2   -> D1W_SendByte
      0      2   D1W_ReadBit
      0      2   D1W_ReadRom
        0      2   -> D1W_ReceiveByte
        0      2   -> D1W_SendByte
      0      2   D1W_ReceiveByte
        0      2   -> D1W_ReadBit
      0      2   D1W_SearchRom
        0      2   -> D1W_ReadBit
        0      2   -> D1W_SendByte
        0      2   -> D1W_WriteBit0
        0      2   -> D1W_WriteBit1
      0      2   D1W_SendByte
        0      2   -> D1W_WriteBit0
        0      2   -> D1W_WriteBit1
      0      2   D1W_SkipRom
        0      2   -> D1W_SendByte
      0      2   D1W_WriteBit0
      0      2   D1W_WriteBit1
      0      2   DS1820_ReadTemperature
        0      2   -> D1W_DetectPresence
        0      2   -> D1W_MatchRom
        0      2   -> D1W_ReadBit
        0      2   -> D1W_ReceiveByte
        0      2   -> D1W_SendByte
      0      2   DS1W_FindFamily
      6      2   DS1W_SearchBuses
        6      2   -> D1W_CheckRomCRC
        6      2   -> D1W_DetectPresence
        6      2   -> D1W_SearchRom
        6      2   -> memcpy
      0      2   DS2890_SetWiperPosition
        0      2   -> D1W_DetectPresence
        0      2   -> D1W_MatchRom
        0      2   -> D1W_ReceiveByte
        0      2   -> D1W_SendByte


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?Subroutine0
       4  ?Subroutine1
      30  D1W_CheckRomCRC
      34  D1W_ComputeCRC8
      54  D1W_DetectPresence
      18  D1W_Init
      18  D1W_MatchRom
      42  D1W_ReadBit
      18  D1W_ReadRom
      22  D1W_ReceiveByte
     106  D1W_SearchRom
      22  D1W_SendByte
       4  D1W_SkipRom
      28  D1W_WriteBit0
      32  D1W_WriteBit1
      54  DS1820_ReadTemperature
      32  DS1W_FindFamily
     128  DS1W_SearchBuses
      70  DS2890_SetWiperPosition
       1  _A_DDRD
       1  _A_PIND
       1  _A_PORTD

 
   3 bytes in segment ABSOLUTE
 720 bytes in segment CODE
 
 720 bytes of CODE memory
   0 bytes of DATA memory (+ 3 bytes shared)

Errors: none
Warnings: none
