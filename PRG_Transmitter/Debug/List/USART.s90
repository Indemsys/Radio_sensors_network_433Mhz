///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR      26/Oct/2021  17:01:07
// Copyright 1996-2021 IAR Systems AB.
//
//    Source file  =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\USART.c
//    Command line =  
//        -f C:\Users\aly\AppData\Local\Temp\EW92E5.tmp
//        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\USART.c
//        --cpu=m8 -ms -o
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj
//        -lCN
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        -lB
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        --initializers_in_flash --no_cross_call --no_clustering --no_tbaa
//        --debug -DENABLE_BIT_DEFINITIONS -e --eeprom_size 512 --clib -Ohz)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List\USART.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME USART

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBWEAK `??USART_RX_interrupt::??INTVEC 22`
        PUBWEAK `??USART_TXC_interrupt::??INTVEC 26`
        PUBWEAK `??USART_TX_interrupt::??INTVEC 24`
        PUBLIC DataInReceiveBuffer
        PUBLIC USART_Init
        PUBLIC USART_RX_interrupt
        PUBLIC USART_Receive
        PUBLIC USART_TXC_interrupt
        PUBLIC USART_TX_interrupt
        PUBLIC USART_Transmit
        PUBLIC USART_close
        PUBLIC USART_sendstr
        PUBWEAK _A_UBRRL
        PUBWEAK _A_UCSRA
        PUBWEAK _A_UCSRB
        PUBWEAK _A_UCSRC
        PUBWEAK _A_UDR
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC wait_until_tx_complete

USART_RX_interrupt  SYMBOL "USART_RX_interrupt"
`??USART_RX_interrupt::??INTVEC 22` SYMBOL "??INTVEC 22", USART_RX_interrupt
USART_TXC_interrupt SYMBOL "USART_TXC_interrupt"
`??USART_TXC_interrupt::??INTVEC 26` SYMBOL "??INTVEC 26", USART_TXC_interrupt
USART_TX_interrupt  SYMBOL "USART_TX_interrupt"
`??USART_TX_interrupt::??INTVEC 24` SYMBOL "??INTVEC 24", USART_TX_interrupt

// D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\USART.c
//    1 #include <iom8.h>

        ASEGN ABSOLUTE:DATA:NOROOT,040H
// union <unnamed> volatile __io _A_UCSRC
_A_UCSRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,02cH
// union <unnamed> volatile __io _A_UDR
_A_UDR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,02bH
// union <unnamed> volatile __io _A_UCSRA
_A_UCSRA:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,02aH
// union <unnamed> volatile __io _A_UCSRB
_A_UCSRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,029H
// union <unnamed> volatile __io _A_UBRRL
_A_UBRRL:
        DS8 1
//    2 #include <ina90.h>
//    3 
//    4 #include "main.h"
//    5 
//    6 
//    7 #define USART_RX_BUFFER_SIZE 32     /* 2,4,8,16,32,64,128 or 256 bytes */
//    8 #define USART_TX_BUFFER_SIZE 32     /* 2,4,8,16,32,64,128 or 256 bytes */
//    9 #define USART_RX_BUFFER_MASK ( USART_RX_BUFFER_SIZE - 1 )
//   10 #define USART_TX_BUFFER_MASK ( USART_TX_BUFFER_SIZE - 1 )
//   11 #if ( USART_RX_BUFFER_SIZE & USART_RX_BUFFER_MASK )
//   12 #error RX buffer size is not a power of 2
//   13 #endif
//   14 #if ( USART_TX_BUFFER_SIZE & USART_TX_BUFFER_MASK )
//   15 #error TX buffer size is not a power of 2
//   16 #endif
//   17 
//   18 /* Static Variables */

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   19 static unsigned char USART_RxBuf[USART_RX_BUFFER_SIZE];
USART_RxBuf:
        DS8 32

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   20 static volatile unsigned char USART_RxHead;
USART_RxHead:
        DS8 1

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   21 static volatile unsigned char USART_RxTail;
USART_RxTail:
        DS8 1

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   22 static unsigned char USART_TxBuf[USART_TX_BUFFER_SIZE];
USART_TxBuf:
        DS8 32

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   23 static volatile unsigned char USART_TxHead;
USART_TxHead:
        DS8 1

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   24 static volatile unsigned char USART_TxTail;
USART_TxTail:
        DS8 1
//   25 

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   26 static volatile unsigned char tx_complete;
tx_complete:
        DS8 1
//   27 
//   28 #include "USART.h"
//   29 
//   30 
//   31 /*
//   32 Инициализация UART
//   33 
//   34 корость расчитываеться по формуле UBRR = Fosc/(8*BAUD) - 1
//   35 */

        RSEG `CODE`:CODE:NOROOT(1)
//   36 void USART_Init( unsigned int baudrate )
USART_Init:
        CODE
//   37 {
//   38   unsigned char x;
//   39 
//   40   UBRRH = (unsigned char) (baudrate>>8);
        OUT     0x20, R17
//   41   UBRRL = (unsigned char) baudrate;
        OUT     0x09, R16
//   42 
//   43   UCSRA = (1 << U2X);
        LDI     R16, 2
        OUT     0x0B, R16
//   44   /* Enable UART receiver and transmitter */
//   45   UCSRB = ( ( 1 << RXCIE ) | ( 1 << RXEN ) | ( 1 << TXEN ) | ( 1 << TXCIE ));
        LDI     R16, 216
        OUT     0x0A, R16
//   46 
//   47   /* Set frame format: 8 data 2stop */
//   48   UCSRC = (1<<URSEL)|(1<<USBS)|(1<<UCSZ1)|(1<<UCSZ0);
        LDI     R16, 142
        OUT     0x20, R16
//   49 
//   50   /* Flush receive buffer */
//   51   x = 0;
//   52 
//   53   USART_RxTail = x;
        LDI     R16, 0
        STS     USART_RxTail, R16
//   54   USART_RxHead = x;
        STS     USART_RxHead, R16
//   55   USART_TxTail = x;
        STS     USART_TxTail, R16
//   56   USART_TxHead = x;
        STS     USART_TxHead, R16
//   57 }
        RET
        REQUIRE _A_UCSRC
        REQUIRE _A_UBRRL
        REQUIRE _A_UCSRA
        REQUIRE _A_UCSRB
//   58 
//   59 

        RSEG `CODE`:CODE:NOROOT(1)
//   60 void USART_close(void)
USART_close:
        CODE
//   61 {
//   62   UCSRA = 0;
        LDI     R16, 0
        OUT     0x0B, R16
//   63   UCSRB = 0;
        OUT     0x0A, R16
//   64   UCSRC = 0;
        OUT     0x20, R16
//   65 }
        RET
        REQUIRE _A_UCSRA
        REQUIRE _A_UCSRB
        REQUIRE _A_UCSRC
//   66 
//   67 /* Interrupt handlers */
//   68 #pragma vector=USART_RXC_vect

        RSEG `CODE`:CODE:NOROOT(1)
        CALL_GRAPH_ROOT USART_RX_interrupt, "interrupt"
//   69 __interrupt void USART_RX_interrupt( void )
USART_RX_interrupt:
        CODE
//   70 {
        ST      -Y, R31
        ST      -Y, R30
        ST      -Y, R19
        ST      -Y, R18
        ST      -Y, R17
        ST      -Y, R16
        IN      R19, 0x3F
//   71   unsigned char data;
//   72   unsigned char tmphead;
//   73 
//   74   /* Read the received data */
//   75   data = UDR;
        IN      R18, 0x0C
//   76   /* Calculate buffer index */
//   77   tmphead = ( USART_RxHead + 1 ) & USART_RX_BUFFER_MASK;
        LDS     R16, USART_RxHead
        INC     R16
        ANDI    R16, 0x1F
//   78   USART_RxHead = tmphead;      /* Store new index */
        STS     USART_RxHead, R16
//   79 
//   80   if ( tmphead == USART_RxTail )
        LDS     R17, USART_RxTail
//   81   {
//   82     /* ERROR! Receive buffer overflow */
//   83   }
//   84 
//   85   USART_RxBuf[tmphead] = data; /* Store received data in buffer */
        LDI     R31, 0
        MOV     R30, R16
        SUBI    R30, LOW((-(USART_RxBuf) & 0xFFFF))
        SBCI    R31, (-(USART_RxBuf) & 0xFFFF) >> 8
        ST      Z, R18
//   86 
//   87 }
        OUT     0x3F, R19
        LD      R16, Y+
        LD      R17, Y+
        LD      R18, Y+
        LD      R19, Y+
        REQUIRE ?Subroutine0
        REQUIRE _A_UDR
        ;               // Fall through to label ?Subroutine0

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine0:
        LD      R30, Y+
        LD      R31, Y+
        RETI
//   88 

        RSEG `CODE`:CODE:NOROOT(1)
//   89 void wait_until_tx_complete(void)
wait_until_tx_complete:
        CODE
//   90 {
//   91   while (tx_complete != 0 );
??wait_until_tx_complete_0:
        LDS     R16, tx_complete
        TST     R16
        BRNE    ??wait_until_tx_complete_0
//   92 }
        RET
//   93 
//   94 
//   95 #pragma vector=USART_TXC_vect

        RSEG `CODE`:CODE:NOROOT(1)
        CALL_GRAPH_ROOT USART_TXC_interrupt, "interrupt"
//   96 __interrupt void USART_TXC_interrupt( void )
USART_TXC_interrupt:
        CODE
//   97 {
        ST      -Y, R16
//   98   if ((UCSRB & (1<<UDRIE)) == 0) tx_complete = 0;
        SBIC    0x0A, 0x05
        RJMP    ??USART_TXC_interrupt_0
        LDI     R16, 0
        STS     tx_complete, R16
//   99 }
??USART_TXC_interrupt_0:
        LD      R16, Y+
        RETI
        REQUIRE _A_UCSRB
//  100 
//  101 
//  102 #pragma vector=USART_UDRE_vect

        RSEG `CODE`:CODE:NOROOT(1)
        CALL_GRAPH_ROOT USART_TX_interrupt, "interrupt"
//  103 __interrupt void USART_TX_interrupt( void )
USART_TX_interrupt:
        CODE
//  104 {
        ST      -Y, R31
        ST      -Y, R30
        ST      -Y, R18
        ST      -Y, R17
        ST      -Y, R16
        IN      R18, 0x3F
//  105   unsigned char tmptail;
//  106 
//  107   /* Check if all data is transmitted */
//  108   tmptail = USART_TxTail;
        LDS     R16, USART_TxTail
//  109   if ( USART_TxHead != tmptail )
        LDS     R17, USART_TxHead
        CP      R17, R16
        BREQ    ??USART_TX_interrupt_0
//  110   {
//  111     /* Calculate buffer index */
//  112     tmptail = ( USART_TxTail + 1 ) & USART_TX_BUFFER_MASK;
        LDS     R16, USART_TxTail
        INC     R16
        ANDI    R16, 0x1F
//  113     USART_TxTail = tmptail;      /* Store new index */
        STS     USART_TxTail, R16
//  114 
//  115     UDR = USART_TxBuf[tmptail];  /* Start transmition */
        LDI     R31, 0
        MOV     R30, R16
        SUBI    R30, LOW((-(USART_TxBuf) & 0xFFFF))
        SBCI    R31, (-(USART_TxBuf) & 0xFFFF) >> 8
        LD      R16, Z
        OUT     0x0C, R16
        RJMP    ??USART_TX_interrupt_1
//  116   }
//  117   else
//  118   {
//  119     UCSRB &= ~(1<<UDRIE);         /* Disable UDRE interrupt */
??USART_TX_interrupt_0:
        CBI     0x0A, 0x05
//  120   }
//  121 }
??USART_TX_interrupt_1:
        OUT     0x3F, R18
        LD      R16, Y+
        LD      R17, Y+
        LD      R18, Y+
        RJMP    ?Subroutine0
        REQUIRE _A_UDR
        REQUIRE _A_UCSRB
//  122 
//  123 /* Read and write functions */

        RSEG `CODE`:CODE:NOROOT(1)
//  124 unsigned char USART_Receive( void )
USART_Receive:
        CODE
//  125 {
//  126   unsigned char tmptail;
//  127 
//  128 
//  129   tmptail =  USART_RxTail;
        LDS     R16, USART_RxTail
//  130   while ( USART_RxHead == tmptail );
??USART_Receive_0:
        LDS     R17, USART_RxHead
        CP      R17, R16
        BREQ    ??USART_Receive_0
//  131   tmptail = ( USART_RxTail + 1 ) & USART_RX_BUFFER_MASK;/* Calculate buffer index */
        LDS     R16, USART_RxTail
        INC     R16
        ANDI    R16, 0x1F
//  132 
//  133   USART_RxTail = tmptail;                /* Store new index */
        STS     USART_RxTail, R16
//  134 
//  135   return USART_RxBuf[tmptail];           /* Return data */
        LDI     R31, 0
        MOV     R30, R16
        SUBI    R30, LOW((-(USART_RxBuf) & 0xFFFF))
        SBCI    R31, (-(USART_RxBuf) & 0xFFFF) >> 8
        LD      R16, Z
        RET
//  136 }
//  137 

        RSEG `CODE`:CODE:NOROOT(1)
//  138 void USART_Transmit( unsigned char data )
USART_Transmit:
        CODE
//  139 {
//  140   unsigned char tmphead;
//  141   /* Calculate buffer index */
//  142   tmphead = ( USART_TxHead + 1 ) & USART_TX_BUFFER_MASK; /* Wait for free space in buffer */
        LDS     R18, USART_TxHead
        INC     R18
        ANDI    R18, 0x1F
//  143   while ( tmphead == USART_TxTail );
??USART_Transmit_0:
        LDS     R17, USART_TxTail
        CP      R18, R17
        BREQ    ??USART_Transmit_0
//  144 
//  145   USART_TxBuf[tmphead] = data;           /* Store data in buffer */
        LDI     R31, 0
        MOV     R30, R18
        SUBI    R30, LOW((-(USART_TxBuf) & 0xFFFF))
        SBCI    R31, (-(USART_TxBuf) & 0xFFFF) >> 8
        ST      Z, R16
//  146   USART_TxHead = tmphead;                /* Store new index */
        STS     USART_TxHead, R18
//  147 
//  148   UCSRB |= (1<<UDRIE);                   /* Enable UDRE interrupt */
        SBI     0x0A, 0x05
//  149   tx_complete = 1;
        LDI     R16, 1
        STS     tx_complete, R16
//  150 }
        RET
        REQUIRE _A_UCSRB
//  151 

        RSEG `CODE`:CODE:NOROOT(1)
//  152 unsigned char DataInReceiveBuffer( void )
DataInReceiveBuffer:
        CODE
//  153 {
//  154   unsigned char tmptail;
//  155 
//  156   tmptail =  USART_RxTail;
        LDS     R16, USART_RxTail
//  157   return ( USART_RxHead != tmptail ); /* Return 0 (FALSE) if the receive buffer is empty */
        LDS     R17, USART_RxHead
        CP      R17, R16
        BREQ    ??DataInReceiveBuffer_0
        LDI     R16, 1
        RET
??DataInReceiveBuffer_0:
        LDI     R16, 0
        RET
//  158 }
//  159 

        RSEG `CODE`:CODE:NOROOT(1)
//  160 void USART_sendstr(char *strbuf)
USART_sendstr:
        CODE
//  161 {
        RCALL   ?PROLOGUE4_L09
        MOVW    R27:R26, R17:R16
        RJMP    ??USART_sendstr_0
//  162   while (*strbuf!=0) USART_Transmit(*strbuf++);
??USART_sendstr_1:
        ADIW    R27:R26, 1
        RCALL   USART_Transmit
??USART_sendstr_0:
        MOVW    R31:R30, R27:R26
        LD      R16, Z
        TST     R16
        BRNE    ??USART_sendstr_1
//  163 
//  164 }
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        COMMON INTVEC:CODE:ROOT(1)
        ORG 22
`??USART_RX_interrupt::??INTVEC 22`:
        CODE
        RJMP    USART_RX_interrupt

        COMMON INTVEC:CODE:ROOT(1)
        ORG 24
`??USART_TX_interrupt::??INTVEC 24`:
        CODE
        RJMP    USART_TX_interrupt

        COMMON INTVEC:CODE:ROOT(1)
        ORG 26
`??USART_TXC_interrupt::??INTVEC 26`:
        CODE
        RJMP    USART_TXC_interrupt

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        END
// 
//   5 bytes in segment ABSOLUTE
// 310 bytes in segment CODE
//   6 bytes in segment INITTAB
//   6 bytes in segment INTVEC
//  69 bytes in segment NEAR_Z
// 
// 310 bytes of CODE memory (+ 12 bytes shared)
//  69 bytes of DATA memory (+  5 bytes shared)
//
//Errors: none
//Warnings: none
