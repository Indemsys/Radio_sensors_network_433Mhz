///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR      26/Oct/2021  17:01:07
// Copyright 1996-2021 IAR Systems AB.
//
//    Source file  =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\DS1Wire.c
//    Command line =  
//        -f C:\Users\aly\AppData\Local\Temp\EW92E3.tmp
//        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\DS1Wire.c
//        --cpu=m8 -ms -o
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj
//        -lCN
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        -lB
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        --initializers_in_flash --no_cross_call --no_clustering --no_tbaa
//        --debug -DENABLE_BIT_DEFINITIONS -e --eeprom_size 512 --clib -Ohz)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List\DS1Wire.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME DS1Wire

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B6_L09
        EXTERN ?PROLOGUE6_L09
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg

        PUBLIC D1W_CheckRomCRC
        PUBLIC D1W_ComputeCRC8
        PUBLIC D1W_DetectPresence
        PUBLIC D1W_Init
        PUBLIC D1W_MatchRom
        PUBLIC D1W_ReadBit
        PUBLIC D1W_ReadRom
        PUBLIC D1W_ReceiveByte
        PUBLIC D1W_SearchRom
        PUBLIC D1W_SendByte
        PUBLIC D1W_SkipRom
        PUBLIC D1W_WriteBit0
        PUBLIC D1W_WriteBit1
        PUBLIC DS1820_ReadTemperature
        PUBLIC DS1W_FindFamily
        PUBLIC DS1W_SearchBuses
        PUBLIC DS2890_SetWiperPosition
        PUBWEAK _A_DDRD
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTD
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR

        EXTERN memcpy

// D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\DS1Wire.c
//    1 #include <ioavr.h>

        ASEGN ABSOLUTE:DATA:NOROOT,032H
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,031H
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,030H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1

        RSEG `CODE`:CODE:NOROOT(1)
D1W_WriteBit0:
        CODE
        IN      R16, 0x3F
        CLI
        SBI     0x11, 0x04
        CBI     0x12, 0x04
        LDI     R17, 189
        RJMP    $+2
        DEC     R17
        BRNE    $-4
        RJMP    $+2
        CBI     0x11, 0x04
        CBI     0x12, 0x04
        LDI     R17, 49
        DEC     R17
        BRNE    $-2
        REQUIRE ?Subroutine0
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
        ;               // Fall through to label ?Subroutine0
//    2 #include <inavr.h>
//    3 #include <string.h>
//    4 #include "DS1Wire.h"
//    5 
//    6 /*! \brief  Perform a 1-Wire search
//    7 *
//    8 *  This function shows how the D1W_SearchRom function can be used to
//    9 *  discover all slaves on the bus. It will also CRC check the 64 bit
//   10 *  identifiers.
//   11 *
//   12 *  \param  devices Pointer to an array of type D1W_device. The discovered
//   13 *                  devices will be placed from the beginning of this array.
//   14 *
//   15 *  \param  len     The length of the device array. (Max. number of elements).
//   16 *
//   17 *
//   18 *  \retval SEARCH_SUCCESSFUL   Search completed successfully.
//   19 *  \retval SEARCH_CRC_ERROR    A CRC error occured. Probably because of noise
//   20 *                              during transmission.
//   21 */
//   22 unsigned char DS1W_SearchBuses(D1W_device * devices, unsigned char len)
//   23 {
//   24   unsigned char i, j;
//   25   unsigned char presence;
//   26   unsigned char * newID;
//   27   unsigned char * currentID;
//   28   unsigned char lastDeviation;
//   29   unsigned char numDevices;
//   30 
//   31   // Initialize all addresses as zero, on bus 0 (does not exist).
//   32   for (i = 0; i < len; i++)
//   33   {
//   34     for (j = 0; j < 8; j++)
//   35     {
//   36       devices[i].id[j] = 0x00;
//   37     }
//   38   }
//   39 
//   40   // Find the buses with slave devices.
//   41   presence = D1W_DetectPresence();
//   42 
//   43   numDevices = 0;
//   44   newID = devices[0].id;
//   45 
//   46   // Go through all buses with slave devices.
//   47   lastDeviation = 0;
//   48   currentID = newID;
//   49   if (presence) // Devices available on this bus.
//   50   {
//   51     // Do slave search  and place identifiers in the array.
//   52     do
//   53     {
//   54       memcpy(newID, currentID, 8);
//   55       D1W_DetectPresence();
//   56       lastDeviation = D1W_SearchRom(newID, lastDeviation);
//   57       currentID = newID;
//   58       numDevices++;
//   59       newID=devices[numDevices].id;
//   60     }
//   61     while(lastDeviation != D1W_ROM_SEARCH_FINISHED);
//   62   }
//   63 
//   64   // Go through all the devices and do CRC check.
//   65   for (i = 0; i < numDevices; i++)
//   66   {
//   67     // If any id has a crc error, return error.
//   68     if(D1W_CheckRomCRC(devices[i].id) != D1W_CRC_OK)
//   69     {
//   70       return SEARCH_CRC_ERROR;
//   71     }
//   72   }
//   73   // Else, return Successful.
//   74   return SEARCH_SUCCESSFUL;
//   75 }
//   76 
//   77 /*! \brief  Find the first device of a family based on the family id
//   78 *
//   79 *  This function returns a pointer to a device in the device array
//   80 *  that matches the specified family.
//   81 *
//   82 *  \param  familyID    The 8 bit family ID to search for.
//   83 *
//   84 *  \param  devices     An array of devices to search through.
//   85 *
//   86 *  \param  size        The size of the array 'devices'
//   87 *
//   88 *  \return A pointer to a device of the family.
//   89 *  \retval NULL    if no device of the family was found.
//   90 */
//   91 D1W_device * DS1W_FindFamily(unsigned char familyID, D1W_device * devices, unsigned char size)
//   92 {
//   93   unsigned char i = 0;
//   94 
//   95   // Search through the array.
//   96   while (i < size)
//   97   {
//   98     // Return the pointer if there is a family id match.
//   99     if ((*devices).id[0] == familyID)
//  100     {
//  101       return devices;
//  102     }
//  103     devices++;
//  104     i++;
//  105   }
//  106   // Else, return NULL.
//  107   return NULL;
//  108 }
//  109 
//  110 
//  111 /*! \brief  Read the temperature from a DS1820 temperature sensor.
//  112 *
//  113 *  This function will start a conversion and read back the temperature
//  114 *  from a DS1820 temperature sensor.
//  115 *
//  116 *
//  117 *  \param  id  The 64 bit identifier of the DS1820.
//  118 *
//  119 *  \return The 16 bit signed temperature read from the DS1820.
//  120 */
//  121 signed int DS1820_ReadTemperature(unsigned char * id)
//  122 {
//  123   signed int temperature;
//  124 
//  125   // Reset, presence.
//  126   if (!D1W_DetectPresence())
//  127   {
//  128     return DS1820_ERROR; // Error
//  129   }
//  130   // Match the id found earlier.
//  131   D1W_MatchRom(id);
//  132   // Send start conversion command.
//  133   D1W_SendByte(DS1820_START_CONVERSION);
//  134   // Wait until conversion is finished.
//  135   // Bus line is held low until conversion is finished.
//  136   while (!D1W_ReadBit())
//  137   {
//  138 
//  139   }
//  140   // Reset, presence.
//  141   if(!D1W_DetectPresence())
//  142   {
//  143     return -1000; // Error
//  144   }
//  145   // Match id again.
//  146   D1W_MatchRom(id);
//  147   // Send READ SCRATCHPAD command.
//  148   D1W_SendByte(DS1820_READ_SCRATCHPAD);
//  149   // Read only two first bytes (temperature low, temperature high)
//  150   // and place them in the 16 bit temperature variable.
//  151   temperature = D1W_ReceiveByte();
//  152   temperature |= (D1W_ReceiveByte() << 8);
//  153 
//  154   return temperature;
//  155 }
//  156 
//  157 
//  158 /*! \brief  Set the wiper position of a DS2890.
//  159 *
//  160 *  This function initializes the DS2890 by enabling the charge pump. It then
//  161 *  changes the wiper position.
//  162 *
//  163 *  \param  position    The new wiper position.
//  164 *
//  165 *  \param  id          The 64 bit identifier of the DS2890.
//  166 */
//  167 void DS2890_SetWiperPosition(unsigned char position, unsigned char * id)
//  168 {
//  169   // Reset, presence.
//  170   if(!D1W_DetectPresence())
//  171   {
//  172     return;
//  173   }
//  174   //Match id.
//  175   D1W_MatchRom(id);
//  176 
//  177   // Send Write control register command.
//  178   D1W_SendByte(DS2890_WRITE_CONTROL_REGISTER);
//  179 
//  180   // Write 0x4c to control register to enable charge pump.
//  181   D1W_SendByte(0x4c);
//  182 
//  183   // Check that the value returned matches the value sent.
//  184   if (D1W_ReceiveByte() != 0x4c)
//  185   {
//  186     return;
//  187   }
//  188 
//  189   // Send release code to update control register.
//  190   D1W_SendByte(DS2890_RELEASE_CODE);
//  191 
//  192   // Check that zeros are returned to ensure that the operation was
//  193   // successful.
//  194   if (D1W_ReceiveByte() == 0xff)
//  195   {
//  196     return;
//  197   }
//  198 
//  199   // Reset, presence.
//  200   if (!D1W_DetectPresence())
//  201   {
//  202     return;
//  203   }
//  204 
//  205   // Match id.
//  206   D1W_MatchRom(id);
//  207 
//  208   // Send the Write Position command.
//  209   D1W_SendByte(DS2890_WRITE_POSITION);
//  210 
//  211   // Send the new position.
//  212   D1W_SendByte(position);
//  213 
//  214   // Check that the value returned matches the value sent.
//  215   if (D1W_ReceiveByte() != position)
//  216   {
//  217     return;
//  218   }
//  219 
//  220   // Send release code to update wiper position.
//  221   D1W_SendByte(DS2890_RELEASE_CODE);
//  222 
//  223   // Check that zeros are returned to ensure that the operation was
//  224   // successful.
//  225   if (D1W_ReceiveByte() == 0xff)
//  226   {
//  227     return;
//  228   }
//  229 }
//  230 
//  231 /*! \brief  Sends one byte of data on the 1-Wire(R) bus(es).
//  232 *
//  233 *  This function automates the task of sending a complete byte
//  234 *  of data on the 1-Wire bus(es).
//  235 *
//  236 *  \param  data    The data to send on the bus(es).
//  237 *
//  238 */
//  239 void D1W_SendByte(unsigned char data)
//  240 {
//  241   unsigned char temp;
//  242   unsigned char i;
//  243 
//  244   // Do once for each bit
//  245   for (i = 0; i < 8; i++)
//  246   {
//  247     // Determine if lsb is '0' or '1' and transmit corresponding
//  248     // waveform on the bus.
//  249     temp = data & 0x01;
//  250     if (temp)
//  251     {
//  252       D1W_WriteBit1();
//  253     }
//  254     else
//  255     {
//  256       D1W_WriteBit0();
//  257     }
//  258     // Right shift the data to get next bit.
//  259     data >>= 1;
//  260   }
//  261 }
//  262 
//  263 
//  264 /*! \brief  Receives one byte of data from the 1-Wire(R) bus.
//  265 *
//  266 *  This function automates the task of receiving a complete byte
//  267 *  of data from the 1-Wire bus.
//  268 *
//  269 *  \return     The byte read from the bus.
//  270 */
//  271 unsigned char D1W_ReceiveByte(void)
//  272 {
//  273   unsigned char data;
//  274   unsigned char i;
//  275 
//  276   // Clear the temporary input variable.
//  277   data = 0x00;
//  278 
//  279   // Do once for each bit
//  280   for (i = 0; i < 8; i++)
//  281   {
//  282     // Shift temporary input variable right.
//  283     data >>= 1;
//  284     // Set the msb if a '1' value is read from the bus.
//  285     // Leave as it is ('0') else.
//  286     if (D1W_ReadBit())
//  287     {
//  288       // Set msb
//  289       data |= 0x80;
//  290     }
//  291   }
//  292   return data;
//  293 }
//  294 
//  295 
//  296 /*! \brief  Sends the SKIP ROM command to the 1-Wire bus(es).
//  297 *
//  298 */
//  299 void D1W_SkipRom(void)
//  300 {
//  301   // Send the SKIP ROM command on the bus.
//  302   D1W_SendByte(D1W_ROM_SKIP);
//  303 }
//  304 
//  305 
//  306 /*! \brief  Sends the READ ROM command and reads back the ROM id.
//  307 *
//  308 *  \param  romValue    A pointer where the id will be placed.
//  309 *
//  310 */
//  311 void D1W_ReadRom(unsigned char * romValue)
//  312 {
//  313   unsigned char bytesLeft = 8;
//  314 
//  315   // Send the READ ROM command on the bus.
//  316   D1W_SendByte(D1W_ROM_READ);
//  317 
//  318   // Do 8 times.
//  319   while (bytesLeft > 0)
//  320   {
//  321     // Place the received data in memory.
//  322     *romValue++ = D1W_ReceiveByte();
//  323     bytesLeft--;
//  324   }
//  325 }
//  326 
//  327 
//  328 /*! \brief  Sends the MATCH ROM command and the ROM id to match against.
//  329 *
//  330 *  \param  romValue    A pointer to the ID to match against.
//  331 *
//  332 */
//  333 void D1W_MatchRom(unsigned char * romValue)
//  334 {
//  335   unsigned char bytesLeft = 8;
//  336 
//  337   // Send the MATCH ROM command.
//  338   D1W_SendByte(D1W_ROM_MATCH);
//  339 
//  340   // Do once for each byte.
//  341   while (bytesLeft > 0)
//  342   {
//  343     // Transmit 1 byte of the ID to match.
//  344     D1W_SendByte(*romValue++);
//  345     bytesLeft--;
//  346   }
//  347 }
//  348 
//  349 
//  350 /*! \brief  Sends the SEARCH ROM command and returns 1 id found on the
//  351 *          1-Wire(R) bus.
//  352 *
//  353 *  \param  bitPattern      A pointer to an 8 byte char array where the
//  354 *                          discovered identifier will be placed. When
//  355 *                          searching for several slaves, a copy of the
//  356 *                          last found identifier should be supplied in
//  357 *                          the array, or the search will fail.
//  358 *
//  359 *  \param  lastDeviation   The bit position where the algorithm made a
//  360 *                          choice the last time it was run. This argument
//  361 *                          should be 0 when a search is initiated. Supplying
//  362 *                          the return argument of this function when calling
//  363 *                          repeatedly will go through the complete slave
//  364 *                          search.
//  365 *
//  366 *  \return The last bit position where there was a discrepancy between slave addresses the last time this function was run. Returns D1W_ROM_SEARCH_FAILED if an error was detected (e.g. a device was connected to the bus during the search), or D1W_ROM_SEARCH_FINISHED when there are no more devices to be discovered.
//  367 *
//  368 *  \note   See main.c for an example of how to utilize this function.
//  369 */
//  370 unsigned char D1W_SearchRom(unsigned char * bitPattern, unsigned char lastDeviation)
//  371 {
//  372   unsigned char currentBit = 1;
//  373   unsigned char newDeviation = 0;
//  374   unsigned char bitMask = 0x01;
//  375   unsigned char bitA;
//  376   unsigned char bitB;
//  377 
//  378   // Send SEARCH ROM command on the bus.
//  379   D1W_SendByte(D1W_ROM_SEARCH);
//  380 
//  381   // Walk through all 64 bits.
//  382   while (currentBit <= 64)
//  383   {
//  384     // Read bit from bus twice.
//  385     bitA = D1W_ReadBit();
//  386     bitB = D1W_ReadBit();
//  387 
//  388     if (bitA && bitB)
//  389     {
//  390       // Both bits 1 (Error).
//  391       newDeviation = D1W_ROM_SEARCH_FAILED;
//  392       return newDeviation;
//  393     }
//  394     else if (bitA ^ bitB)
//  395     {
//  396       // Bits A and B are different. All devices have the same bit here.
//  397       // Set the bit in bitPattern to this value.
//  398       if (bitA)
//  399       {
//  400         (*bitPattern) |= bitMask;
//  401       }
//  402       else
//  403       {
//  404         (*bitPattern) &= ~bitMask;
//  405       }
//  406     }
//  407     else // Both bits 0
//  408     {
//  409       // If this is where a choice was made the last time,
//  410       // a '1' bit is selected this time.
//  411       if (currentBit == lastDeviation)
//  412       {
//  413         (*bitPattern) |= bitMask;
//  414       }
//  415       // For the rest of the id, '0' bits are selected when
//  416       // discrepancies occur.
//  417       else if (currentBit > lastDeviation)
//  418       {
//  419         (*bitPattern) &= ~bitMask;
//  420         newDeviation = currentBit;
//  421       }
//  422       // If current bit in bit pattern = 0, then this is
//  423       // out new deviation.
//  424       else if ( !(*bitPattern & bitMask))
//  425       {
//  426         newDeviation = currentBit;
//  427       }
//  428       // IF the bit is already 1, do nothing.
//  429       else
//  430       {
//  431 
//  432       }
//  433     }
//  434 
//  435 
//  436     // Send the selected bit to the bus.
//  437     if ((*bitPattern) & bitMask)
//  438     {
//  439       D1W_WriteBit1();
//  440     }
//  441     else
//  442     {
//  443       D1W_WriteBit0();
//  444     }
//  445 
//  446     // Increment current bit.
//  447     currentBit++;
//  448 
//  449     // Adjust bitMask and bitPattern pointer.
//  450     bitMask <<= 1;
//  451     if (!bitMask)
//  452     {
//  453       bitMask = 0x01;
//  454       bitPattern++;
//  455     }
//  456   }
//  457   return newDeviation;
//  458 }
//  459 
//  460 unsigned char D1W_ComputeCRC8(unsigned char inData, unsigned char seed)
//  461 {
//  462   unsigned char bitsLeft;
//  463   unsigned char temp;
//  464 
//  465   for (bitsLeft = 8; bitsLeft > 0; bitsLeft--)
//  466   {
//  467     temp = ((seed ^ inData) & 0x01);
//  468     if (temp == 0)
//  469     {
//  470       seed >>= 1;
//  471     }
//  472     else
//  473     {
//  474       seed ^= 0x18;
//  475       seed >>= 1;
//  476       seed |= 0x80;
//  477     }
//  478     inData >>= 1;
//  479   }
//  480   return seed;
//  481 }
//  482 
//  483 
//  484 unsigned char D1W_CheckRomCRC(unsigned char * romValue)
//  485 {
//  486   unsigned char i;
//  487   unsigned char crc8 = 0;
//  488 
//  489   for (i = 0; i < 7; i++)
//  490   {
//  491     crc8 = D1W_ComputeCRC8(*romValue, crc8);
//  492     romValue++;
//  493   }
//  494   if (crc8 == (*romValue))
//  495   {
//  496     return D1W_CRC_OK;
//  497   }
//  498   return D1W_CRC_ERROR;
//  499 }
//  500 
//  501 /*! \brief Initialization of the one wire bus(es). (Software only driver)
//  502 *
//  503 *  This function initializes the 1-Wire bus(es) by releasing it and
//  504 *  waiting until any presence sinals are finished.
//  505 *
//  506 *  \param  pins    A bitmask of the buses to initialize.
//  507 */
//  508 void D1W_Init(void)
//  509 {
//  510   D1W_RELEASE_BUS;
//  511   // The first rising edge can be interpreted by a slave as the end of a
//  512   // Reset pulse. Delay for the required reset recovery time (H) to be
//  513   // sure that the real reset is interpreted correctly.
//  514   __delay_cycles(D1W_DELAY_H_STD_MODE);
//  515 }
//  516 
//  517 
//  518 /*! \brief  Write a '1' bit to the bus(es). (Software only driver)
//  519 *
//  520 *  Generates the waveform for transmission of a '1' bit on the 1-Wire
//  521 *  bus.
//  522 *
//  523 *  \param  pins    A bitmask of the buses to write to.
//  524 */

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine0:
        OUT     0x3F, R16
        RET

        RSEG `CODE`:CODE:NOROOT(1)
//  525 void D1W_WriteBit1(void)
D1W_WriteBit1:
        CODE
//  526 {
//  527   unsigned char intState;
//  528 
//  529   // Disable interrupts.
//  530   intState = __save_interrupt();
        IN      R16, 0x3F
//  531   __disable_interrupt();
        CLI
//  532 
//  533   // Drive bus low and delay.
//  534   D1W_PULL_BUS_LOW;
        SBI     0x11, 0x04
        CBI     0x12, 0x04
//  535   __delay_cycles(D1W_DELAY_A_STD_MODE);
        LDI     R17, 27
        DEC     R17
        BRNE    $-2
        RJMP    $+2
//  536 
//  537   // Release bus and delay.
//  538   D1W_RELEASE_BUS;
        CBI     0x11, 0x04
        CBI     0x12, 0x04
//  539   __delay_cycles(D1W_DELAY_B_STD_MODE);
        LDI     R17, 202
        RJMP    $+2
        DEC     R17
        BRNE    $-4
        NOP
//  540 
//  541   // Restore interrupts.
//  542   __restore_interrupt(intState);
        RJMP    ?Subroutine0
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
//  543 }

        RSEG `CODE`:CODE:NOROOT(1)
D1W_ReadBit:
        CODE
        IN      R17, 0x3F
        CLI
        SBI     0x11, 0x04
        CBI     0x12, 0x04
        LDI     R16, 27
        DEC     R16
        BRNE    $-2
        RJMP    $+2
        CBI     0x11, 0x04
        CBI     0x12, 0x04
        LDI     R16, 43
        DEC     R16
        BRNE    $-2
        RJMP    $+2
        IN      R16, 0x10
        LDI     R18, 173
        RJMP    $+2
        DEC     R18
        BRNE    $-4
        RJMP    $+2
        OUT     0x3F, R17
        REQUIRE ?Subroutine1
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
        REQUIRE _A_PIND
        ;               // Fall through to label ?Subroutine1

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine1:
        ANDI    R16, 0x10
        RET

        RSEG `CODE`:CODE:NOROOT(1)
D1W_SendByte:
        CODE
        MOV     R19, R16
        LDI     R18, 8
??D1W_SendByte_0:
        BST     R19, 0
        BRTC    ??D1W_SendByte_1
        RCALL   D1W_WriteBit1
        RJMP    ??D1W_SendByte_2
??D1W_SendByte_1:
        RCALL   D1W_WriteBit0
??D1W_SendByte_2:
        LSR     R19
        DEC     R18
        BRNE    ??D1W_SendByte_0
        RET

        RSEG `CODE`:CODE:NOROOT(1)
D1W_SearchRom:
        CODE
        MOVW    R31:R30, R17:R16
        MOV     R22, R18
        LDI     R20, 1
        LDI     R23, 0
        LDI     R21, 1
        LDI     R16, 240
        RCALL   D1W_SendByte
??D1W_SearchRom_0:
        RCALL   D1W_ReadBit
        MOV     R19, R16
        RCALL   D1W_ReadBit
        TST     R19
        BREQ    ??D1W_SearchRom_1
        TST     R16
        BREQ    ??D1W_SearchRom_1
        LDI     R16, 255
        RET
??D1W_SearchRom_1:
        LD      R17, Z
        MOV     R18, R21
        COM     R18
        MOV     R0, R19
        EOR     R0, R16
        BREQ    ??D1W_SearchRom_2
        TST     R19
        BRNE    ??D1W_SearchRom_3
        AND     R17, R18
        RJMP    ??D1W_SearchRom_4
??D1W_SearchRom_2:
        CP      R20, R22
        BRNE    ??D1W_SearchRom_5
??D1W_SearchRom_3:
        OR      R17, R21
        RJMP    ??D1W_SearchRom_4
??D1W_SearchRom_5:
        CP      R22, R20
        BRCC    ??D1W_SearchRom_6
        AND     R17, R18
        RJMP    ??D1W_SearchRom_7
??D1W_SearchRom_6:
        MOV     R16, R17
        AND     R16, R21
        BRNE    ??D1W_SearchRom_4
??D1W_SearchRom_7:
        MOV     R23, R20
??D1W_SearchRom_4:
        ST      Z, R17
        AND     R17, R21
        BREQ    ??D1W_SearchRom_8
        RCALL   D1W_WriteBit1
        RJMP    ??D1W_SearchRom_9
??D1W_SearchRom_8:
        RCALL   D1W_WriteBit0
??D1W_SearchRom_9:
        INC     R20
        LSL     R21
        BRNE    ??D1W_SearchRom_10
        LDI     R21, 1
        ADIW    R31:R30, 1
??D1W_SearchRom_10:
        CPI     R20, 65
        BRCS    ??D1W_SearchRom_0
        MOV     R16, R23
        RET

        RSEG `CODE`:CODE:NOROOT(1)
D1W_DetectPresence:
        CODE
        IN      R17, 0x3F
        CLI
        SBI     0x11, 0x04
        CBI     0x12, 0x04
        LDI     R18, 124
        LDI     R19, 7
        SUBI    R18, 1
        SBCI    R19, 0
        BRNE    $-4
        RJMP    $+2
        CBI     0x11, 0x04
        CBI     0x12, 0x04
        LDI     R16, 221
        RJMP    $+2
        DEC     R16
        BRNE    $-4
        RJMP    $+2
        IN      R16, 0x10
        LDI     R18, 100
        LDI     R19, 6
        SUBI    R18, 1
        SBCI    R19, 0
        BRNE    $-4
        RJMP    $+2
        OUT     0x3F, R17
        COM     R16
        RJMP    ?Subroutine1
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
        REQUIRE _A_PIND

        RSEG `CODE`:CODE:NOROOT(1)
DS1W_SearchBuses:
        CODE
        RCALL   ?PROLOGUE6_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        MOVW    R27:R26, R17:R16
        LDI     R24, 0
        RJMP    ??DS1W_SearchBuses_0
??DS1W_SearchBuses_1:
        LDI     R20, 0
        LDI     R16, 8
        LDI     R17, 8
        LDI     R21, 0
??DS1W_SearchBuses_2:
        MUL     R24, R17
        MOVW    R31:R30, R27:R26
        ADD     R30, R0
        ADC     R31, R1
        ADD     R30, R20
        ADC     R31, R21
        ST      Z, R21
        INC     R20
        DEC     R16
        BRNE    ??DS1W_SearchBuses_2
        INC     R24
??DS1W_SearchBuses_0:
        CP      R24, R18
        BRCS    ??DS1W_SearchBuses_1
        RCALL   D1W_DetectPresence
        CLR     R4
        MOVW    R25:R24, R27:R26
        CLR     R5
        MOVW    R19:R18, R27:R26
        TST     R16
        BREQ    ??DS1W_SearchBuses_3
??DS1W_SearchBuses_4:
        LDI     R20, 8
        LDI     R21, 0
        MOVW    R17:R16, R25:R24
        RCALL   memcpy
        RCALL   D1W_DetectPresence
        MOV     R18, R5
        MOVW    R17:R16, R25:R24
        RCALL   D1W_SearchRom
        MOV     R5, R16
        MOVW    R19:R18, R25:R24
        INC     R4
        LDI     R16, 8
        MUL     R4, R16
        MOVW    R25:R24, R27:R26
        ADD     R24, R0
        ADC     R25, R1
        TST     R5
        BRNE    ??DS1W_SearchBuses_4
??DS1W_SearchBuses_3:
        LDI     R24, 0
        RJMP    ??DS1W_SearchBuses_5
??DS1W_SearchBuses_6:
        INC     R24
??DS1W_SearchBuses_5:
        CP      R24, R4
        BRCC    ??DS1W_SearchBuses_7
        LDI     R16, 8
        MUL     R24, R16
        MOVW    R17:R16, R27:R26
        ADD     R16, R0
        ADC     R17, R1
        RCALL   D1W_CheckRomCRC
        CPI     R16, 1
        BREQ    ??DS1W_SearchBuses_6
        LDI     R16, 1
        RJMP    ??DS1W_SearchBuses_8
??DS1W_SearchBuses_7:
        LDI     R16, 0
??DS1W_SearchBuses_8:
        LDI     R30, 6
        RJMP    ?EPILOGUE_B6_L09

        RSEG `CODE`:CODE:NOROOT(1)
DS1W_FindFamily:
        CODE
        LDI     R20, 0
        RJMP    ??DS1W_FindFamily_0
??DS1W_FindFamily_1:
        SUBI    R18, 248
        SBCI    R19, 255
        INC     R20
??DS1W_FindFamily_0:
        CP      R20, R17
        BRCC    ??DS1W_FindFamily_2
        MOVW    R31:R30, R19:R18
        LD      R21, Z
        CP      R21, R16
        BRNE    ??DS1W_FindFamily_1
        MOVW    R17:R16, R19:R18
        RET
??DS1W_FindFamily_2:
        LDI     R16, 0
        LDI     R17, 0
        RET

        RSEG `CODE`:CODE:NOROOT(1)
D1W_ReceiveByte:
        CODE
        LDI     R20, 0
        LDI     R19, 8
??D1W_ReceiveByte_0:
        LSR     R20
        RCALL   D1W_ReadBit
        TST     R16
        BREQ    ??D1W_ReceiveByte_1
        ORI     R20, 0x80
??D1W_ReceiveByte_1:
        DEC     R19
        BRNE    ??D1W_ReceiveByte_0
        MOV     R16, R20
        RET

        RSEG `CODE`:CODE:NOROOT(1)
D1W_MatchRom:
        CODE
        MOVW    R31:R30, R17:R16
        LDI     R16, 85
        RCALL   D1W_SendByte
        LDI     R20, 8
??D1W_MatchRom_0:
        LD      R16, Z+
        RCALL   D1W_SendByte
        DEC     R20
        BRNE    ??D1W_MatchRom_0
        RET

        RSEG `CODE`:CODE:NOROOT(1)
DS1820_ReadTemperature:
        CODE
        MOVW    R23:R22, R17:R16
        RCALL   D1W_DetectPresence
        TST     R16
        BREQ    ??DS1820_ReadTemperature_0
        MOVW    R17:R16, R23:R22
        RCALL   D1W_MatchRom
        LDI     R16, 68
        RCALL   D1W_SendByte
??DS1820_ReadTemperature_1:
        RCALL   D1W_ReadBit
        TST     R16
        BREQ    ??DS1820_ReadTemperature_1
        RCALL   D1W_DetectPresence
        TST     R16
        BRNE    ??DS1820_ReadTemperature_2
??DS1820_ReadTemperature_0:
        LDI     R16, 24
        LDI     R17, 252
        RET
??DS1820_ReadTemperature_2:
        MOVW    R17:R16, R23:R22
        RCALL   D1W_MatchRom
        LDI     R16, 190
        RCALL   D1W_SendByte
        RCALL   D1W_ReceiveByte
        MOV     R21, R16
        RCALL   D1W_ReceiveByte
        MOV     R17, R16
        MOV     R16, R21
        RET

        RSEG `CODE`:CODE:NOROOT(1)
DS2890_SetWiperPosition:
        CODE
        MOV     R21, R16
        MOVW    R23:R22, R19:R18
        RCALL   D1W_DetectPresence
        TST     R16
        BREQ    ??DS2890_SetWiperPosition_0
        MOVW    R17:R16, R23:R22
        RCALL   D1W_MatchRom
        LDI     R16, 85
        RCALL   D1W_SendByte
        LDI     R16, 76
        RCALL   D1W_SendByte
        RCALL   D1W_ReceiveByte
        CPI     R16, 76
        BRNE    ??DS2890_SetWiperPosition_0
        LDI     R16, 150
        RCALL   D1W_SendByte
        RCALL   D1W_ReceiveByte
        CPI     R16, 255
        BREQ    ??DS2890_SetWiperPosition_0
        RCALL   D1W_DetectPresence
        TST     R16
        BREQ    ??DS2890_SetWiperPosition_0
        MOVW    R17:R16, R23:R22
        RCALL   D1W_MatchRom
        LDI     R16, 15
        RCALL   D1W_SendByte
        MOV     R16, R21
        RCALL   D1W_SendByte
        RCALL   D1W_ReceiveByte
        CP      R16, R21
        BRNE    ??DS2890_SetWiperPosition_0
        LDI     R16, 150
        RCALL   D1W_SendByte
        RCALL   D1W_ReceiveByte
??DS2890_SetWiperPosition_0:
        RET

        RSEG `CODE`:CODE:NOROOT(1)
D1W_SkipRom:
        CODE
        LDI     R16, 204
        RJMP    D1W_SendByte

        RSEG `CODE`:CODE:NOROOT(1)
D1W_ReadRom:
        CODE
        MOVW    R31:R30, R17:R16
        LDI     R16, 51
        RCALL   D1W_SendByte
        LDI     R21, 8
??D1W_ReadRom_0:
        RCALL   D1W_ReceiveByte
        ST      Z+, R16
        DEC     R21
        BRNE    ??D1W_ReadRom_0
        RET

        RSEG `CODE`:CODE:NOROOT(1)
D1W_ComputeCRC8:
        CODE
        LDI     R18, 8
??D1W_ComputeCRC8_0:
        MOV     R19, R17
        LSR     R19
        ANDI    R17, 0x01
        MOV     R20, R17
        MOV     R17, R16
        ANDI    R17, 0x01
        EOR     R20, R17
        MOV     R17, R19
        BREQ    ??D1W_ComputeCRC8_1
        LDI     R19, 140
        EOR     R17, R19
??D1W_ComputeCRC8_1:
        LSR     R16
        DEC     R18
        BRNE    ??D1W_ComputeCRC8_0
        MOV     R16, R17
        RET

        RSEG `CODE`:CODE:NOROOT(1)
D1W_CheckRomCRC:
        CODE
        MOVW    R31:R30, R17:R16
        LDI     R17, 0
        LDI     R21, 7
??D1W_CheckRomCRC_0:
        LD      R16, Z+
        RCALL   D1W_ComputeCRC8
        MOV     R17, R16
        DEC     R21
        BRNE    ??D1W_CheckRomCRC_0
        LD      R16, Z
        CP      R17, R16
        BRNE    ??D1W_CheckRomCRC_1
        LDI     R16, 1
        RET
??D1W_CheckRomCRC_1:
        LDI     R16, 0
        RET

        RSEG `CODE`:CODE:NOROOT(1)
D1W_Init:
        CODE
        CBI     0x11, 0x04
        CBI     0x12, 0x04
        LDI     R16, 124
        LDI     R17, 7
        SUBI    R16, 1
        SBCI    R17, 0
        BRNE    $-4
        RJMP    $+2
        RET
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        END
//  544 
//  545 
//  546 /*! \brief  Write a '0' to the bus(es). (Software only driver)
//  547 *
//  548 *  Generates the waveform for transmission of a '0' bit on the 1-Wire(R)
//  549 *  bus.
//  550 *
//  551 *  \param  pins    A bitmask of the buses to write to.
//  552 */
//  553 void D1W_WriteBit0(void)
//  554 {
//  555   unsigned char intState;
//  556 
//  557   // Disable interrupts.
//  558   intState = __save_interrupt();
//  559   __disable_interrupt();
//  560 
//  561   // Drive bus low and delay.
//  562   D1W_PULL_BUS_LOW;
//  563   __delay_cycles(D1W_DELAY_C_STD_MODE);
//  564 
//  565   // Release bus and delay.
//  566   D1W_RELEASE_BUS;
//  567   __delay_cycles(D1W_DELAY_D_STD_MODE);
//  568 
//  569   // Restore interrupts.
//  570   __restore_interrupt(intState);
//  571 }
//  572 
//  573 
//  574 /*! \brief  Read a bit from the bus(es). (Software only driver)
//  575 *
//  576 *  Generates the waveform for reception of a bit on the 1-Wire(R) bus(es).
//  577 *
//  578 *  \return A bitmask of the buses where a '1' was read.
//  579 */
//  580 unsigned char D1W_ReadBit(void)
//  581 {
//  582   unsigned char intState;
//  583   unsigned char bitsRead;
//  584 
//  585   // Disable interrupts.
//  586   intState = __save_interrupt();
//  587   __disable_interrupt();
//  588 
//  589   // Drive bus low and delay.
//  590   D1W_PULL_BUS_LOW;
//  591   __delay_cycles(D1W_DELAY_A_STD_MODE);
//  592 
//  593   // Release bus and delay.
//  594   D1W_RELEASE_BUS;
//  595   __delay_cycles(D1W_DELAY_E_STD_MODE);
//  596 
//  597   // Sample bus and delay.
//  598   bitsRead = D1W_PIN & D1W_BUS;
//  599   __delay_cycles(D1W_DELAY_F_STD_MODE);
//  600 
//  601   // Restore interrupts.
//  602   __restore_interrupt(intState);
//  603 
//  604   return bitsRead;
//  605 }
//  606 
//  607 
//  608 /*! \brief  Send a Reset signal and listen for Presence signal. (software
//  609 *  only driver)
//  610 *
//  611 *  Generates the waveform for transmission of a Reset pulse on the
//  612 *  1-Wire(R) bus and listens for presence signals.
//  613 *
//  614 *  \param  pins    A bitmask of the buses to send the Reset signal on.
//  615 *
//  616 *  \return A bitmask of the buses where a presence signal was detected.
//  617 */
//  618 unsigned char D1W_DetectPresence(void)
//  619 {
//  620   unsigned char intState;
//  621   unsigned char presenceDetected;
//  622 
//  623   // Disable interrupts.
//  624   intState = __save_interrupt();
//  625   __disable_interrupt();
//  626 
//  627   // Drive bus low and delay.
//  628   D1W_PULL_BUS_LOW;
//  629   __delay_cycles(D1W_DELAY_H_STD_MODE);
//  630 
//  631   // Release bus and delay.
//  632   D1W_RELEASE_BUS;
//  633   __delay_cycles(D1W_DELAY_I_STD_MODE);
//  634 
//  635   // Sample bus to detect presence signal and delay.
//  636   presenceDetected = ((~D1W_PIN) & D1W_BUS);
//  637   __delay_cycles(D1W_DELAY_J_STD_MODE);
//  638 
//  639   // Restore interrupts.
//  640   __restore_interrupt(intState);
//  641 
//  642   return presenceDetected;
//  643 }
//  644 
// 
//   3 bytes in segment ABSOLUTE
// 720 bytes in segment CODE
// 
// 720 bytes of CODE memory
//   0 bytes of DATA memory (+ 3 bytes shared)
//
//Errors: none
//Warnings: none
