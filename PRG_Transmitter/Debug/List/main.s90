///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR      26/Oct/2021  17:01:07
// Copyright 1996-2021 IAR Systems AB.
//
//    Source file  =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\main.c
//    Command line =  
//        -f C:\Users\aly\AppData\Local\Temp\EW92E8.tmp
//        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\main.c
//        --cpu=m8 -ms -o
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj
//        -lCN
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        -lB
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        --initializers_in_flash --no_cross_call --no_clustering --no_tbaa
//        --debug -DENABLE_BIT_DEFINITIONS -e --eeprom_size 512 --clib -Ohz)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List\main.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME main

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B2_L09
        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?L_EC_MUL_L03
        EXTERN ?PROLOGUE2_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?UL_SHR_L03
        EXTERN ?US_SHR_L02
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_I>`
        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBWEAK `??INT0_vect_interrupt::??INTVEC 2`
        PUBWEAK `??INT1_vect_interrupt::??INTVEC 4`
        PUBLIC INT0_vect_interrupt
        PUBLIC INT1_vect_interrupt
        PUBWEAK _A_DDRB
        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_GICR
        PUBWEAK _A_GIFR
        PUBWEAK _A_MCUCR
        PUBWEAK _A_MCUCSR
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK _A_WDTCR
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC devices
        PUBLIC flags
        PUBLIC fswon
        PUBLIC get_pack_first_byte
        PUBLIC heart_beat_msg
        PUBLIC main
        PUBLIC pack_cnt
        PUBLIC prepare_temper_pack
        PUBLIC rand_gen_byte
        PUBLIC rf_packet
        PUBLIC seed
        PUBLIC send_ADC_results
        PUBLIC send_buttons
        PUBLIC send_packet
        PUBLIC send_temperatures
        PUBLIC wdt_div
        PUBLIC wdtpresc

INT0_vect_interrupt SYMBOL "INT0_vect_interrupt"
`??INT0_vect_interrupt::??INTVEC 2` SYMBOL "??INTVEC 2", INT0_vect_interrupt
INT1_vect_interrupt SYMBOL "INT1_vect_interrupt"
`??INT1_vect_interrupt::??INTVEC 4` SYMBOL "??INTVEC 4", INT1_vect_interrupt

        EXTERN ADC_get_select_ch
        EXTERN ADC_init
        EXTERN ADC_switch_off
        EXTERN D1W_Init
        EXTERN DS1820_ReadTemperature
        EXTERN DS1W_FindFamily
        EXTERN DS1W_SearchBuses
        EXTERN DataInReceiveBuffer
        EXTERN RF_send
        EXTERN Restore_default_settings
        EXTERN Restore_settings_from_eeprom
        EXTERN USART_Init
        EXTERN USART_Transmit
        EXTERN USART_close
        EXTERN USART_sendstr
        EXTERN hex_to_ascii
        EXTERN terminal
        EXTERN wp

// D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\main.c
//    1 /*
//    2   Программа передатчика на ATMEGA8
//    3 */
//    4 #include <iom8.h>

        ASEGN ABSOLUTE:DATA:NOROOT,05bH
// union <unnamed> volatile __io _A_GICR
_A_GICR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,05aH
// union <unnamed> volatile __io _A_GIFR
_A_GIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,055H
// union <unnamed> volatile __io _A_MCUCR
_A_MCUCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,054H
// union <unnamed> volatile __io _A_MCUCSR
_A_MCUCSR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,041H
// union <unnamed> volatile __io _A_WDTCR
_A_WDTCR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,038H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,037H
// union <unnamed> volatile __io _A_DDRB
_A_DDRB:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,035H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,034H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,032H
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,031H
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,030H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1
//    5 #include <ina90.h>
//    6 #include <string.h>
//    7 #include <pgmspace.h>
//    8 #include <stdio.h>
//    9 #include <stdlib.h>
//   10 #include "main.h"
//   11 #include "wrk_params.h"
//   12 #include "USART.h"
//   13 #include "Monitor.h"
//   14 #include "DS1Wire.h"
//   15 #include "ADC.h"
//   16 #include "Timers.h"
//   17 #include "RF_settings.h"
//   18 #include "RF_transmitter.h"
//   19 #include "Util.h"
//   20 #include "rc4.h"
//   21 
//   22 

        RSEG NEAR_N:DATA:NOROOT(0)
//   23 __no_init D1W_device devices[MAX_DEVICES];
devices:
        DS8 32
//   24 
//   25 
//   26 

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   27 char rf_packet[20];
rf_packet:
        DS8 20

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   28 volatile tflags flags;
flags:
        DS8 1

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   29 char fswon;
fswon:
        DS8 1
//   30 

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   31 static unsigned char fbut1; // Флаг нажатия кнопки 1
fbut1:
        DS8 1

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   32 static unsigned char fbut2; // Флаг нажатия кнопки 2
fbut2:
        DS8 1
//   33 
//   34 extern __no_init TPARAMS wp;   // Рабочие параметры в RAM
//   35 

        RSEG NEAR_N:DATA:NOROOT(0)
//   36 __no_init unsigned long  pack_cnt;
pack_cnt:
        DS8 4
//   37 

        RSEG NEAR_N:DATA:NOROOT(0)
//   38 __no_init unsigned char wdt_div;        // Коэффициент прореживания частоты активизации устройства
wdt_div:
        DS8 1

        RSEG NEAR_N:DATA:NOROOT(0)
//   39 __no_init unsigned char wdtpresc;
wdtpresc:
        DS8 1

        RSEG NEAR_N:DATA:NOROOT(0)
//   40 __no_init unsigned long seed;           // Начальная величина для генератора случайных чисел
seed:
        DS8 4

        RSEG `CODE`:CODE:NOROOT(1)
send_packet:
        CODE
        CBI     0x18, 0x01
        LDI     R18, 9
        LDI     R16, LOW(rf_packet)
        LDI     R17, (rf_packet) >> 8
        RCALL   RF_send
??send_packet_0:
        LDS     R16, flags
        SBRS    R16, 2
        RJMP    ??send_packet_0
        SBI     0x18, 0x01
        RET
        REQUIRE _A_PORTB
//   41 
//   42 
//   43 void          send_temperatures(void);
//   44 unsigned char prepare_temper_pack(D1W_device* device);
//   45 void          send_ADC_results(void);
//   46 void          send_buttons(void);
//   47 void          send_packet(void);
//   48 unsigned char rand_gen_byte(unsigned long* seed);
//   49 void          heart_beat_msg(void);
//   50 /*--------------------------------------------------------------------------------------
//   51 
//   52      MAIN
//   53 
//   54   --------------------------------------------------------------------------------------*/
//   55 void main( void )
//   56 {
//   57 
//   58   DDRB  = P_LED | P_RFD | P_SWP;
//   59   PORTB = 0xFF & (~P_RFD) & (~P_SWP) ;
//   60 
//   61   DDRC  = 0;
//   62   PORTC = b01000000;
//   63 
//   64   DDRD  = P_DSD;
//   65   PORTD = 0xFF & (~P_TXD) & (~P_JM1) & (~P_JM2) & (~P_JM3); // На TXD и перемычках Z-состояние
//   66 
//   67   WDTCR = b00011000;
//   68   WDTCR = b00001111;  // Включили WDT на максимальный период
//   69 
//   70   // Сбросили флаги внешних прерываний.
//   71   GIFR  = b11000000;
//   72   // Разрешили внешние прерывания
//   73   GICR  = b11000000;
//   74 
//   75 
//   76   _SEI();            // До Sleep прерывания должны быть разрешены иначе не будет реакции на внешний INT
//   77 
//   78   // Определим источник сброса
//   79   if ((MCUCSR & (1 << WDRF))!=0)
//   80   {
//   81     // Это сброс по WDT
//   82     MCUCSR = 0;
//   83     wdtpresc++;
//   84     if (wdtpresc < wdt_div)
//   85     {
//   86       // Прошло недостаточно периодов WDT. Возвращаемся снова в Power Down, для этого выставим флаг  fswon.
//   87       // По этому флагу в Power Down перейдем в главном цикле
//   88       fswon = 0;
//   89     }
//   90     else
//   91     {
//   92       // Пришла пора активизировать устройство
//   93       fswon    = 1;
//   94       // Пересчитать время для следующей активизации
//   95       wdt_div  = wp.wdt_div_const + (wp.wdt_div_var & rand_gen_byte(&seed));
//   96       wdtpresc = 0;
//   97     }
//   98 
//   99   }
//  100   else
//  101   {
//  102     // Это сброс после подачи или сбоя в питании
//  103     wdtpresc = 0;
//  104     MCUCSR   = 0;   // Внешние прерывания по низкому уровню на INT0, INT1
//  105     fswon    = 1;
//  106     pack_cnt = 0;
//  107 
//  108     USART_Init( 16 );  // 115200 при кварце 16 Мгц
//  109 
//  110     // Инициализируем оперативные переменные из EEPROM
//  111     if (Restore_settings_from_eeprom()== 0)
//  112     {
//  113       Restore_default_settings();
//  114       USART_sendstr("CRC error!\n\r");
//  115     }
//  116     else
//  117     {
//  118       if (wp.version != PRG_VERSION)
//  119       {
//  120         Restore_default_settings();
//  121         USART_sendstr("Ver. error!\n\r");
//  122       }
//  123       else
//  124       {
//  125         USART_sendstr("EEPROM Ok!\n\r");
//  126       }
//  127     }
//  128     USART_sendstr("Settings restored!\n\r");
//  129 
//  130     seed     = 0;
//  131     D1W_Init();
//  132     if (DS1W_SearchBuses(devices, MAX_DEVICES)==SEARCH_SUCCESSFUL)
//  133     {
//  134       D1W_device *dev;
//  135       dev = DS1W_FindFamily(DS1820_FAMILY_ID, devices, MAX_DEVICES);
//  136       if (dev!=NULL)
//  137       {
//  138       	// Начальная величина для генератора случайных чисел
//  139       	// вычисляеться на основе уникальной части идентификатора первого обнаруженного чипа DS1820
//  140         seed = (((unsigned long)(*dev).id[1]<<24) ^ ((unsigned long)(*dev).id[5]<<24)) |
//  141                (((unsigned long)(*dev).id[2]<<16) ^ ((unsigned long)(*dev).id[6]<<16)) |
//  142                ((unsigned long)(*dev).id[3]<<8)  |
//  143                ((unsigned long)(*dev).id[4]);
//  144       }
//  145     }
//  146     wdt_div = wp.wdt_div_const + (wp.wdt_div_var & rand_gen_byte(&seed));
//  147 
//  148   }
//  149 
//  150   for( ; ; )        /* Forever */
//  151   {
//  152     unsigned char tmp;
//  153     USART_Init( 16 );  // 115200 при кварце 16 Мгц
//  154 
//  155     if (fswon!=0)  // На промежеточных активизациях ничего не делать
//  156     {
//  157       D1W_Init();
//  158 
//  159       if ((wp.flags & HEART_BEAT_DISABLED)==0) heart_beat_msg();
//  160       if ((wp.flags & DS1WIRE_DISABLED)   ==0) send_temperatures();
//  161       if ((wp.flags & ADC_DISABLED)       ==0) send_ADC_results();
//  162     }
//  163 
//  164     do
//  165     {
//  166     	if (DataInReceiveBuffer()!=0) terminal();
//  167     }	
//  168     while ((PIND & b00001100) != b00001100); // Ожидать пока не отпустят кнопки.
//  169                                              // Сработка WDT приведет к выходу из цикла.
//  170 
//  171     // Выключить UART, чтобы он не мешал выставить нужный уровень на линии TXD
//  172     USART_close();
//  173 
//  174     // Привести линии портов в состояние с наименьшим потреблением
//  175     PORTB = 0xFF & (~P_RFD) & ~(P_SWP) ;
//  176     DDRD  = P_TXD;
//  177     PORTD = P_BT1 | P_BT2;
//  178 
//  179     // Установим таймер WDT
//  180 
//  181     tmp = b00001000 | (wp.wdt_period & 0x07); // Подготовим значения для загрузки в WDT
//  182     __watchdog_reset();
//  183     WDTCR = b00011000;
//  184     WDTCR = tmp;        // Включили WDT на заданный период
//  185 
//  186     // Сбросили флаги внешних прерываний.
//  187     GIFR  = b11000000;
//  188 
//  189     if ((wp.flags & BUTTONS_DISABLED)==0)
//  190       GICR  = b11000000;  // Разрешили внешние прерывания
//  191     else
//  192       GICR  = b00000000;  // Запретили внешние прерывания
//  193 
//  194     // Выход в режим Power Down
//  195     MCUCR = b10100000; // Внешние прерывания по низкому уровню на INT0, INT1
//  196     __sleep();
//  197     // Режим Power Down прерываеться и переход к посылке состояния кнопок.
//  198     __watchdog_reset();
//  199     send_buttons();
//  200     fswon    = 0;
//  201     wdtpresc = 0;
//  202   }
//  203 }
//  204 
//  205 /*--------------------------------------------------------------------------------------
//  206    Сформироать первый байт пакета с информацией о типе пакета и номере передатчика
//  207   --------------------------------------------------------------------------------------*/

        RSEG `CODE`:CODE:NOROOT(1)
//  208 unsigned char get_pack_first_byte(unsigned char type)
get_pack_first_byte:
        CODE
//  209 {
//  210   unsigned char b;
//  211 
//  212   // Определить и записать номер передатчика
//  213   PORTD |= (P_JM1 | P_JM2 | P_JM3); // Включим на перемычках Pull-Up
        IN      R17, 0x12
        ORI     R17, 0xE0
        OUT     0x12, R17
//  214 
//  215   __delay_cycles(16); // Задержка для установки уровня на 1 мкс
        LDI     R17, 5
        DEC     R17
        BRNE    $-2
        NOP
//  216 
//  217   b = (PIND >> 5) & 0x07;
        IN      R18, 0x10
//  218 
//  219   PORTD &= ((~P_JM1) & (~P_JM2) & (~P_JM3)) ; // Выключаем на перемычках Pull-Up
        IN      R17, 0x12
        ANDI    R17, 0x1F
        OUT     0x12, R17
//  220   // Записать тип пакета
//  221   b |= (type << 4);
//  222   return b;
        SWAP    R18
        ANDI    R18, 0x0F
        LSR     R18
        SWAP    R16
        ANDI    R16, 0xF0
        OR      R16, R18
        RET
        REQUIRE _A_PORTD
        REQUIRE _A_PIND
//  223 }

        RSEG `CODE`:CODE:NOROOT(1)
send_ADC_results:
        CODE
        RCALL   ?PROLOGUE4_L09
        RCALL   ADC_init
        LDI     R16, 0
        RCALL   ADC_get_select_ch
        LDI     R16, 2
        RCALL   get_pack_first_byte
        STS     rf_packet, R16
        LDI     R24, 1
        LDI     R16, 8
        LDI     R25, 0
??send_ADC_results_0:
        MOVW    R31:R30, R25:R24
        SUBI    R30, LOW((-(rf_packet) & 0xFFFF))
        SBCI    R31, (-(rf_packet) & 0xFFFF) >> 8
        ST      Z, R25
        INC     R24
        DEC     R16
        BRNE    ??send_ADC_results_0
        LDI     R26, 1
        LDI     R24, 0
        LDI     R27, 6
        RJMP    ??send_ADC_results_1
??send_ADC_results_2:
        TST     R24
        BRNE    ??send_ADC_results_3
??send_ADC_results_1:
        LDI     R30, LOW(wp)
        LDI     R31, (wp) >> 8
        LDD     R16, Z+7
        SBRS    R16, 4
        RJMP    ??send_ADC_results_3
        LDD     R18, Z+11
        LDD     R19, Z+12
        RJMP    ??send_ADC_results_4
??send_ADC_results_3:
        MOV     R16, R24
        RCALL   ADC_get_select_ch
        MOVW    R19:R18, R17:R16
??send_ADC_results_4:
        LDI     R16, 10
        LDI     R21, 0
??send_ADC_results_5:
        CPI     R25, 8
        BRNE    ??send_ADC_results_6
        INC     R26
        LDI     R25, 1
        RJMP    ??send_ADC_results_7
??send_ADC_results_6:
        LDI     R30, LOW(rf_packet)
        LDI     R31, (rf_packet) >> 8
        ADD     R30, R26
        ADC     R31, R21
        LD      R17, Z
        LSL     R17
        ST      Z, R17
        INC     R25
??send_ADC_results_7:
        BST     R19, 1
        BRTC    ??send_ADC_results_8
        LDI     R31, 0
        MOV     R30, R26
        SUBI    R30, LOW((-(rf_packet) & 0xFFFF))
        SBCI    R31, (-(rf_packet) & 0xFFFF) >> 8
        LD      R17, Z
        INC     R17
        ST      Z, R17
??send_ADC_results_8:
        LSL     R18
        ROL     R19
        DEC     R16
        BRNE    ??send_ADC_results_5
        INC     R24
        DEC     R27
        BRNE    ??send_ADC_results_2
        RCALL   send_packet
        RCALL   ADC_switch_off
        REQUIRE ?Subroutine0
        ;               // Fall through to label ?Subroutine0

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine0:
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
//  224 
//  225 
//  226 
//  227 
//  228 /*--------------------------------------------------------------------------------------
//  229     Выслать показания всех датчиков температуры обнаруженных в 1-Wire сети
//  230   --------------------------------------------------------------------------------------*/

        RSEG `CODE`:CODE:NOROOT(1)
//  231 void send_temperatures(void)
send_temperatures:
        CODE
//  232 {
        RCALL   ?PROLOGUE2_L09
//  233   unsigned char i;
//  234 
//  235   for (i=0;i<MAX_DEVICES;i++)
        LDI     R25, 0
        LDI     R24, 4
//  236   {
//  237     if (devices[i].id[0] == DS1820_FAMILY_ID)
??send_temperatures_0:
        LDI     R16, 8
        MUL     R25, R16
        LDI     R30, LOW(devices)
        LDI     R31, (devices) >> 8
        ADD     R30, R0
        ADC     R31, R1
        LD      R16, Z
        CPI     R16, 16
        BRNE    ??send_temperatures_1
//  238     {
//  239       if (prepare_temper_pack(&devices[i])==FALSE)  // Подготовим пакет для отправки
        MOVW    R17:R16, R31:R30
        RCALL   prepare_temper_pack
        TST     R16
        BRNE    ??send_temperatures_2
//  240       {
//  241          DS1W_SearchBuses(devices, MAX_DEVICES);
        LDI     R18, 4
        LDI     R16, LOW(devices)
        LDI     R17, (devices) >> 8
        RCALL   DS1W_SearchBuses
//  242          return;
        RJMP    ??send_temperatures_3
//  243       }
//  244       else
//  245       {
//  246         send_packet();
??send_temperatures_2:
        RCALL   send_packet
//  247       }
//  248     }
//  249   }
??send_temperatures_1:
        INC     R25
        DEC     R24
        BRNE    ??send_temperatures_0
//  250 }
??send_temperatures_3:
        REQUIRE ?Subroutine1
        ;               // Fall through to label ?Subroutine1

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine1:
//  251 
//  252 
//  253 /*--------------------------------------------------------------------------------------
//  254    Снять показания температуры с датчика и сформировать пакет для отправки
//  255 
//  256    Возвращает: TRUE если температура прочитана успешно
//  257   --------------------------------------------------------------------------------------*/
//  258 unsigned char prepare_temper_pack(D1W_device* device)
//  259 {
//  260   signed int temperature;
//  261   unsigned char i;
//  262 
//  263   rf_packet[0] = get_pack_first_byte(PACK_TEMPER);
//  264 
//  265   temperature = DS1820_ReadTemperature((*device).id);
//  266 
//  267   if (temperature == -1000) return FALSE;
//  268 
//  269 
//  270   // Идентификатор DS1820 состоит из 48-и бит
//  271   for (i=1;i<7;i++) rf_packet[i] = (*device).id[i];
//  272   rf_packet[7] = temperature >> 8;
//  273   rf_packet[8] = temperature & 0xFF;
//  274 
//  275 
//  276   return TRUE;
        LDI     R30, 2
        RJMP    ?EPILOGUE_B2_L09

        RSEG `CODE`:CODE:NOROOT(1)
heart_beat_msg:
        CODE
        LDI     R30, LOW(pack_cnt)
        LDI     R31, (pack_cnt) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        SUBI    R16, 255
        SBCI    R17, 255
        SBCI    R18, 255
        SBCI    R19, 255
        ST      Z, R16
        STD     Z+1, R17
        STD     Z+2, R18
        STD     Z+3, R19
        LSR     R19
        LSR     R19
        LSR     R19
        LSR     R19
        MOV     R16, R19
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        LDS     R16, (pack_cnt + 3)
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        LDI     R20, 20
        LDI     R30, LOW(pack_cnt)
        LDI     R31, (pack_cnt) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        RCALL   ?UL_SHR_L03
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        LDS     R16, (pack_cnt + 2)
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        LDI     R20, 12
        LDI     R30, LOW(pack_cnt)
        LDI     R31, (pack_cnt) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        RCALL   ?UL_SHR_L03
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        LDS     R16, (pack_cnt + 1)
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        LDI     R30, LOW(pack_cnt)
        LDI     R31, (pack_cnt) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        LDI     R20, 4
        RCALL   ?US_SHR_L02
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        LDS     R16, pack_cnt
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        LDI     R16, 10
        RCALL   USART_Transmit
        LDI     R16, 13
        RJMP    USART_Transmit
//  277 }
//  278 
//  279 
//  280 
//  281 /*--------------------------------------------------------------------------------------
//  282     Выслать результаты измерения ЦАП во всех каналах
//  283   --------------------------------------------------------------------------------------*/
//  284 void send_ADC_results(void)
//  285 {
//  286   unsigned char i,j,k, bitcnt;
//  287   unsigned int res;
//  288 
//  289 
//  290   ADC_init();
//  291   ADC_get_select_ch(0); // Проведем одно пустое измерение
//  292 
//  293   rf_packet[0] = get_pack_first_byte(PACK_ADC);
//  294 
//  295   for (i=1;i<9;i++) rf_packet[i]=0;
//  296   k      = 1;
//  297   bitcnt = 0;
//  298   for (i=0;i<6;i++)
//  299   {
//  300     if ((i==0) && ((wp.flags & TRANSMIT_REFCOD)!=0))
//  301       res = wp.refcod;
//  302     else
//  303       res = ADC_get_select_ch(i);  // Получим результат преобразования в канале
//  304     // Запакуем результат в отправляемый пакет
//  305     for (j=0;j<10;j++)  // Пройдем все биты результата
//  306     {
//  307       if (bitcnt == 8)
//  308       {
//  309         k++;
//  310         bitcnt=0;
//  311       }
//  312       else
//  313       {
//  314         rf_packet[k] <<=1;
//  315       }
//  316       if ((res & 0x0200)!=0)  rf_packet[k]++;
//  317       res <<=1;
//  318       bitcnt++;
//  319 
//  320     }
//  321   }
//  322   send_packet();
//  323   ADC_switch_off();
//  324 
//  325 }
//  326 
//  327 
//  328 /*--------------------------------------------------------------------------------------
//  329     Выслать состояние кнопок
//  330   --------------------------------------------------------------------------------------*/

        RSEG `CODE`:CODE:NOROOT(1)
//  331 void send_buttons(void)
send_buttons:
        CODE
//  332 {
        RCALL   ?PROLOGUE4_L09
//  333   unsigned char i;
//  334   rf_packet[0] = get_pack_first_byte(PACK_BUTTONS);
        LDI     R30, LOW(rf_packet)
        LDI     R31, (rf_packet) >> 8
        LDI     R16, 1
        RCALL   get_pack_first_byte
        ST      Z, R16
//  335   for (i=1;i<9;i++) rf_packet[i]=0;
        LDI     R18, 1
        LDI     R16, 8
        LDI     R19, 0
??send_buttons_0:
        MOVW    R27:R26, R31:R30
        ADD     R26, R18
        ADC     R27, R19
        ST      X, R19
        INC     R18
        DEC     R16
        BRNE    ??send_buttons_0
//  336   if (fbut1 !=0) rf_packet[1] = 0xFF;
        LDS     R16, fbut1
        TST     R16
        BREQ    ??send_buttons_1
        LDI     R16, 255
        STD     Z+1, R16
//  337   if (fbut2 !=0) rf_packet[2] = 0xFF;
??send_buttons_1:
        LDS     R16, fbut2
        TST     R16
        BREQ    ??send_buttons_2
        LDI     R16, 255
        STD     Z+2, R16
//  338   fbut1 = 0;
??send_buttons_2:
        STS     fbut1, R19
//  339   fbut2 = 0;
        STS     fbut2, R19
//  340   send_packet();
        RCALL   send_packet
//  341   GIFR  = b11000000; // Стереть флаги прерываний
        LDI     R16, 192
        OUT     0x3A, R16
//  342 }
        RJMP    ?Subroutine0
        REQUIRE _A_GIFR

        RSEG `CODE`:CODE:NOROOT(1)
rand_gen_byte:
        CODE
        MOVW    R31:R30, R17:R16
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        LDI     R20, 13
        LDI     R21, 102
        LDI     R22, 25
        LDI     R23, 0
        RCALL   ?L_EC_MUL_L03
        SUBI    R16, 161
        SBCI    R17, 12
        SBCI    R18, 145
        SBCI    R19, 195
        ST      Z, R16
        STD     Z+1, R17
        STD     Z+2, R18
        STD     Z+3, R19
        MOV     R16, R19
        RET

        RSEG `CODE`:CODE:NOROOT(1)
main:
        CODE
        RCALL   ?PROLOGUE4_L09
        LDI     R16, 7
        OUT     0x17, R16
        LDI     R16, 250
        OUT     0x18, R16
        LDI     R16, 0
        OUT     0x14, R16
        LDI     R16, 64
        OUT     0x15, R16
        LDI     R16, 16
        OUT     0x11, R16
        LDI     R16, 29
        OUT     0x12, R16
        LDI     R16, 24
        OUT     0x21, R16
        LDI     R16, 15
        OUT     0x21, R16
        LDI     R16, 192
        OUT     0x3A, R16
        OUT     0x3B, R16
        SEI
        IN      R16, 0x34
        SBRS    R16, 3
        RJMP    ??main_0
        LDI     R16, 0
        OUT     0x34, R16
        LDS     R16, wdtpresc
        INC     R16
        STS     wdtpresc, R16
        LDS     R17, wdt_div
        CP      R16, R17
        BRCC    ??main_1
        LDI     R16, 0
        STS     fswon, R16
        RJMP    ??main_2
??main_1:
        LDI     R16, 1
        STS     fswon, R16
        LDI     R16, LOW(seed)
        LDI     R17, (seed) >> 8
        RCALL   rand_gen_byte
        LDS     R17, (wp + 3)
        LDS     R18, (wp + 4)
        AND     R18, R16
        ADD     R17, R18
        STS     wdt_div, R17
        LDI     R16, 0
        RJMP    ??main_3
??main_0:
        LDI     R16, 0
        STS     wdtpresc, R16
        OUT     0x34, R16
        LDI     R16, 1
        STS     fswon, R16
        LDI     R30, LOW(pack_cnt)
        LDI     R31, (pack_cnt) >> 8
        LDI     R16, 0
        ST      Z, R16
        STD     Z+1, R16
        STD     Z+2, R16
        STD     Z+3, R16
        LDI     R16, 16
        LDI     R17, 0
        RCALL   USART_Init
        RCALL   Restore_settings_from_eeprom
        TST     R16
        BRNE    ??main_4
        RCALL   Restore_default_settings
        LDI     R16, LOW(`?<Constant "CRC error!\\n\\r">`)
        LDI     R17, (`?<Constant "CRC error!\\n\\r">`) >> 8
        RJMP    ??main_5
??main_4:
        LDI     R30, LOW(wp)
        LDI     R31, (wp) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        CPI     R16, 106
        SBCI    R17, 0
        BREQ    ??main_6
        RCALL   Restore_default_settings
        LDI     R16, LOW(`?<Constant "Ver. error!\\n\\r">`)
        LDI     R17, (`?<Constant "Ver. error!\\n\\r">`) >> 8
        RJMP    ??main_5
??main_6:
        LDI     R16, LOW(`?<Constant "EEPROM Ok!\\n\\r">`)
        LDI     R17, (`?<Constant "EEPROM Ok!\\n\\r">`) >> 8
??main_5:
        RCALL   USART_sendstr
        LDI     R16, LOW(`?<Constant "Settings restored!\\n\\r">`)
        LDI     R17, (`?<Constant "Settings restored!\\n\\r">`) >> 8
        RCALL   USART_sendstr
        LDI     R30, LOW(seed)
        LDI     R31, (seed) >> 8
        LDI     R16, 0
        ST      Z, R16
        STD     Z+1, R16
        STD     Z+2, R16
        STD     Z+3, R16
        RCALL   D1W_Init
        LDI     R18, 4
        LDI     R16, LOW(devices)
        LDI     R17, (devices) >> 8
        RCALL   DS1W_SearchBuses
        TST     R16
        BRNE    ??main_7
        LDI     R17, 4
        LDI     R18, LOW(devices)
        LDI     R19, (devices) >> 8
        LDI     R16, 16
        RCALL   DS1W_FindFamily
        MOVW    R31:R30, R17:R16
        OR      R16, R17
        BREQ    ??main_7
        LDD     R20, Z+1
        LDD     R16, Z+5
        EOR     R20, R16
        LDD     R18, Z+2
        LDD     R16, Z+6
        EOR     R18, R16
        LDD     R17, Z+3
        LDD     R16, Z+4
        LDI     R30, LOW(seed)
        LDI     R31, (seed) >> 8
        ST      Z, R16
        STD     Z+1, R17
        STD     Z+2, R18
        STD     Z+3, R20
??main_7:
        LDI     R16, LOW(seed)
        LDI     R17, (seed) >> 8
        RCALL   rand_gen_byte
        LDS     R17, (wp + 3)
        LDS     R18, (wp + 4)
        AND     R18, R16
        ADD     R17, R18
        STS     wdt_div, R17
        RJMP    ??main_2
??main_8:
        LDI     R16, 0
??main_9:
        OUT     0x3B, R16
        LDI     R16, 160
        OUT     0x35, R16
        SLEEP
        WDR
        RCALL   send_buttons
        LDI     R16, 0
        STS     fswon, R16
??main_3:
        STS     wdtpresc, R16
??main_2:
        LDI     R16, 16
        LDI     R17, 0
        RCALL   USART_Init
        LDS     R16, fswon
        TST     R16
        BREQ    ??main_10
        RCALL   D1W_Init
        LDI     R26, LOW(wp)
        LDI     R27, (wp) >> 8
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+7
        SBRS    R16, 3
        RCALL   heart_beat_msg
??main_11:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+7
        SBRS    R16, 1
        RCALL   send_temperatures
??main_12:
        MOVW    R31:R30, R27:R26
        LDD     R16, Z+7
        SBRS    R16, 0
        RCALL   send_ADC_results
??main_10:
        RCALL   DataInReceiveBuffer
        TST     R16
        BREQ    ??main_13
        RCALL   terminal
??main_13:
        IN      R16, 0x10
        ANDI    R16, 0x0C
        CPI     R16, 12
        BRNE    ??main_10
        RCALL   USART_close
        LDI     R16, 250
        OUT     0x18, R16
        LDI     R16, 2
        OUT     0x11, R16
        LDI     R16, 12
        OUT     0x12, R16
        LDI     R30, LOW(wp)
        LDI     R31, (wp) >> 8
        LDD     R16, Z+2
        ANDI    R16, 0x07
        ORI     R16, 0x08
        WDR
        LDI     R17, 24
        OUT     0x21, R17
        OUT     0x21, R16
        LDI     R16, 192
        OUT     0x3A, R16
        LDD     R16, Z+7
        SBRC    R16, 2
        RJMP    ??main_8
        LDI     R16, 192
        RJMP    ??main_9
        REQUIRE _A_DDRB
        REQUIRE _A_PORTB
        REQUIRE _A_DDRC
        REQUIRE _A_PORTC
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
        REQUIRE _A_WDTCR
        REQUIRE _A_GIFR
        REQUIRE _A_GICR
        REQUIRE _A_MCUCSR
        REQUIRE _A_PIND
        REQUIRE _A_MCUCR

        RSEG `CODE`:CODE:NOROOT(1)
prepare_temper_pack:
        CODE
        RCALL   ?PROLOGUE2_L09
        MOVW    R25:R24, R17:R16
        LDI     R16, 0
        RCALL   get_pack_first_byte
        STS     rf_packet, R16
        MOVW    R17:R16, R25:R24
        RCALL   DS1820_ReadTemperature
        MOVW    R21:R20, R17:R16
        CPI     R16, 24
        SBCI    R17, 252
        BRNE    ??prepare_temper_pack_0
        LDI     R16, 0
        RJMP    ??prepare_temper_pack_1
??prepare_temper_pack_0:
        LDI     R16, 1
        LDI     R17, 6
        LDI     R19, 0
??prepare_temper_pack_2:
        MOVW    R31:R30, R25:R24
        ADD     R30, R16
        ADC     R31, R19
        LD      R22, Z
        MOV     R30, R16
        LDI     R31, 0
        SUBI    R30, LOW((-(rf_packet) & 0xFFFF))
        SBCI    R31, (-(rf_packet) & 0xFFFF) >> 8
        ST      Z, R22
        INC     R16
        DEC     R17
        BRNE    ??prepare_temper_pack_2
        STS     (rf_packet + 7), R21
        STS     (rf_packet + 8), R20
        LDI     R16, 1
??prepare_temper_pack_1:
        RJMP    ?Subroutine1
//  343 
//  344 
//  345 
//  346 /*--------------------------------------------------------------------------------------
//  347     Выслать подготовленный пакет
//  348   --------------------------------------------------------------------------------------*/
//  349 void send_packet(void)
//  350 {
//  351   PORTB &= ~P_LED;
//  352   RF_send(rf_packet,9);
//  353   while (flags.done!=1);
//  354   PORTB |= P_LED;
//  355 }
//  356 
//  357 
//  358 /*--------------------------------------------------------------------------------------
//  359     Генератор случайного байта
//  360   --------------------------------------------------------------------------------------*/
//  361 unsigned char rand_gen_byte(unsigned long* seed)
//  362 {
//  363   *seed = 1664525ul*(* seed) + 1013904223ul;
//  364   return ((*seed) >> 24);
//  365 }
//  366 
//  367 /*--------------------------------------------------------------------------------------
//  368     Отправка в последовательный порт контрольного сообщения
//  369   --------------------------------------------------------------------------------------*/
//  370 void heart_beat_msg(void)
//  371 {
//  372    pack_cnt++;
//  373    USART_Transmit(hex_to_ascii(pack_cnt>>28));
//  374    USART_Transmit(hex_to_ascii(pack_cnt>>24));
//  375    USART_Transmit(hex_to_ascii(pack_cnt>>20));
//  376    USART_Transmit(hex_to_ascii(pack_cnt>>16));
//  377    USART_Transmit(hex_to_ascii(pack_cnt>>12));
//  378    USART_Transmit(hex_to_ascii(pack_cnt>>8));
//  379    USART_Transmit(hex_to_ascii(pack_cnt>>4));
//  380    USART_Transmit(hex_to_ascii(pack_cnt));
//  381    USART_Transmit('\n');
//  382    USART_Transmit('\r');
//  383 }
//  384 
//  385 
//  386 #pragma vector=INT0_vect

        RSEG `CODE`:CODE:NOROOT(1)
        CALL_GRAPH_ROOT INT0_vect_interrupt, "interrupt"
//  387 __interrupt void INT0_vect_interrupt( void )
INT0_vect_interrupt:
        CODE
//  388 {
        ST      -Y, R16
//  389   GICR  = 0; // Запретим прерывания, чтобы они вновь не возникали в случае если кнопку не отпустили
        LDI     R16, 0
        OUT     0x3B, R16
//  390   fbut1 = 1;
        LDI     R16, 1
        STS     fbut1, R16
//  391 }
        REQUIRE ?Subroutine2
        REQUIRE _A_GICR
        ;               // Fall through to label ?Subroutine2

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine2:
        LD      R16, Y+
        RETI
//  392 
//  393 
//  394 #pragma vector=INT1_vect

        RSEG `CODE`:CODE:NOROOT(1)
        CALL_GRAPH_ROOT INT1_vect_interrupt, "interrupt"
//  395 __interrupt void INT1_vect_interrupt( void )
INT1_vect_interrupt:
        CODE
//  396 {
        ST      -Y, R16
//  397   GICR  = 0; // Запретим прерывания, чтобы они вновь не возникали в случае если кнопку не отпустили
        LDI     R16, 0
        OUT     0x3B, R16
//  398   fbut2 = 1;
        LDI     R16, 1
        STS     fbut2, R16
//  399 }
        RJMP    ?Subroutine2
        REQUIRE _A_GICR

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        COMMON INTVEC:CODE:ROOT(1)
        ORG 2
`??INT0_vect_interrupt::??INTVEC 2`:
        CODE
        RJMP    INT0_vect_interrupt

        COMMON INTVEC:CODE:ROOT(1)
        ORG 4
`??INT1_vect_interrupt::??INTVEC 4`:
        CODE
        RJMP    INT1_vect_interrupt

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "CRC error!\\n\\r">>`:
        DC8 "CRC error!\012\015"

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_I>`:
        DC16    SFE(NEAR_I) - SFB(NEAR_I)
        DC16    SFB(NEAR_I)
        DC16    SFB(NEAR_ID)
        REQUIRE ?need_segment_init

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "Ver. error!\\n\\r">`:
        DC8 "Ver. error!\012\015"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "EEPROM Ok!\\n\\r">>`:
        DC8 "EEPROM Ok!\012\015"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "Settings restored`:
        DC8 "Settings restored!\012\015"

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "CRC error!\\n\\r">`:
        DS8 13
        REQUIRE `?<Initializer for <Constant "CRC error!\\n\\r">>`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "Ver. error!\\n\\r">`:
        DS8 14
        REQUIRE `?<Initializer for <Constant "Ver. error!\\n\\r">`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "EEPROM Ok!\\n\\r">`:
        DS8 13
        REQUIRE `?<Initializer for <Constant "EEPROM Ok!\\n\\r">>`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "Settings restored!\\n\\r">`:
        DS8 21
        REQUIRE `?<Initializer for <Constant "Settings restored`

        END
// 
//    12 bytes in segment ABSOLUTE
// 1 020 bytes in segment CODE
//    12 bytes in segment INITTAB
//     4 bytes in segment INTVEC
//    61 bytes in segment NEAR_I
//    61 bytes in segment NEAR_ID
//    42 bytes in segment NEAR_N
//    24 bytes in segment NEAR_Z
// 
// 1 081 bytes of CODE memory (+ 16 bytes shared)
//   127 bytes of DATA memory (+ 12 bytes shared)
//
//Errors: none
//Warnings: none
