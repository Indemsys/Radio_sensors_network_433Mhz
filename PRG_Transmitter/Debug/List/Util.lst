###############################################################################
#
# IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR       26/Oct/2021  17:01:08
# Copyright 1996-2021 IAR Systems AB.
#
#    Source file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Util.c
#    Command line =  
#        -f C:\Users\aly\AppData\Local\Temp\EW92E2.tmp
#        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Util.c
#        --cpu=m8 -ms -o
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj
#        -lCN
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
#        -lB
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
#        --initializers_in_flash --no_cross_call --no_clustering --no_tbaa
#        --debug -DENABLE_BIT_DEFINITIONS -e --eeprom_size 512 --clib -Ohz)
#    Locale       =  Russian_RUS.1251
#    List file    =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List\Util.lst
#    Object file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj\Util.r90
#
###############################################################################

D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Util.c
      1          #include  "main.h"
      2          #include  <stdlib.h>
      3          
      4          // ==========================================================
      5          //  Проверка соответствия символа шестнадцатеричному представлению
      6          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
      7          unsigned char is_hex_digit(unsigned char c)
   \                     is_hex_digit:
      8          {
      9              if ((c >= '0' && c <= '9') ||
     10                  (c >= 'a' && c <= 'f') ||
     11                  (c >= 'A' && c <= 'F')) return (1);
   \   00000000   2F10               MOV     R17, R16
   \   00000002   5310               SUBI    R17, 48
   \   00000004   301A               CPI     R17, 10
   \   00000006   F038               BRCS    ??is_hex_digit_0
   \   00000008   2F10               MOV     R17, R16
   \   0000000A   5611               SUBI    R17, 97
   \   0000000C   3016               CPI     R17, 6
   \   0000000E   F018               BRCS    ??is_hex_digit_0
   \   00000010   5401               SUBI    R16, 65
   \   00000012   3006               CPI     R16, 6
   \   00000014   F410               BRCC    ??is_hex_digit_1
   \                     ??is_hex_digit_0:
   \   00000016   E001               LDI     R16, 1
   \   00000018   9508               RET
     12              return (0);
   \                     ??is_hex_digit_1:
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   9508               RET
     13          } 
     14          
     15          // ==========================================================
     16          //  Преобразование символа в шестнадцатеричное представление
     17          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     18          unsigned char ascii_to_hex(unsigned char c)
   \                     ascii_to_hex:
     19          {
     20              if (c >= '0' && c <= '9')      return ( c - '0' ) & 0x0f;
   \   00000000   2F10               MOV     R17, R16
   \   00000002   5310               SUBI    R17, 48
   \   00000004   301A               CPI     R17, 10
   \   00000006   F028               BRCS    ??ascii_to_hex_0
     21              else if (c >= 'a' && c <= 'f') return ( c - 'a' + 10 ) & 0x0f;
   \   00000008   2F10               MOV     R17, R16
   \   0000000A   5611               SUBI    R17, 97
   \   0000000C   3016               CPI     R17, 6
   \   0000000E   F418               BRCC    ??ascii_to_hex_1
   \   00000010   5507               SUBI    R16, 87
   \                     ??ascii_to_hex_0:
   \   00000012   700F               ANDI    R16, 0x0F
   \   00000014   9508               RET
     22              else                           return ( c - 'A' + 10 ) & 0x0f;
   \                     ??ascii_to_hex_1:
   \   00000016   5307               SUBI    R16, 55
   \   00000018   CFFC               RJMP    ??ascii_to_hex_0
     23          } 
     24          
     25          // ==========================================================
     26          //  Преобразование байта в ASCII 
     27          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     28          unsigned char hex_to_ascii(unsigned char c)
   \                     hex_to_ascii:
     29          {
     30              c = c & 0xf;
   \   00000000   700F               ANDI    R16, 0x0F
     31              if (c <= 9) return (c + 0x30);
   \   00000002   300A               CPI     R16, 10
   \   00000004   F410               BRCC    ??hex_to_ascii_0
   \   00000006   5D00               SUBI    R16, 208
   \   00000008   9508               RET
     32              return (c + 'A' - 10);
   \                     ??hex_to_ascii_0:
   \   0000000A   5C09               SUBI    R16, 201
   \   0000000C   9508               RET
     33          } 
     34          
     35          // ==========================================================
     36          //  Преобразовать не символьные байты в точку
     37          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     38          unsigned char write_ascii(unsigned char c)
   \                     write_ascii:
     39          {
     40              if (c >= 0x20) return (c);
   \   00000000   3200               CPI     R16, 32
   \   00000002   F408               BRCC    ??write_ascii_0
     41              return ('.');
   \   00000004   E20E               LDI     R16, 46
   \                     ??write_ascii_0:
   \   00000006   9508               RET
     42          } 
     43          
     44          
     45          
     46          
     47          // ==========================================================
     48          //  Расчет контрольной суммы по стандарту CRC CCITT 
     49          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     50          unsigned int GetCRC(unsigned int CRC,unsigned char b)
   \                     GetCRC:
     51          {
     52          #define POLI 0x1021 // CRC-16/CITT
     53            unsigned char i;
     54            CRC=CRC ^ (b << 8);
   \   00000000   2712               EOR     R17, R18
     55            for (i=0;i<8;i++)
   \   00000002   E028               LDI     R18, 8
     56            {
     57              if ((CRC & 0x8000) != 0) 
   \                     ??GetCRC_0:
   \   00000004   01A8               MOVW    R21:R20, R17:R16
   \   00000006   0F44               LSL     R20
   \   00000008   1F55               ROL     R21
   \   0000000A   FB17               BST     R17, 7
   \   0000000C   018A               MOVW    R17:R16, R21:R20
   \   0000000E   F426               BRTC    ??GetCRC_1
     58              {
     59                CRC=(CRC << 1) ^ POLI; 
   \   00000010   E231               LDI     R19, 33
   \   00000012   2703               EOR     R16, R19
   \   00000014   E130               LDI     R19, 16
   \   00000016   2713               EOR     R17, R19
     60              }
     61              else
     62              {
     63                CRC=(CRC << 1);
     64              }   
     65            } 
   \                     ??GetCRC_1:
   \   00000018   952A               DEC     R18
   \   0000001A   F7A1               BRNE    ??GetCRC_0
     66            return CRC;
   \   0000001C   9508               RET
     67          }
     68          
     69          // ==========================================================
     70          //  Расчет контрольной суммы блока данных
     71          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     72          unsigned int GetBlockCRC(unsigned char* b,long len)
   \                     GetBlockCRC:
     73          {
   \   00000000   ....               RCALL   ?PROLOGUE6_L09
   \   00000002                      REQUIRE ?Register_R4_is_cg_reg
   \   00000002                      REQUIRE ?Register_R5_is_cg_reg
   \   00000002   0128               MOVW    R5:R4, R17:R16
   \   00000004   010A               MOVW    R1:R0, R21:R20
     74            long i;
     75            unsigned int CRC=0xFFFF;
   \   00000006   EF0F               LDI     R16, 255
   \   00000008   EF1F               LDI     R17, 255
     76            
     77            for (i=0;i<len;i++)
   \   0000000A   E080               LDI     R24, 0
   \   0000000C   E090               LDI     R25, 0
   \   0000000E   E0A0               LDI     R26, 0
   \   00000010   E0B0               LDI     R27, 0
   \   00000012   C009               RJMP    ??GetBlockCRC_0
     78            {
     79               CRC=GetCRC(CRC, *(b+i)); 
   \                     ??GetBlockCRC_1:
   \   00000014   01F2               MOVW    R31:R30, R5:R4
   \   00000016   0FE8               ADD     R30, R24
   \   00000018   1FF9               ADC     R31, R25
   \   0000001A   8120               LD      R18, Z
   \   0000001C   ....               RCALL   GetCRC
     80            }
   \   0000001E   5F8F               SUBI    R24, 255
   \   00000020   4F9F               SBCI    R25, 255
   \   00000022   4FAF               SBCI    R26, 255
   \   00000024   4FBF               SBCI    R27, 255
   \                     ??GetBlockCRC_0:
   \   00000026   1580               CP      R24, R0
   \   00000028   0591               CPC     R25, R1
   \   0000002A   07A6               CPC     R26, R22
   \   0000002C   07B7               CPC     R27, R23
   \   0000002E   F394               BRLT    ??GetBlockCRC_1
     81            return CRC;
   \   00000030   E0E6               LDI     R30, 6
   \   00000032   ....               RJMP    ?EPILOGUE_B6_L09
     82          }
     83          
     84          
     85          // ==========================================================
     86          //  Перевод беззнакового целого числа (unsigned long) в строку
     87          //  buf   - указатель на буфер приемник строки
     88          //  ln    - максимальная длина строки
     89          //  ul    - преобразуемое число
     90          //  base  - база исчисления: 10 - десятичная, 16 - шестнадцатеричная, 2 - двоичная и т.д.  
     91          //  Возвращает количество символов в строке 
     92          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     93          int Num_to_str(unsigned char *buf,int ln,unsigned long ul,unsigned char base)
   \                     Num_to_str:
     94          {
   \   00000000   ....               RCALL   ?PROLOGUE7_L09
   \   00000002                      REQUIRE ?Register_R4_is_cg_reg
   \   00000002                      REQUIRE ?Register_R5_is_cg_reg
   \   00000002                      REQUIRE ?Register_R6_is_cg_reg
   \   00000002   9728               SBIW    R29:R28, 8
   \   00000004   0128               MOVW    R5:R4, R17:R16
   \   00000006   01D9               MOVW    R27:R26, R19:R18
     95            int    n;          // Счетчик позиции в буфере    
     96            ldiv_t res;        // Результат целочисленного деления
     97            unsigned char b;
     98            int i;
     99            
    100            n=0;
   \   00000008   E080               LDI     R24, 0
   \   0000000A   E090               LDI     R25, 0
   \   0000000C   846F               LDD     R6, Y+15
   \   0000000E   C007               RJMP    ??Num_to_str_0
    101            for (;;)                            
    102            {                                   
    103              res=ldiv(ul,base);                 
    104              *(buf+n)=hex_to_ascii(res.rem);       
    105              n++;                              
    106              if (ln!=0) 
    107              {                       
    108                if (n>=ln) break;             
   \                     ??Num_to_str_1:
   \   00000010   178A               CP      R24, R26
   \   00000012   079B               CPC     R25, R27
   \   00000014   F4FC               BRGE    ??Num_to_str_2
    109              }  
    110              else                    
    111              {          
    112                if (res.quot==0) break;         
    113              }  
    114              ul=res.quot;                      
   \                     ??Num_to_str_3:
   \   00000016   8148               LD      R20, Y
   \   00000018   8159               LDD     R21, Y+1
   \   0000001A   816A               LDD     R22, Y+2
   \   0000001C   817B               LDD     R23, Y+3
   \                     ??Num_to_str_0:
   \   0000001E   E010               LDI     R17, 0
   \   00000020   931A               ST      -Y, R17
   \   00000022   931A               ST      -Y, R17
   \   00000024   931A               ST      -Y, R17
   \   00000026   926A               ST      -Y, R6
   \   00000028   018E               MOVW    R17:R16, R29:R28
   \   0000002A   5F0C               SUBI    R16, 252
   \   0000002C   4F1F               SBCI    R17, 255
   \   0000002E   ....               RCALL   ldiv
   \   00000030   810C               LDD     R16, Y+4
   \   00000032   ....               RCALL   hex_to_ascii
   \   00000034   01F2               MOVW    R31:R30, R5:R4
   \   00000036   0FE8               ADD     R30, R24
   \   00000038   1FF9               ADC     R31, R25
   \   0000003A   8300               ST      Z, R16
   \   0000003C   9601               ADIW    R25:R24, 1
   \   0000003E   2F0A               MOV     R16, R26
   \   00000040   2B0B               OR      R16, R27
   \   00000042   F731               BRNE    ??Num_to_str_1
   \   00000044   8108               LD      R16, Y
   \   00000046   8119               LDD     R17, Y+1
   \   00000048   812A               LDD     R18, Y+2
   \   0000004A   813B               LDD     R19, Y+3
   \   0000004C   2B01               OR      R16, R17
   \   0000004E   2B02               OR      R16, R18
   \   00000050   2B03               OR      R16, R19
   \   00000052   F709               BRNE    ??Num_to_str_3
    115            }              
    116          
    117            // Переписать буфер в обратной последовательности
    118            for (i=0;i<(n / 2);i++)
   \                     ??Num_to_str_2:
   \   00000054   E0A0               LDI     R26, 0
   \   00000056   E0B0               LDI     R27, 0
   \   00000058   0192               MOVW    R19:R18, R5:R4
   \   0000005A   0F28               ADD     R18, R24
   \   0000005C   1F39               ADC     R19, R25
   \   0000005E   C015               RJMP    ??Num_to_str_4
    119            {
    120              b=*(buf+i);
   \                     ??Num_to_str_5:
   \   00000060   01A2               MOVW    R21:R20, R5:R4
   \   00000062   0F4A               ADD     R20, R26
   \   00000064   1F5B               ADC     R21, R27
   \   00000066   01FA               MOVW    R31:R30, R21:R20
   \   00000068   8000               LD      R0, Z
    121              *(buf+i)=*(buf+n-i-1);
   \   0000006A   01BD               MOVW    R23:R22, R27:R26
   \   0000006C   9571               NEG     R23
   \   0000006E   9561               NEG     R22
   \   00000070   4070               SBCI    R23, 0
   \   00000072   0189               MOVW    R17:R16, R19:R18
   \   00000074   0F06               ADD     R16, R22
   \   00000076   1F17               ADC     R17, R23
   \   00000078   5001               SUBI    R16, 1
   \   0000007A   4010               SBCI    R17, 0
   \   0000007C   01F8               MOVW    R31:R30, R17:R16
   \   0000007E   8160               LD      R22, Z
   \   00000080   01FA               MOVW    R31:R30, R21:R20
   \   00000082   8360               ST      Z, R22
    122              *(buf+n-i-1)=b; 
   \   00000084   01F8               MOVW    R31:R30, R17:R16
   \   00000086   8200               ST      Z, R0
    123            }
   \   00000088   9611               ADIW    R27:R26, 1
   \                     ??Num_to_str_4:
   \   0000008A   E042               LDI     R20, 2
   \   0000008C   E050               LDI     R21, 0
   \   0000008E   018C               MOVW    R17:R16, R25:R24
   \   00000090   ....               RCALL   ?SS_DIVMOD_L02
   \   00000092   17A0               CP      R26, R16
   \   00000094   07B1               CPC     R27, R17
   \   00000096   F324               BRLT    ??Num_to_str_5
    124              
    125            *(buf+n)=0; // Закончить строку нулем 
   \   00000098   01F9               MOVW    R31:R30, R19:R18
   \   0000009A   E000               LDI     R16, 0
   \   0000009C   8300               ST      Z, R16
    126            return n;
   \   0000009E   018C               MOVW    R17:R16, R25:R24
   \   000000A0   9628               ADIW    R29:R28, 8
   \   000000A2   E0E8               LDI     R30, 8
   \   000000A4   ....               RJMP    ?EPILOGUE_B7_L09
    127          }   
    128          
    129          // ==========================================================
    130          //  Преобразует строку в беззнаковое целое число 
    131          //  *buf - указатель на буфер в котором находиться строка
    132          //  base - база исчисления: 10 - десятичная, 16 - шестнадцатеричная, 2 - двоичная и т.д.  
    133          //  Возвращает  число
    134          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
    135          unsigned long Str_to_num(unsigned char *buf, unsigned char base)
   \                     Str_to_num:
    136          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
   \   00000002   2E32               MOV     R3, R18
    137            unsigned long b=0;  
   \   00000004   E040               LDI     R20, 0
   \   00000006   E050               LDI     R21, 0
   \   00000008   E060               LDI     R22, 0
   \   0000000A   E070               LDI     R23, 0
   \   0000000C   C00E               RJMP    ??Str_to_num_0
    138            while (*buf!=0)
    139            {
    140              b=b*base + ascii_to_hex(*buf);
   \                     ??Str_to_num_1:
   \   0000000E   2D03               MOV     R16, R3
   \   00000010   E010               LDI     R17, 0
   \   00000012   E020               LDI     R18, 0
   \   00000014   E030               LDI     R19, 0
   \   00000016   ....               RCALL   ?L_EC_MUL_L03
   \   00000018   01A8               MOVW    R21:R20, R17:R16
   \   0000001A   01B9               MOVW    R23:R22, R19:R18
   \   0000001C   9101               LD      R16, Z+
   \   0000001E   ....               RCALL   ascii_to_hex
   \   00000020   E010               LDI     R17, 0
   \   00000022   0F40               ADD     R20, R16
   \   00000024   1F51               ADC     R21, R17
   \   00000026   1F61               ADC     R22, R17
   \   00000028   1F71               ADC     R23, R17
    141              buf++;
    142            }   
   \                     ??Str_to_num_0:
   \   0000002A   8100               LD      R16, Z
   \   0000002C   2300               TST     R16
   \   0000002E   F779               BRNE    ??Str_to_num_1
    143            return b; 
   \   00000030   018A               MOVW    R17:R16, R21:R20
   \   00000032   019B               MOVW    R19:R18, R23:R22
   \   00000034   9508               RET
    144            
    145          } 
    146          /* ========================================================
    147             Выравнивание строки вправо
    148             ========================================================*/

   \                                 In  segment CODE, align 2, keep-with-next
    149          void Right_align_str(unsigned char *buf, int buf_len)
   \                     Right_align_str:
    150          {
   \   00000000   ....               RCALL   ?PROLOGUE4_L09
   \   00000002   01A8               MOVW    R21:R20, R17:R16
   \   00000004   01B9               MOVW    R23:R22, R19:R18
    151            int l=0;
   \   00000006   E080               LDI     R24, 0
   \   00000008   E090               LDI     R25, 0
   \   0000000A   C001               RJMP    ??Right_align_str_0
    152            int i;
    153            while (*(buf+l)!=0) l++; // Найдем длину строки в буфере
   \                     ??Right_align_str_1:
   \   0000000C   9601               ADIW    R25:R24, 1
   \                     ??Right_align_str_0:
   \   0000000E   018A               MOVW    R17:R16, R21:R20
   \   00000010   0F08               ADD     R16, R24
   \   00000012   1F19               ADC     R17, R25
   \   00000014   01F8               MOVW    R31:R30, R17:R16
   \   00000016   8120               LD      R18, Z
   \   00000018   2322               TST     R18
   \   0000001A   F7C1               BRNE    ??Right_align_str_1
    154            if (l<buf_len)
   \   0000001C   1786               CP      R24, R22
   \   0000001E   0797               CPC     R25, R23
   \   00000020   F4DC               BRGE    ??Right_align_str_2
    155            {
    156              for (i=0;i<l;i++) 
   \   00000022   E020               LDI     R18, 0
   \   00000024   E030               LDI     R19, 0
   \   00000026   0F46               ADD     R20, R22
   \   00000028   1F57               ADC     R21, R23
   \   0000002A   C010               RJMP    ??Right_align_str_3
    157              {
    158                *(buf+buf_len-1-i)=*(buf+l-1-i);
   \                     ??Right_align_str_4:
   \   0000002C   01B9               MOVW    R23:R22, R19:R18
   \   0000002E   9571               NEG     R23
   \   00000030   9561               NEG     R22
   \   00000032   4070               SBCI    R23, 0
   \   00000034   01F8               MOVW    R31:R30, R17:R16
   \   00000036   0FE6               ADD     R30, R22
   \   00000038   1FF7               ADC     R31, R23
   \   0000003A   9002               LD      R0, -Z
   \   0000003C   01DA               MOVW    R27:R26, R21:R20
   \   0000003E   0FA6               ADD     R26, R22
   \   00000040   1FB7               ADC     R27, R23
   \   00000042   920E               ST      -X, R0
    159                *(buf+l-1-i)=' ';
   \   00000044   E260               LDI     R22, 32
   \   00000046   8360               ST      Z, R22
    160              }
   \   00000048   5F2F               SUBI    R18, 255
   \   0000004A   4F3F               SBCI    R19, 255
   \                     ??Right_align_str_3:
   \   0000004C   1728               CP      R18, R24
   \   0000004E   0739               CPC     R19, R25
   \   00000050   F36C               BRLT    ??Right_align_str_4
    161              *(buf+buf_len)=0; 
   \   00000052   01FA               MOVW    R31:R30, R21:R20
   \   00000054   E000               LDI     R16, 0
   \   00000056   8300               ST      Z, R16
    162            } 
    163          } 
   \                     ??Right_align_str_2:
   \   00000058   E0E4               LDI     R30, 4
   \   0000005A   ....               RJMP    ?EPILOGUE_B4_L09
    164          
    165          // ==========================================================
    166          //  Преобразование числа в строковое представление. Возвращает указатель на конец занятого буфера 
    167          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
    168          unsigned char *float_conversion(float value,   // Преобразуемая величина
   \                     float_conversion:
    169                                        short nr_of_digits,    // Общее количество цифр для представления числа 
    170                                                               // Если число меньше 1, то не считая предварительных нулей 
    171                                        unsigned char *buf,     
    172                                        unsigned char format_flag,    // 'E' или 'e'
    173                                        unsigned char g_flag,         // 1 - представлять в формате с фиксированной точкой
    174                                        unsigned char alternate_flag) // 1 - не убирать не значащие нули
    175          {
   \   00000000   ....               RCALL   ?PROLOGUE16_L09
   \   00000002                      REQUIRE ?Register_R4_is_cg_reg
   \   00000002                      REQUIRE ?Register_R5_is_cg_reg
   \   00000002                      REQUIRE ?Register_R6_is_cg_reg
   \   00000002                      REQUIRE ?Register_R7_is_cg_reg
   \   00000002                      REQUIRE ?Register_R8_is_cg_reg
   \   00000002                      REQUIRE ?Register_R9_is_cg_reg
   \   00000002                      REQUIRE ?Register_R10_is_cg_reg
   \   00000002                      REQUIRE ?Register_R11_is_cg_reg
   \   00000002                      REQUIRE ?Register_R12_is_cg_reg
   \   00000002                      REQUIRE ?Register_R13_is_cg_reg
   \   00000002                      REQUIRE ?Register_R14_is_cg_reg
   \   00000002                      REQUIRE ?Register_R15_is_cg_reg
   \   00000002   01C8               MOVW    R25:R24, R17:R16
   \   00000004   01D9               MOVW    R27:R26, R19:R18
   \   00000006   017A               MOVW    R15:R14, R21:R20
   \   00000008   015B               MOVW    R11:R10, R23:R22
    176            unsigned char *cp, *buf_pointer;
    177            short n, i, dec_point_pos, integral_10_log;
    178          
    179            buf_pointer = buf;
   \   0000000A   016B               MOVW    R13:R12, R23:R22
    180            integral_10_log = 0;
   \   0000000C   2488               CLR     R8
   \   0000000E   2499               CLR     R9
    181            // Показать знак числа
    182            if (value<0)
   \   00000010   E040               LDI     R20, 0
   \   00000012   E050               LDI     R21, 0
   \   00000014   E060               LDI     R22, 0
   \   00000016   E070               LDI     R23, 0
   \   00000018   ....               RCALL   ?F_CMP_LT_L04
   \   0000001A   F428               BRCC    ??float_conversion_0
    183            {
    184              value=-value;
   \   0000001C   58B0               SUBI    R27, 128
    185              *buf_pointer++ = '-';
   \   0000001E   01F6               MOVW    R31:R30, R13:R12
   \   00000020   E20D               LDI     R16, 45
   \   00000022   9301               ST      Z+, R16
   \   00000024   016F               MOVW    R13:R12, R31:R30
    186            } 
    187            
    188            if (value >= 1)
   \                     ??float_conversion_0:
   \   00000026   2F08               MOV     R16, R24
   \   00000028   2F3B               MOV     R19, R27
   \   0000002A   E860               LDI     R22, 128
   \   0000002C   E37F               LDI     R23, 63
   \   0000002E   ....               RCALL   ?F_CMP_GE_L04
   \   00000030   F160               BRCS    ??float_conversion_1
    189            {
    190              // Вычисляем количество десятков в экспоненте
    191              while (value >= 1e11)        
    192              {
    193                value /= 1e10;
    194                integral_10_log += 10;
    195              }
    196              // Вычисляем количество единиц в экспоненте
    197              while (value >= 10)
    198              {
    199                value /= 10;
    200                integral_10_log++;
    201              }
    202            }
    203            else if (value)            
   \   00000032   2F0B               MOV     R16, R27
   \   00000034   0F00               LSL     R16
   \   00000036   2B08               OR      R16, R24
   \   00000038   2B09               OR      R16, R25
   \   0000003A   2B0A               OR      R16, R26
   \   0000003C   F009               BREQ    $+2+2
   \   0000003E   C048               RJMP    ??float_conversion_2
    204            {
    205              // Вычисляем количество десятков в знаменателе экспоненты
    206              while (value <= 1e-10)        
    207              {
    208                value *= 1e10;
    209                integral_10_log -= 10;
    210              }
    211              // Вычисляем количество единиц в знаменателе экспоненты
    212              while (value < 1)
    213              {
    214                value *= 10;
    215                integral_10_log--;
    216              }
    217            }
    218            
    219            if (g_flag)
   \                     ??float_conversion_3:
   \   00000040   8909               LDD     R16, Y+17
   \   00000042   2300               TST     R16
   \   00000044   F409               BRNE    $+2+2
   \   00000046   C060               RJMP    ??float_conversion_4
    220            {
    221              if (integral_10_log < nr_of_digits && integral_10_log >= -4)
   \   00000048   148E               CP      R8, R14
   \   0000004A   049F               CPC     R9, R15
   \   0000004C   F44C               BRGE    ??float_conversion_5
   \   0000004E   EF0C               LDI     R16, 252
   \   00000050   1680               CP      R8, R16
   \   00000052   EF0F               LDI     R16, 255
   \   00000054   0690               CPC     R9, R16
   \   00000056   F024               BRLT    ??float_conversion_5
    222              {
    223                format_flag = 0;
   \   00000058   E000               LDI     R16, 0
   \   0000005A   8B08               STD     Y+16, R16
    224                nr_of_digits = nr_of_digits - integral_10_log;
   \   0000005C   18E8               SUB     R14, R8
   \   0000005E   08F9               SBC     R15, R9
    225              }
    226              nr_of_digits--;
   \                     ??float_conversion_5:
   \   00000060   EF0F               LDI     R16, 255
   \   00000062   0EE0               ADD     R14, R16
   \   00000064   1EF0               ADC     R15, R16
    227              if (alternate_flag)
   \   00000066   890A               LDD     R16, Y+18
   \   00000068   2300               TST     R16
   \   0000006A   F409               BRNE    $+2+2
   \   0000006C   C04B               RJMP    ??float_conversion_6
    228              {
    229                g_flag = 0;         /* %#G - No removal of trailing zeros */
   \   0000006E   E000               LDI     R16, 0
   \   00000070   8B09               STD     Y+17, R16
   \   00000072   C04A               RJMP    ??float_conversion_4
    230              }
   \                     ??float_conversion_7:
   \   00000074   EF49               LDI     R20, 249
   \   00000076   E052               LDI     R21, 2
   \   00000078   E165               LDI     R22, 21
   \   0000007A   E570               LDI     R23, 80
   \   0000007C   ....               RCALL   ?F_DIV_L04
   \   0000007E   01C8               MOVW    R25:R24, R17:R16
   \   00000080   01D9               MOVW    R27:R26, R19:R18
   \   00000082   E00A               LDI     R16, 10
   \   00000084   0E80               ADD     R8, R16
   \   00000086   E000               LDI     R16, 0
   \   00000088   1E90               ADC     R9, R16
   \                     ??float_conversion_1:
   \   0000008A   018C               MOVW    R17:R16, R25:R24
   \   0000008C   019D               MOVW    R19:R18, R27:R26
   \   0000008E   EB47               LDI     R20, 183
   \   00000090   E453               LDI     R21, 67
   \   00000092   EB6A               LDI     R22, 186
   \   00000094   E571               LDI     R23, 81
   \   00000096   ....               RCALL   ?F_CMP_GE_L04
   \   00000098   F368               BRCS    ??float_conversion_7
   \                     ??float_conversion_8:
   \   0000009A   018C               MOVW    R17:R16, R25:R24
   \   0000009C   019D               MOVW    R19:R18, R27:R26
   \   0000009E   E040               LDI     R20, 0
   \   000000A0   E050               LDI     R21, 0
   \   000000A2   E260               LDI     R22, 32
   \   000000A4   E471               LDI     R23, 65
   \   000000A6   ....               RCALL   ?F_CMP_GE_L04
   \   000000A8   F658               BRCC    ??float_conversion_3
   \   000000AA   ....               RCALL   ?F_DIV_L04
   \   000000AC   01C8               MOVW    R25:R24, R17:R16
   \   000000AE   01D9               MOVW    R27:R26, R19:R18
   \   000000B0   E001               LDI     R16, 1
   \   000000B2   0E80               ADD     R8, R16
   \   000000B4   E000               LDI     R16, 0
   \   000000B6   1E90               ADC     R9, R16
   \   000000B8   CFF0               RJMP    ??float_conversion_8
   \                     ??float_conversion_9:
   \   000000BA   EF49               LDI     R20, 249
   \   000000BC   E052               LDI     R21, 2
   \   000000BE   E165               LDI     R22, 21
   \   000000C0   E570               LDI     R23, 80
   \   000000C2   ....               RCALL   ?F_MUL_L04
   \   000000C4   01C8               MOVW    R25:R24, R17:R16
   \   000000C6   01D9               MOVW    R27:R26, R19:R18
   \   000000C8   EF06               LDI     R16, 246
   \   000000CA   0E80               ADD     R8, R16
   \   000000CC   EF0F               LDI     R16, 255
   \   000000CE   1E90               ADC     R9, R16
   \                     ??float_conversion_2:
   \   000000D0   018C               MOVW    R17:R16, R25:R24
   \   000000D2   019D               MOVW    R19:R18, R27:R26
   \   000000D4   E040               LDI     R20, 0
   \   000000D6   EE57               LDI     R21, 231
   \   000000D8   ED6B               LDI     R22, 219
   \   000000DA   E27E               LDI     R23, 46
   \   000000DC   ....               RCALL   ?F_CMP_LT_L04
   \   000000DE   F368               BRCS    ??float_conversion_9
   \                     ??float_conversion_10:
   \   000000E0   018C               MOVW    R17:R16, R25:R24
   \   000000E2   019D               MOVW    R19:R18, R27:R26
   \   000000E4   E040               LDI     R20, 0
   \   000000E6   E050               LDI     R21, 0
   \   000000E8   E860               LDI     R22, 128
   \   000000EA   E37F               LDI     R23, 63
   \   000000EC   ....               RCALL   ?F_CMP_LT_L04
   \   000000EE   F008               BRCS    $+2+2
   \   000000F0   CFA7               RJMP    ??float_conversion_3
   \   000000F2   E260               LDI     R22, 32
   \   000000F4   E471               LDI     R23, 65
   \   000000F6   ....               RCALL   ?F_MUL_L04
   \   000000F8   01C8               MOVW    R25:R24, R17:R16
   \   000000FA   01D9               MOVW    R27:R26, R19:R18
   \   000000FC   EF0F               LDI     R16, 255
   \   000000FE   0E80               ADD     R8, R16
   \   00000100   1E90               ADC     R9, R16
   \   00000102   CFEE               RJMP    ??float_conversion_10
    231              else
    232              {
    233                alternate_flag = 1;  /* %G - Removal of trailing zeros */
   \                     ??float_conversion_6:
   \   00000104   E001               LDI     R16, 1
   \   00000106   8B0A               STD     Y+18, R16
    234              }
    235            }
    236            
    237            if (format_flag)        /* %e or %E */
   \                     ??float_conversion_4:
   \   00000108   8908               LDD     R16, Y+16
   \   0000010A   2300               TST     R16
   \   0000010C   F019               BREQ    ??float_conversion_11
    238            {
    239              // Для представления с экспонентой
    240              dec_point_pos = 0;
   \   0000010E   2466               CLR     R6
   \   00000110   2477               CLR     R7
   \   00000112   C05B               RJMP    ??float_conversion_12
    241            }
    242            else
    243            {
    244              if (integral_10_log < 0)       
   \                     ??float_conversion_11:
   \   00000114   2099               TST     R9
   \   00000116   F55A               BRPL    ??float_conversion_13
    245              {
    246                // Для чисел меньших по абсолютному значению чем 1 в представлении без экспоненты
    247                *buf_pointer++ = '0';
   \   00000118   01F6               MOVW    R31:R30, R13:R12
   \   0000011A   E300               LDI     R16, 48
   \   0000011C   9301               ST      Z+, R16
   \   0000011E   016F               MOVW    R13:R12, R31:R30
    248                if ((n = nr_of_digits) || alternate_flag)
   \   00000120   0127               MOVW    R5:R4, R15:R14
   \   00000122   2D0E               MOV     R16, R14
   \   00000124   2905               OR      R16, R5
   \   00000126   F419               BRNE    ??float_conversion_14
   \   00000128   890A               LDD     R16, Y+18
   \   0000012A   2300               TST     R16
   \   0000012C   F019               BREQ    ??float_conversion_15
    249                {
    250                  *buf_pointer++ = '.';
   \                     ??float_conversion_14:
   \   0000012E   E20E               LDI     R16, 46
   \   00000130   9301               ST      Z+, R16
   \   00000132   016F               MOVW    R13:R12, R31:R30
    251                }
    252                i = 0;
   \                     ??float_conversion_15:
   \   00000134   2466               CLR     R6
   \   00000136   2477               CLR     R7
   \   00000138   C007               RJMP    ??float_conversion_16
    253                while (--i > integral_10_log && nr_of_digits)
    254                {
    255                  *buf_pointer++ = '0';
   \                     ??float_conversion_17:
   \   0000013A   01F6               MOVW    R31:R30, R13:R12
   \   0000013C   E300               LDI     R16, 48
   \   0000013E   9301               ST      Z+, R16
   \   00000140   016F               MOVW    R13:R12, R31:R30
    256                  nr_of_digits--;
   \   00000142   EF0F               LDI     R16, 255
   \   00000144   0EE0               ADD     R14, R16
   \   00000146   1EF0               ADC     R15, R16
    257                }
   \                     ??float_conversion_16:
   \   00000148   EF0F               LDI     R16, 255
   \   0000014A   0E60               ADD     R6, R16
   \   0000014C   1E70               ADC     R7, R16
   \   0000014E   1486               CP      R8, R6
   \   00000150   0497               CPC     R9, R7
   \   00000152   F41C               BRGE    ??float_conversion_18
   \   00000154   2D0E               MOV     R16, R14
   \   00000156   290F               OR      R16, R15
   \   00000158   F781               BRNE    ??float_conversion_17
    258                if (integral_10_log < (-n - 1))
   \                     ??float_conversion_18:
   \   0000015A   9440               COM     R4
   \   0000015C   9450               COM     R5
   \   0000015E   1484               CP      R8, R4
   \   00000160   0495               CPC     R9, R5
   \   00000162   F40C               BRGE    $+2+2
   \   00000164   C07C               RJMP    ??float_conversion_19
    259                {
    260                  goto CLEAN_UP;     /* Nothing more to do */
    261                }
    262                dec_point_pos = 1;
   \   00000166   2477               CLR     R7
   \   00000168   2466               CLR     R6
   \   0000016A   9463               INC     R6
   \   0000016C   C02E               RJMP    ??float_conversion_12
    263              }
    264              else
    265              {
    266                // Для чисел больших по абсолютному значению чем 1 в представлении без экспоненты
    267                dec_point_pos = - integral_10_log;
   \                     ??float_conversion_13:
   \   0000016E   0134               MOVW    R7:R6, R9:R8
   \   00000170   9471               NEG     R7
   \   00000172   9461               NEG     R6
   \   00000174   E000               LDI     R16, 0
   \   00000176   0A70               SBC     R7, R16
   \   00000178   C028               RJMP    ??float_conversion_12
    268              }
    269            }
    270          
    271            i = dec_point_pos;
    272            while (i <= nr_of_digits )
    273            {
    274              n = (short)value;
   \                     ??float_conversion_20:
   \   0000017A   ....               RCALL   ?F2SL_L04
   \   0000017C   2E40               MOV     R4, R16
    275              value = value - n;          /* n=Digit value=Remainder */
    276              value = value * 10;         /* Prepare for next shot */
   \   0000017E   2F21               MOV     R18, R17
   \   00000180   0F22               LSL     R18
   \   00000182   0B22               SBC     R18, R18
   \   00000184   2F32               MOV     R19, R18
   \   00000186   ....               RCALL   ?SL2F_L04
   \   00000188   01A8               MOVW    R21:R20, R17:R16
   \   0000018A   01B9               MOVW    R23:R22, R19:R18
   \   0000018C   018C               MOVW    R17:R16, R25:R24
   \   0000018E   019D               MOVW    R19:R18, R27:R26
   \   00000190   ....               RCALL   ?F_SUB_L04
   \   00000192   E040               LDI     R20, 0
   \   00000194   E050               LDI     R21, 0
   \   00000196   E260               LDI     R22, 32
   \   00000198   E471               LDI     R23, 65
   \   0000019A   ....               RCALL   ?F_MUL_L04
   \   0000019C   01C8               MOVW    R25:R24, R17:R16
   \   0000019E   01D9               MOVW    R27:R26, R19:R18
    277              *buf_pointer++ = n + '0';
   \   000001A0   2D04               MOV     R16, R4
   \   000001A2   5D00               SUBI    R16, 208
   \   000001A4   01F6               MOVW    R31:R30, R13:R12
   \   000001A6   9301               ST      Z+, R16
   \   000001A8   016F               MOVW    R13:R12, R31:R30
    278              if ( ! i++ && (nr_of_digits || alternate_flag))
   \   000001AA   0193               MOVW    R19:R18, R7:R6
   \   000001AC   E001               LDI     R16, 1
   \   000001AE   0E60               ADD     R6, R16
   \   000001B0   E000               LDI     R16, 0
   \   000001B2   1E70               ADC     R7, R16
   \   000001B4   2B23               OR      R18, R19
   \   000001B6   F449               BRNE    ??float_conversion_12
   \   000001B8   2D0E               MOV     R16, R14
   \   000001BA   290F               OR      R16, R15
   \   000001BC   F419               BRNE    ??float_conversion_21
   \   000001BE   890A               LDD     R16, Y+18
   \   000001C0   2300               TST     R16
   \   000001C2   F019               BREQ    ??float_conversion_12
    279              {
    280                *buf_pointer++ = '.';
   \                     ??float_conversion_21:
   \   000001C4   E20E               LDI     R16, 46
   \   000001C6   9301               ST      Z+, R16
   \   000001C8   016F               MOVW    R13:R12, R31:R30
    281              }
    282            } // while
   \                     ??float_conversion_12:
   \   000001CA   14E6               CP      R14, R6
   \   000001CC   04F7               CPC     R15, R7
   \   000001CE   018C               MOVW    R17:R16, R25:R24
   \   000001D0   019D               MOVW    R19:R18, R27:R26
   \   000001D2   F69C               BRGE    ??float_conversion_20
    283            
    284            if (value >= 5)    /* Rounding possible */
   \   000001D4   E040               LDI     R20, 0
   \   000001D6   E050               LDI     R21, 0
   \   000001D8   EA60               LDI     R22, 160
   \   000001DA   E470               LDI     R23, 64
   \   000001DC   ....               RCALL   ?F_CMP_GE_L04
   \   000001DE   F5F8               BRCC    ??float_conversion_19
    285            {
    286              n = 1;    /* Carry */
   \   000001E0   2444               CLR     R4
   \   000001E2   9443               INC     R4
    287              cp = buf_pointer - 1;
   \   000001E4   01C6               MOVW    R25:R24, R13:R12
   \   000001E6   9701               SBIW    R25:R24, 1
    288              do
    289              {
    290                if (*cp != '.')
   \                     ??float_conversion_22:
   \   000001E8   01FC               MOVW    R31:R30, R25:R24
   \   000001EA   8100               LD      R16, Z
   \   000001EC   320E               CPI     R16, 46
   \   000001EE   F051               BREQ    ??float_conversion_23
    291                  if ( (*cp += n) == ('9' + 1) )
   \   000001F0   0D04               ADD     R16, R4
   \   000001F2   8300               ST      Z, R16
   \   000001F4   330A               CPI     R16, 58
   \   000001F6   F429               BRNE    ??float_conversion_24
    292                  {
    293                    *cp = '0';
   \   000001F8   E300               LDI     R16, 48
   \   000001FA   8300               ST      Z, R16
    294                    n = 1;
   \   000001FC   2444               CLR     R4
   \   000001FE   9443               INC     R4
   \   00000200   C001               RJMP    ??float_conversion_23
    295                  }
    296                  else
    297                  {
    298                    n = 0;
   \                     ??float_conversion_24:
   \   00000202   2444               CLR     R4
    299                  }
    300              } while (cp-- > buf);
   \                     ??float_conversion_23:
   \   00000204   9701               SBIW    R25:R24, 1
   \   00000206   16AE               CP      R10, R30
   \   00000208   06BF               CPC     R11, R31
   \   0000020A   F370               BRCS    ??float_conversion_22
    301              if (n)
   \   0000020C   FA40               BST     R4, 0
   \   0000020E   F53E               BRTC    ??float_conversion_19
    302              {
    303                if (format_flag)        /* %e or %E */
   \   00000210   8908               LDD     R16, Y+16
   \   00000212   2300               TST     R16
   \   00000214   F0A9               BREQ    ??float_conversion_25
    304                {
    305                  cp = buf_pointer;
   \   00000216   01C6               MOVW    R25:R24, R13:R12
   \   00000218   C002               RJMP    ??float_conversion_26
    306                  while (cp > buf)
    307                  {
    308                    if (*(cp - 1) == '.')
    309                    {
    310                      *cp = *(cp - 2);
    311                      cp--;
    312                    }
    313                    else
    314                    {
    315                      *cp = *(cp - 1);
   \                     ??float_conversion_27:
   \   0000021A   8301               STD     Z+1, R16
    316                    }
    317                    cp--;
   \                     ??float_conversion_28:
   \   0000021C   9701               SBIW    R25:R24, 1
   \                     ??float_conversion_26:
   \   0000021E   16A8               CP      R10, R24
   \   00000220   06B9               CPC     R11, R25
   \   00000222   F450               BRCC    ??float_conversion_29
   \   00000224   01FC               MOVW    R31:R30, R25:R24
   \   00000226   9102               LD      R16, -Z
   \   00000228   320E               CPI     R16, 46
   \   0000022A   F7B9               BRNE    ??float_conversion_27
   \   0000022C   01FC               MOVW    R31:R30, R25:R24
   \   0000022E   9732               SBIW    R31:R30, 2
   \   00000230   8100               LD      R16, Z
   \   00000232   8302               STD     Z+2, R16
   \   00000234   9701               SBIW    R25:R24, 1
   \   00000236   CFF2               RJMP    ??float_conversion_28
    318                  }
    319                  integral_10_log++;
   \                     ??float_conversion_29:
   \   00000238   E001               LDI     R16, 1
   \   0000023A   0E80               ADD     R8, R16
   \   0000023C   1E94               ADC     R9, R20
   \   0000023E   C00C               RJMP    ??float_conversion_30
    320                }
    321                else
    322                {
    323                  cp = ++buf_pointer;
   \                     ??float_conversion_25:
   \   00000240   E001               LDI     R16, 1
   \   00000242   0EC0               ADD     R12, R16
   \   00000244   1ED4               ADC     R13, R20
   \   00000246   01C6               MOVW    R25:R24, R13:R12
   \   00000248   C004               RJMP    ??float_conversion_31
    324                  while (cp > buf)
    325                  {
    326                    *cp = *(cp - 1);
   \                     ??float_conversion_32:
   \   0000024A   01FC               MOVW    R31:R30, R25:R24
   \   0000024C   9102               LD      R16, -Z
   \   0000024E   8301               STD     Z+1, R16
    327                    cp--;
   \   00000250   9701               SBIW    R25:R24, 1
    328                  }
   \                     ??float_conversion_31:
   \   00000252   16A8               CP      R10, R24
   \   00000254   06B9               CPC     R11, R25
   \   00000256   F3C8               BRCS    ??float_conversion_32
    329                }
    330                *buf = '1';
   \                     ??float_conversion_30:
   \   00000258   01F5               MOVW    R31:R30, R11:R10
   \   0000025A   E301               LDI     R16, 49
   \   0000025C   8300               ST      Z, R16
    331              }
    332            }
    333          CLEAN_UP:
    334            if (g_flag)            /* %G - Remove trailing zeros */
   \                     ??float_conversion_19:
   \   0000025E   8909               LDD     R16, Y+17
   \   00000260   2300               TST     R16
   \   00000262   F421               BRNE    ??float_conversion_33
   \   00000264   C00C               RJMP    ??float_conversion_34
    335            {
    336              while (*(buf_pointer - 1) == '0')
    337              {
    338                buf_pointer--;
   \                     ??float_conversion_35:
   \   00000266   EF0F               LDI     R16, 255
   \   00000268   0EC0               ADD     R12, R16
   \   0000026A   1ED0               ADC     R13, R16
    339              }
   \                     ??float_conversion_33:
   \   0000026C   01F6               MOVW    R31:R30, R13:R12
   \   0000026E   9102               LD      R16, -Z
   \   00000270   3300               CPI     R16, 48
   \   00000272   F3C9               BREQ    ??float_conversion_35
    340              if (*(buf_pointer - 1) == '.')
   \   00000274   320E               CPI     R16, 46
   \   00000276   F419               BRNE    ??float_conversion_34
    341              {
    342                buf_pointer--;
   \   00000278   EF0F               LDI     R16, 255
   \   0000027A   0EC0               ADD     R12, R16
   \   0000027C   1ED0               ADC     R13, R16
    343              }
    344            }
    345            if (format_flag)        /* %e or %E */
   \                     ??float_conversion_34:
   \   0000027E   8908               LDD     R16, Y+16
   \   00000280   2300               TST     R16
   \   00000282   F409               BRNE    $+2+2
   \   00000284   C04F               RJMP    ??float_conversion_36
    346            {
    347              *buf_pointer++ = format_flag;
   \   00000286   01F6               MOVW    R31:R30, R13:R12
   \   00000288   8300               ST      Z, R16
    348              if (integral_10_log < 0)
   \   0000028A   2099               TST     R9
   \   0000028C   F452               BRPL    ??float_conversion_37
    349              {
    350                *buf_pointer++ = '-';
   \   0000028E   E20D               LDI     R16, 45
   \   00000290   8301               STD     Z+1, R16
   \   00000292   E002               LDI     R16, 2
   \   00000294   0EC0               ADD     R12, R16
   \   00000296   E000               LDI     R16, 0
   \   00000298   1ED0               ADC     R13, R16
    351                integral_10_log = -integral_10_log;
   \   0000029A   9491               NEG     R9
   \   0000029C   9481               NEG     R8
   \   0000029E   0A90               SBC     R9, R16
   \   000002A0   C006               RJMP    ??float_conversion_38
    352              }
    353              else
    354              {
    355                *buf_pointer++ = '+';
   \                     ??float_conversion_37:
   \   000002A2   E20B               LDI     R16, 43
   \   000002A4   8301               STD     Z+1, R16
   \   000002A6   E002               LDI     R16, 2
   \   000002A8   0EC0               ADD     R12, R16
   \   000002AA   E000               LDI     R16, 0
   \   000002AC   1ED0               ADC     R13, R16
    356              }
    357              n = 0;
   \                     ??float_conversion_38:
   \   000002AE   2444               CLR     R4
   \   000002B0   2455               CLR     R5
    358              buf_pointer +=3;
   \   000002B2   E003               LDI     R16, 3
   \   000002B4   0EC0               ADD     R12, R16
   \   000002B6   1CD4               ADC     R13, R4
    359              do
    360              {
    361                n++;
   \                     ??float_conversion_39:
   \   000002B8   E001               LDI     R16, 1
   \   000002BA   0E40               ADD     R4, R16
   \   000002BC   E000               LDI     R16, 0
   \   000002BE   1E50               ADC     R5, R16
    362                *buf_pointer++ = (integral_10_log % 10) + '0'; // Запись в буфер цифр экспоненты
   \   000002C0   E04A               LDI     R20, 10
   \   000002C2   E050               LDI     R21, 0
   \   000002C4   0184               MOVW    R17:R16, R9:R8
   \   000002C6   ....               RCALL   ?SS_DIVMOD_L02
   \   000002C8   5D40               SUBI    R20, 208
   \   000002CA   01F6               MOVW    R31:R30, R13:R12
   \   000002CC   9341               ST      Z+, R20
   \   000002CE   016F               MOVW    R13:R12, R31:R30
    363                integral_10_log /= 10;
   \   000002D0   E04A               LDI     R20, 10
   \   000002D2   E050               LDI     R21, 0
   \   000002D4   0184               MOVW    R17:R16, R9:R8
   \   000002D6   ....               RCALL   ?SS_DIVMOD_L02
   \   000002D8   0148               MOVW    R9:R8, R17:R16
    364              } while ( integral_10_log || n < 2 );
   \   000002DA   2B01               OR      R16, R17
   \   000002DC   F769               BRNE    ??float_conversion_39
   \   000002DE   E002               LDI     R16, 2
   \   000002E0   1640               CP      R4, R16
   \   000002E2   E000               LDI     R16, 0
   \   000002E4   0650               CPC     R5, R16
   \   000002E6   F344               BRLT    ??float_conversion_39
    365              for ( i = n ; n > 0 ; n-- )
   \   000002E8   0132               MOVW    R7:R6, R5:R4
   \   000002EA   01C2               MOVW    R25:R24, R5:R4
    366                *(buf_pointer - 4 - i + n) = *(buf_pointer - n);
   \                     ??float_conversion_40:
   \   000002EC   0182               MOVW    R17:R16, R5:R4
   \   000002EE   9511               NEG     R17
   \   000002F0   9501               NEG     R16
   \   000002F2   4010               SBCI    R17, 0
   \   000002F4   01F6               MOVW    R31:R30, R13:R12
   \   000002F6   0FE0               ADD     R30, R16
   \   000002F8   1FF1               ADC     R31, R17
   \   000002FA   8120               LD      R18, Z
   \   000002FC   0183               MOVW    R17:R16, R7:R6
   \   000002FE   9511               NEG     R17
   \   00000300   9501               NEG     R16
   \   00000302   4010               SBCI    R17, 0
   \   00000304   01F6               MOVW    R31:R30, R13:R12
   \   00000306   0FE0               ADD     R30, R16
   \   00000308   1FF1               ADC     R31, R17
   \   0000030A   0DE4               ADD     R30, R4
   \   0000030C   1DF5               ADC     R31, R5
   \   0000030E   9734               SBIW    R31:R30, 4
   \   00000310   8320               ST      Z, R18
   \   00000312   EF0F               LDI     R16, 255
   \   00000314   0E40               ADD     R4, R16
   \   00000316   1E50               ADC     R5, R16
   \   00000318   9701               SBIW    R25:R24, 1
   \   0000031A   F741               BRNE    ??float_conversion_40
    367              buf_pointer -= 3;
   \   0000031C   EF0D               LDI     R16, 253
   \   0000031E   0EC0               ADD     R12, R16
   \   00000320   EF0F               LDI     R16, 255
   \   00000322   1ED0               ADC     R13, R16
    368            }
    369            *buf_pointer=0;
   \                     ??float_conversion_36:
   \   00000324   01F6               MOVW    R31:R30, R13:R12
   \   00000326   E000               LDI     R16, 0
   \   00000328   8300               ST      Z, R16
    370            return buf_pointer;
   \   0000032A   0186               MOVW    R17:R16, R13:R12
   \   0000032C   E1E3               LDI     R30, 19
   \   0000032E   ....               RJMP    ?EPILOGUE_B16_L09
    371          }

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      6      2   GetBlockCRC
        6      2   -> GetCRC
      0      2   GetCRC
     20      2   Num_to_str
       16      2   -> hex_to_ascii
       16      2   -> ldiv
       16      2 ?SS_DIVMOD_L02
      4      2   Right_align_str
      0      2   Str_to_num
        0      2   -> ascii_to_hex
        0      2 ?L_EC_MUL_L03
      0      2   ascii_to_hex
     19      2   float_conversion
       19      2 ?F2SL_L04
       19      2 ?F_CMP_GE_L04
       19      2 ?F_CMP_LT_L04
       19      2 ?F_DIV_L04
       19      2 ?F_MUL_L04
       19      2 ?F_SUB_L04
       19      2 ?SL2F_L04
       19      2 ?SS_DIVMOD_L02
      0      2   hex_to_ascii
      0      2   is_hex_digit
      0      2   write_ascii


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      52  GetBlockCRC
      30  GetCRC
     166  Num_to_str
      92  Right_align_str
      54  Str_to_num
      26  ascii_to_hex
     816  float_conversion
      14  hex_to_ascii
      30  is_hex_digit
       8  write_ascii

 
 1 288 bytes in segment CODE
 
 1 288 bytes of CODE memory

Errors: none
Warnings: none
