///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR      26/Oct/2021  17:01:07
// Copyright 1996-2021 IAR Systems AB.
//
//    Source file  =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Monitor.c
//    Command line =  
//        -f C:\Users\aly\AppData\Local\Temp\EW92EA.tmp
//        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Monitor.c
//        --cpu=m8 -ms -o
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj
//        -lCN
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        -lB
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        --initializers_in_flash --no_cross_call --no_clustering --no_tbaa
//        --debug -DENABLE_BIT_DEFINITIONS -e --eeprom_size 512 --clib -Ohz)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List\Monitor.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME Monitor

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?EPILOGUE_B4_L09
        EXTERN ?EPILOGUE_B5_L09
        EXTERN ?PROLOGUE4_L09
        EXTERN ?PROLOGUE5_L09
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?US_SHR_L02
        EXTERN ?need_segment_init

        PUBWEAK `?<Segment init: NEAR_I>`
        PUBWEAK `?<Segment init: NEAR_Z>`
        PUBWEAK `??TIMER0_OVF_vect_interrupt::??INTVEC 18`
        PUBLIC TIMER0_OVF_vect_interrupt
        PUBWEAK _A_PORTB
        PUBWEAK _A_PORTD
        PUBWEAK _A_TCCR0
        PUBWEAK _A_TIFR
        PUBWEAK _A_TIMSK
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC crlf
        PUBLIC exec_cmd
        PUBLIC led_blink_tim
        PUBLIC monit_off_tim
        PUBLIC strbuf
        PUBLIC terminal

TIMER0_OVF_vect_interrupt SYMBOL "TIMER0_OVF_vect_interrupt"
`??TIMER0_OVF_vect_interrupt::??INTVEC 18` SYMBOL "??INTVEC 18", TIMER0_OVF_vect_interrupt

        EXTERN ADC_get_select_ch
        EXTERN ADC_init
        EXTERN ADC_switch_off
        EXTERN DataInReceiveBuffer
        EXTERN Param_to_str
        EXTERN Restore_default_settings
        EXTERN Restore_settings_from_eeprom
        EXTERN Save_Params_To_EEPROM
        EXTERN Str_to_param
        EXTERN USART_Receive
        EXTERN USART_Transmit
        EXTERN USART_sendstr
        EXTERN _Small_Ctype
        EXTERN get_pack_first_byte
        EXTERN get_params_name
        EXTERN get_params_num
        EXTERN hex_to_ascii
        EXTERN strcmp
        EXTERN wait_until_tx_complete

// D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Monitor.c
//    1 #include <iom8.h>

        ASEGN ABSOLUTE:DATA:NOROOT,059H
// union <unnamed> volatile __io _A_TIMSK
_A_TIMSK:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,058H
// union <unnamed> volatile __io _A_TIFR
_A_TIFR:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,053H
// union <unnamed> volatile __io _A_TCCR0
_A_TCCR0:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,038H
// union <unnamed> volatile __io _A_PORTB
_A_PORTB:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,032H
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1
//    2 #include <ina90.h>
//    3 #include <string.h>
//    4 #include <pgmspace.h>
//    5 #include <stdio.h>
//    6 #include <stdlib.h>
//    7 #include <ctype.h>
//    8 #include "main.h"
//    9 #include "USART.h"
//   10 #include "Monitor.h"
//   11 #include "wrk_params.h"
//   12 #include "DS1Wire.h"
//   13 #include "ADC.h"
//   14 #include "Timers.h"
//   15 #include "RF_settings.h"
//   16 #include "RF_transmitter.h"
//   17 #include "Util.h"
//   18 
//   19 extern __no_init D1W_device devices[MAX_DEVICES];
//   20 
//   21 #define  MONIT_OFF_TIMEOUT 65535
//   22 #define  LED_BLINK_TIMEOUT 100
//   23 
//   24 #define INBUF_LEN 30

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   25 char strbuf[INBUF_LEN];
strbuf:
        DS8 30
//   26 

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   27 volatile unsigned int monit_off_tim; // Число тиков до выключения монитора
monit_off_tim:
        DS8 2

        RSEG NEAR_Z:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_Z>`
//   28 unsigned char         led_blink_tim;
led_blink_tim:
        DS8 1

        RSEG `CODE`:CODE:NOROOT(1)
crlf:
        CODE
        LDI     R16, 10
        RCALL   USART_Transmit
        LDI     R16, 13
        RJMP    USART_Transmit

        RSEG `CODE`:CODE:NOROOT(1)
exec_cmd:
        CODE
        RCALL   ?PROLOGUE5_L09
        REQUIRE ?Register_R4_is_cg_reg
        LDI     R26, 0
        RJMP    ??exec_cmd_0
??exec_cmd_1:
        INC     R26
??exec_cmd_0:
        LDI     R27, 0
        LDI     R16, LOW(strbuf)
        LDI     R17, (strbuf) >> 8
        ADD     R16, R26
        ADC     R17, R27
        MOVW    R31:R30, R17:R16
        LD      R27, Z
        MOV     R30, R27
        LDI     R31, 0
        SUBI    R30, LOW((-(_Small_Ctype + 1) & 0xFFFF))
        SBCI    R31, HIGH((-(_Small_Ctype + 1) & 0xFFFF))
        LPM     R18, Z
        ANDI    R18, 0x07
        BRNE    ??exec_cmd_1
        MOVW    R31:R30, R17:R16
        LDI     R16, 0
        ST      Z, R16
        INC     R26
        MOV     R4, R26
        LDI     R26, 0
        RJMP    ??exec_cmd_2
??exec_cmd_3:
        INC     R26
??exec_cmd_2:
        LDI     R25, 0
        RCALL   get_params_num
        CP      R26, R16
        CPC     R25, R17
        BRGE    ??exec_cmd_4
        MOV     R16, R26
        RCALL   get_params_name
        MOVW    R19:R18, R17:R16
        LDI     R16, LOW(strbuf)
        LDI     R17, (strbuf) >> 8
        RCALL   strcmp
        OR      R16, R17
        BRNE    ??exec_cmd_3
        CPI     R27, 61
        BRNE    ??exec_cmd_3
        MOV     R16, R4
        RJMP    ??exec_cmd_5
??exec_cmd_6:
        INC     R16
??exec_cmd_5:
        LDI     R31, 0
        MOV     R30, R16
        SUBI    R30, LOW((-(strbuf) & 0xFFFF))
        SBCI    R31, (-(strbuf) & 0xFFFF) >> 8
        LD      R30, Z
        LDI     R31, 0
        SUBI    R30, LOW((-(_Small_Ctype + 1) & 0xFFFF))
        SBCI    R31, HIGH((-(_Small_Ctype + 1) & 0xFFFF))
        LPM     R17, Z
        ANDI    R17, 0x07
        BRNE    ??exec_cmd_6
        MOV     R18, R26
        LDI     R19, 0
        LDI     R16, LOW(strbuf)
        LDI     R17, (strbuf) >> 8
        ADD     R16, R4
        ADC     R17, R19
        RCALL   Str_to_param
        MOV     R18, R26
        LDI     R19, 0
        LDI     R16, LOW(strbuf)
        LDI     R17, (strbuf) >> 8
        RCALL   Param_to_str
        LDI     R16, 61
        RCALL   USART_Transmit
        LDI     R16, LOW(strbuf)
        LDI     R17, (strbuf) >> 8
        RJMP    ??exec_cmd_7
??exec_cmd_4:
        CPI     R27, 63
        BRNE    ??exec_cmd_8
        LDI     R26, 0
??exec_cmd_9:
        RCALL   get_params_num
        CP      R26, R16
        CPC     R25, R17
        BRLT    $+2+2
        RJMP    ??exec_cmd_10
        RCALL   crlf
        MOV     R16, R26
        RCALL   get_params_name
        RCALL   USART_sendstr
        LDI     R16, 61
        RCALL   USART_Transmit
        MOV     R18, R26
        LDI     R19, 0
        LDI     R16, LOW(strbuf)
        LDI     R17, (strbuf) >> 8
        RCALL   Param_to_str
        LDI     R16, LOW(strbuf)
        LDI     R17, (strbuf) >> 8
        RCALL   USART_sendstr
        INC     R26
        RJMP    ??exec_cmd_9
??exec_cmd_8:
        CPI     R27, 43
        BRNE    ??exec_cmd_11
        RCALL   Save_Params_To_EEPROM
        LDI     R16, LOW(`?<Constant "All parameters saved!">`)
        LDI     R17, (`?<Constant "All parameters saved!">`) >> 8
        RJMP    ??exec_cmd_7
??exec_cmd_11:
        CPI     R27, 45
        BRNE    ??exec_cmd_12
        RCALL   Restore_settings_from_eeprom
        LDI     R16, LOW(`?<Constant "Restored from EEPROM!">`)
        LDI     R17, (`?<Constant "Restored from EEPROM!">`) >> 8
        RJMP    ??exec_cmd_7
??exec_cmd_12:
        CPI     R27, 42
        BRNE    ??exec_cmd_13
        RCALL   Restore_default_settings
        LDI     R16, LOW(`?<Constant "Restored defaults!">`)
        LDI     R17, (`?<Constant "Restored defaults!">`) >> 8
??exec_cmd_7:
        RCALL   USART_sendstr
        RJMP    ??exec_cmd_10
??exec_cmd_13:
        CPI     R27, 46
        BRNE    ??exec_cmd_14
        LDI     R16, 0
        RJMP    ??exec_cmd_15
??exec_cmd_14:
        CPI     R27, 35
        BRNE    ??exec_cmd_16
        LDI     R16, 0
        RCALL   get_pack_first_byte
        MOV     R27, R16
        SWAP    R16
        ANDI    R16, 0x0F
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        MOV     R16, R27
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        RJMP    ??exec_cmd_10
??exec_cmd_16:
        CPI     R27, 94
        BRNE    ??exec_cmd_10
        RCALL   ADC_init
        LDI     R16, 0
        RCALL   ADC_get_select_ch
        RCALL   crlf
        LDI     R26, 0
        LDI     R27, 6
??exec_cmd_17:
        MOV     R16, R26
        RCALL   ADC_get_select_ch
        MOVW    R25:R24, R17:R16
        LSR     R17
        LSR     R17
        LSR     R17
        LSR     R17
        MOV     R16, R17
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        MOV     R16, R25
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        LDI     R20, 4
        MOVW    R17:R16, R25:R24
        RCALL   ?US_SHR_L02
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        MOV     R16, R24
        RCALL   hex_to_ascii
        RCALL   USART_Transmit
        RCALL   crlf
        INC     R26
        DEC     R27
        BRNE    ??exec_cmd_17
        RCALL   ADC_switch_off
??exec_cmd_10:
        LDI     R16, 1
??exec_cmd_15:
        LDI     R30, 5
        RJMP    ?EPILOGUE_B5_L09
//   29 
//   30 unsigned char exec_cmd(void);
//   31 
//   32 /*--------------------------------------------------------------------------------------
//   33   Процедура работы через последовательный интерфейс
//   34   --------------------------------------------------------------------------------------*/

        RSEG `CODE`:CODE:NOROOT(1)
//   35 void terminal(void)
terminal:
        CODE
//   36 {
        RCALL   ?PROLOGUE4_L09
//   37   char ch;
//   38   unsigned char k = 0;
        LDI     R24, 0
//   39 
//   40   PORTD |= P_TXD;
        SBI     0x12, 0x01
//   41   // Инициализируем прерывания от таймера 0, для обслуживания всяких временных интервалов	
//   42   // Частоту следования прерываний выбираем (16 000 000/64)/256 = 976,5625 Гц -> 0.001024 мс
//   43   TCCR0  = b00000011; // Предделитель = 64
        LDI     R16, 3
        OUT     0x33, R16
//   44   TIFR  |= b00000001; //
        IN      R16, 0x38
        ORI     R16, 0x01
        OUT     0x38, R16
//   45   TIMSK |= b00000001; // Разрешаем прерывания
        IN      R16, 0x39
        ORI     R16, 0x01
        OUT     0x39, R16
//   46 
//   47   monit_off_tim = 0; // Монтор выключиться спустя приблизительно минуту после последнего принятого символа
        LDI     R30, LOW(monit_off_tim)
        LDI     R31, (monit_off_tim) >> 8
        ST      Z, R24
        STD     Z+1, R24
//   48   led_blink_tim = 0;
        STS     led_blink_tim, R24
//   49 
//   50   do
//   51   {
//   52     if (DataInReceiveBuffer())
??terminal_0:
        RCALL   DataInReceiveBuffer
        TST     R16
        BREQ    ??terminal_1
//   53     {
//   54       unsigned char res;
//   55       monit_off_tim = 0;
        LDI     R30, LOW(monit_off_tim)
        LDI     R31, (monit_off_tim) >> 8
        LDI     R16, 0
        ST      Z, R16
        STD     Z+1, R16
//   56       ch = USART_Receive();
        RCALL   USART_Receive
        MOV     R25, R16
//   57       if (ch=='\r')
        CPI     R16, 13
        BRNE    ??terminal_2
//   58       {
//   59         crlf();
        RCALL   crlf
//   60         USART_Transmit(' ');
        LDI     R16, 32
        RCALL   USART_Transmit
//   61         res = exec_cmd();
        RCALL   exec_cmd
        MOV     R24, R16
//   62         crlf();
        RCALL   crlf
//   63         if (res==0)
        TST     R24
        BRNE    ??terminal_3
//   64         {
//   65           wait_until_tx_complete();
        RCALL   wait_until_tx_complete
//   66           break;
        RJMP    ??terminal_4
//   67         }
//   68         USART_Transmit('>');
??terminal_3:
        LDI     R16, 62
        RCALL   USART_Transmit
//   69         k = 0;
        RJMP    ??terminal_5
//   70       }
//   71       else
//   72       {
//   73         // Отправить эхо
//   74         USART_Transmit(ch);
??terminal_2:
        RCALL   USART_Transmit
//   75         strbuf[k] = ch;
        LDI     R31, 0
        MOV     R30, R24
        SUBI    R30, LOW((-(strbuf) & 0xFFFF))
        SBCI    R31, (-(strbuf) & 0xFFFF) >> 8
        ST      Z, R25
//   76         k++;
//   77         strbuf[k] = 0;
        INC     R24
        LDI     R31, 0
        MOV     R30, R24
        SUBI    R30, LOW((-(strbuf) & 0xFFFF))
        SBCI    R31, (-(strbuf) & 0xFFFF) >> 8
        LDI     R16, 0
        ST      Z, R16
//   78         if (k == (INBUF_LEN-1))
        CPI     R24, 29
        BRNE    ??terminal_1
//   79         {
//   80           USART_sendstr("\n\rIn buf. overflow!\n\r>");
        LDI     R16, LOW(`?<Constant "\\n\\rIn buf. overflow!\\n\\r>">`)
        LDI     R17, (`?<Constant "\\n\\rIn buf. overflow!\\n\\r>">`) >> 8
        RCALL   USART_sendstr
//   81           k = 0;
??terminal_5:
        LDI     R24, 0
//   82         }
//   83       }
//   84     }
//   85 
//   86   }
//   87   while (monit_off_tim < MONIT_OFF_TIMEOUT);
??terminal_1:
        LDI     R30, LOW(monit_off_tim)
        LDI     R31, (monit_off_tim) >> 8
        LD      R26, Z
        LDD     R27, Z+1
        CPI     R26, 255
        SBCI    R27, 255
        BRNE    ??terminal_0
//   88 
//   89 
//   90   // Выход из монитора
//   91   PORTB |= P_LED;     // Гасим светодиод
??terminal_4:
        SBI     0x18, 0x01
//   92   TIMSK &= b11111110; // Запрещаем прерывания от таймера 0
        IN      R16, 0x39
        ANDI    R16, 0xFE
        OUT     0x39, R16
//   93   TCCR0  = 0;
        LDI     R16, 0
        OUT     0x33, R16
//   94 }
        LDI     R30, 4
        RJMP    ?EPILOGUE_B4_L09
        REQUIRE _A_PORTD
        REQUIRE _A_TCCR0
        REQUIRE _A_TIFR
        REQUIRE _A_TIMSK
        REQUIRE _A_PORTB
//   95 	
//   96 
//   97 /*--------------------------------------------------------------------------------------
//   98    Выполнение поступившей команды
//   99   --------------------------------------------------------------------------------------*/
//  100 unsigned char exec_cmd(void)
//  101 {
//  102   unsigned char i,j,k;
//  103   char* cname;
//  104   char ch;
//  105 
//  106   i=0;
//  107 
//  108   while (isalnum(strbuf[i])!=0) i++;
//  109 
//  110   k = i;
//  111   ch = strbuf[k];
//  112   strbuf[k] = 0;  // Обозначим конец строки имени параметра
//  113   k++;
//  114 
//  115   // Искать параметр с заданным именем
//  116   for (i=0;i < get_params_num(); i++)
//  117   {
//  118     cname = get_params_name(i);
//  119     if (strcmp(strbuf, cname)==0)
//  120     {
//  121       // Найден параметр
//  122       if (ch=='=')
//  123       {
//  124         j = k;
//  125         // Обнаружена команда записи, прочитать аргумент
//  126         while (isalnum(strbuf[j])!=0) j++;
//  127         Str_to_param((unsigned char*)&strbuf[k],i);
//  128         Param_to_str((unsigned char*)strbuf,i);
//  129         USART_Transmit('=');
//  130         USART_sendstr(strbuf);
//  131         return 1;
//  132       }
//  133 
//  134     }
//  135   }
//  136   // Если не нашли такой параметр, то проверить не запрос ли это всех параметров
//  137   if (ch=='?')
//  138   {
//  139     for (i=0;i < get_params_num(); i++)
//  140     {
//  141       crlf();
//  142       cname = get_params_name(i);
//  143       USART_sendstr(cname);
//  144       USART_Transmit('=');
//  145       Param_to_str((unsigned char*)strbuf,i);
//  146       USART_sendstr(strbuf);
//  147     }
//  148     return 1;
//  149   }
//  150 
//  151   if (ch=='+')  // Сохраним все параметры в EEPROM
//  152   {
//  153     Save_Params_To_EEPROM();
//  154     USART_sendstr("All parameters saved!");
//  155     return 1;
//  156   }
//  157 
//  158   if (ch=='-')  // Восстановим параметры из EEPROM
//  159   {
//  160     Restore_settings_from_eeprom();
//  161     USART_sendstr("Restored from EEPROM!");
//  162     return 1;
//  163   }
//  164 
//  165   if (ch=='*')  // Восстановим параметры по умолчанию
//  166   {
//  167     Restore_default_settings();
//  168     USART_sendstr("Restored defaults!");
//  169     return 1;
//  170   }
//  171 
//  172   if (ch=='.')  // Выйти из режима терминала
//  173   {
//  174     return 0;
//  175   }
//  176 
//  177   if (ch=='#')  // Показать номер устройства
//  178   {
//  179     ch = (char)get_pack_first_byte(0);
//  180     USART_Transmit(hex_to_ascii(ch>>4));
//  181     USART_Transmit(hex_to_ascii(ch));
//  182     return 1;
//  183   }
//  184 
//  185   if (ch=='^')  // Показать результаты измерения АЦП
//  186   {
//  187     unsigned int res;
//  188     ADC_init();
//  189     ADC_get_select_ch(0); // Проведем одно пустое измерение
//  190     crlf();
//  191     for (i=0;i<6;i++)
//  192     {
//  193       res = ADC_get_select_ch(i);  // Получим результат преобразования в канале
//  194       USART_Transmit(hex_to_ascii(res>>12));
//  195       USART_Transmit(hex_to_ascii(res>>8));
//  196       USART_Transmit(hex_to_ascii(res>>4));
//  197       USART_Transmit(hex_to_ascii(res));
//  198       crlf();
//  199     }
//  200     ADC_switch_off();
//  201     return 1;
//  202   }
//  203 
//  204 /*
//  205   if (ch=='!')
//  206   {
//  207     unsigned int temperature;
//  208     for (i=0;i<MAX_DEVICES;i++)
//  209     {
//  210       if (devices[i].id[0] == DS1820_FAMILY_ID)
//  211       {
//  212         temperature = DS1820_ReadTemperature(devices[i].id);
//  213         sprintf((char*)strbuf,"%f",(float)temperature/2);
//  214         strcat(strbuf,"\n\r");
//  215         USART_sendstr(strbuf);
//  216       }
//  217 
//  218     }
//  219     return 1;
//  220   }
//  221 */
//  222 
//  223 
//  224 
//  225   return 1;
//  226 }
//  227 
//  228 
//  229 
//  230 
//  231 
//  232 
//  233 void crlf(void)
//  234 {
//  235   USART_Transmit('\n');
//  236   USART_Transmit('\r');
//  237 }
//  238 
//  239 	
//  240 	
//  241 #pragma vector=TIMER0_OVF_vect

        RSEG `CODE`:CODE:NOROOT(1)
        CALL_GRAPH_ROOT TIMER0_OVF_vect_interrupt, "interrupt"
//  242 __interrupt void TIMER0_OVF_vect_interrupt( void )
TIMER0_OVF_vect_interrupt:
        CODE
//  243 {
        ST      -Y, R31
        ST      -Y, R30
        ST      -Y, R19
        ST      -Y, R18
        ST      -Y, R17
        ST      -Y, R16
        IN      R19, 0x3F
//  244  __watchdog_reset(); // Не забываем сбрасывать WDT, поскольку в мониторе можем находиться очень долго
        WDR
//  245 
//  246  if (monit_off_tim < 65535) monit_off_tim++;
        LDS     R30, monit_off_tim
        LDS     R31, (monit_off_tim + 1)
        CPI     R30, 255
        SBCI    R31, 255
        BREQ    ??TIMER0_OVF_vect_interrupt_0
        LDI     R30, LOW(monit_off_tim)
        LDI     R31, (monit_off_tim) >> 8
        LD      R16, Z
        LDD     R17, Z+1
        SUBI    R16, 255
        SBCI    R17, 255
        ST      Z, R16
        STD     Z+1, R17
//  247 
//  248  if (led_blink_tim == LED_BLINK_TIMEOUT)
??TIMER0_OVF_vect_interrupt_0:
        LDS     R16, led_blink_tim
        CPI     R16, 100
        BRNE    ??TIMER0_OVF_vect_interrupt_1
//  249  {
//  250  	 led_blink_tim = 0;
        LDI     R16, 0
//  251  	 PORTB ^= P_LED;
        IN      R18, 0x18
        LDI     R17, 2
        EOR     R18, R17
        OUT     0x18, R18
        RJMP    ??TIMER0_OVF_vect_interrupt_2
//  252  }
//  253  else
//  254  {
//  255  	 led_blink_tim++;
??TIMER0_OVF_vect_interrupt_1:
        INC     R16
??TIMER0_OVF_vect_interrupt_2:
        STS     led_blink_tim, R16
//  256  }
//  257 }
        OUT     0x3F, R19
        LD      R16, Y+
        LD      R17, Y+
        LD      R18, Y+
        LD      R19, Y+
        LD      R30, Y+
        LD      R31, Y+
        RETI
        REQUIRE _A_PORTB

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        COMMON INTVEC:CODE:ROOT(1)
        ORG 18
`??TIMER0_OVF_vect_interrupt::??INTVEC 18`:
        CODE
        RJMP    TIMER0_OVF_vect_interrupt

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "\\n\\rIn buf. overf`:
        DC8 "\012\015In buf. overflow!\012\015>"

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_I>`:
        DC16    SFE(NEAR_I) - SFB(NEAR_I)
        DC16    SFB(NEAR_I)
        DC16    SFB(NEAR_ID)
        REQUIRE ?need_segment_init

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "All parameters sa`:
        DC8 "All parameters saved!"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "Restored from EEP`:
        DC8 "Restored from EEPROM!"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "Restored defaults`:
        DC8 "Restored defaults!"

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_Z>`:
        DC16    SFE(NEAR_Z) - SFB(NEAR_Z)
        DC16    SFB(NEAR_Z)
        DC16    0
        REQUIRE ?need_segment_init

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "\\n\\rIn buf. overflow!\\n\\r>">`:
        DS8 23
        REQUIRE `?<Initializer for <Constant "\\n\\rIn buf. overf`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "All parameters saved!">`:
        DS8 22
        REQUIRE `?<Initializer for <Constant "All parameters sa`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "Restored from EEPROM!">`:
        DS8 22
        REQUIRE `?<Initializer for <Constant "Restored from EEP`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "Restored defaults!">`:
        DS8 19
        REQUIRE `?<Initializer for <Constant "Restored defaults`

        END
// 
//   5 bytes in segment ABSOLUTE
// 586 bytes in segment CODE
//  12 bytes in segment INITTAB
//   2 bytes in segment INTVEC
//  86 bytes in segment NEAR_I
//  86 bytes in segment NEAR_ID
//  33 bytes in segment NEAR_Z
// 
// 672 bytes of CODE memory (+ 14 bytes shared)
// 119 bytes of DATA memory (+  5 bytes shared)
//
//Errors: none
//Warnings: none
