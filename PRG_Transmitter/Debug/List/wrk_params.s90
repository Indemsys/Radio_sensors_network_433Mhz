///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR      26/Oct/2021  17:01:08
// Copyright 1996-2021 IAR Systems AB.
//
//    Source file  =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\wrk_params.c
//    Command line =  
//        -f C:\Users\aly\AppData\Local\Temp\EW92E9.tmp
//        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\wrk_params.c
//        --cpu=m8 -ms -o
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\Obj
//        -lCN
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        -lB
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List
//        --initializers_in_flash --no_cross_call --no_clustering --no_tbaa
//        --debug -DENABLE_BIT_DEFINITIONS -e --eeprom_size 512 --clib -Ohz)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\Debug\List\wrk_params.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME wrk_params

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        EXTERN ?CV_SWITCH_L06
        EXTERN ?EPILOGUE_B5_L09
        EXTERN ?EPILOGUE_B6_L09
        EXTERN ?EPILOGUE_B8_L09
        EXTERN ?F2SL_L04
        EXTERN ?F2UL_L04
        EXTERN ?F_CMP_LT_L04
        EXTERN ?ML_EEPROM_SRAM_16_16_L07
        EXTERN ?ML_SRAM_EEPROM_16_16_L07
        EXTERN ?PROLOGUE5_L09
        EXTERN ?PROLOGUE6_L09
        EXTERN ?PROLOGUE8_L09
        EXTERN ?Register_R4_is_cg_reg
        EXTERN ?Register_R5_is_cg_reg
        EXTERN ?Register_R6_is_cg_reg
        EXTERN ?Register_R7_is_cg_reg
        EXTERN ?SS_SHR_L02
        EXTERN ?S_EC_MUL_L02
        EXTERN ?UL_SHR_L03
        EXTERN ?US_SHR_L02
        EXTERN ?need_segment_init
        EXTERN __eeget16_16
        EXTERN __eeput16_16

        PUBWEAK `?<Segment init: NEAR_I>`
        PUBLIC Param_to_str
        PUBLIC Restore_default_settings
        PUBLIC Restore_settings_from_eeprom
        PUBLIC Save_Params_To_EEPROM
        PUBLIC Str_to_param
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC dwvar
        PUBLIC ee_crc
        PUBLIC ee_wp
        PUBLIC get_params_name
        PUBLIC get_params_num
        PUBLIC wp

        EXTERN GetBlockCRC
        EXTERN atof
        EXTERN hex_to_ascii
        EXTERN strtol

// D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Transmitter\wrk_params.c
//    1 #include <iom8.h>
//    2 #include <ina90.h>
//    3 #include <string.h>
//    4 #include <pgmspace.h>
//    5 #include <stdio.h>
//    6 #include <stdlib.h>
//    7 #include "main.h"
//    8 #include "Util.h"
//    9 #include "RF_settings.h"
//   10 #include "wrk_params.h"
//   11 
//   12 /*
//   13   Объявления рабочих параметров
//   14 */
//   15 

        RSEG EEPROM_N:XDATA:NOROOT(0)
//   16 __no_init __eeprom TPARAMS ee_wp;       // Рабочие параметры в EEPROM
ee_wp:
        DS8 17

        RSEG EEPROM_N:XDATA:NOROOT(0)
//   17 __no_init __eeprom unsigned int ee_crc; // Контрольная сумма в EEPROM
ee_crc:
        DS8 2
//   18 

        RSEG NEAR_N:DATA:NOROOT(0)
//   19 __no_init TPARAMS wp;                   // Рабочие параметры в RAM
wp:
        DS8 17
//   20 
//   21 
//   22 

        RSEG NEAR_F:CODE:NOROOT(0)
        DATA
//   23 __flash DWAR_TYPE dwvar[]=
dwvar:
        DC16 `?<Constant "WDTPER">`, ee_wp + 2H, wp + 2H
        DC8 0
        DD 40E00000H, 0H, 40E00000H
        DC8 0, 0
        DC16 0H
        DC8 1
        DC16 `?<Constant "WDTDVC">`, ee_wp + 3H, wp + 3H
        DC8 0
        DD 40000000H, 0H, 437F0000H
        DC8 0, 0
        DC16 0H
        DC8 1
        DC16 `?<Constant "WDTDVV">`, ee_wp + 4H, wp + 4H
        DC8 0
        DD 0H, 0H, 437F0000H
        DC8 0, 0
        DC16 0H
        DC8 1
        DC16 `?<Constant "BTRATE">`, ee_wp + 5H, wp + 5H
        DC8 2
        DD 467A0000H, 457A0000H, 477FFF00H
        DC8 0, 0
        DC16 0H
        DC8 2
        DC16 `?<Constant "SFLAGS">`, ee_wp + 7H, wp + 7H
        DC8 2
        DD 0H, 0H, 477FFF00H
        DC8 0, 0
        DC16 0H
        DC8 2
        DC16 `?<Constant "PREAMB">`, ee_wp + 9H, wp + 9H
        DC8 2
        DD 4759C200H, 0H, 477FFF00H
        DC8 0, 0
        DC16 0H
        DC8 2
        DC16 `?<Constant "REFCOD">`, ee_wp + 0BH, wp + 0BH
        DC8 2
        DD 4479C000H, 0H, 477FFF00H
        DC8 0, 0
        DC16 0H
        DC8 2
        DC16 `?<Constant "KEYCOD">`, ee_wp + 0DH, wp + 0DH
        DC8 4
        DD 4479C000H, 0H, 4F800000H
        DC8 0, 0
        DC16 0H
        DC8 4
//   24 {
//   25   {
//   26     "WDTPER",                // Строковое описание
//   27     &ee_wp.wdt_period,       // Указатель на значение переменной в EEPROM
//   28     &wp.wdt_period,          // Указатель на значение переменной в RAM
//   29     tunsigned_char,          // Идентификатор типа переменной
//   30     7,                       // Значение по умолчанию
//   31     0,                       // Минимальное возможное значение
//   32     7,                       // Максимальное возможное значение
//   33     0,                       // Количество знаков после запятой
//   34     0,                       // Аттрибуты переменной
//   35     0,                       // Указатель на функцию выполняемую после редактирования
//   36     sizeof(unsigned char)    // Длинна переменной
//   37   },
//   38   {
//   39     "WDTDVC",
//   40     &ee_wp.wdt_div_const,
//   41     &wp.wdt_div_const,
//   42     tunsigned_char,
//   43     2,
//   44     0,
//   45     255,
//   46     0,
//   47     0,
//   48     0,
//   49     sizeof(unsigned char)
//   50   },
//   51   {
//   52     "WDTDVV",
//   53     &ee_wp.wdt_div_var,
//   54     &wp.wdt_div_var,
//   55     tunsigned_char,
//   56     0,
//   57     0,
//   58     255,
//   59     0,
//   60     0,
//   61     0,
//   62     sizeof(unsigned char)
//   63   },
//   64   {
//   65     "BTRATE",
//   66     &ee_wp.rf_bitrate,
//   67     &wp.rf_bitrate,
//   68     tunsigned_int,
//   69     16000,
//   70     4000,
//   71     65535,
//   72     0,
//   73     0,
//   74     0,
//   75     sizeof(unsigned int)
//   76   },
//   77   {
//   78     "SFLAGS",
//   79     &ee_wp.flags,
//   80     &wp.flags,
//   81     tunsigned_int,
//   82     0,
//   83     0,
//   84     65535,
//   85     0,
//   86     0,
//   87     0,
//   88     sizeof(unsigned int)
//   89   },
//   90   {
//   91     "PREAMB",
//   92     &ee_wp.preamble,
//   93     &wp.preamble,
//   94     tunsigned_int,
//   95     PREAMBLE,
//   96     0,
//   97     65535,
//   98     0,
//   99     0,
//  100     0,
//  101     sizeof(unsigned int)
//  102   },
//  103   {
//  104     "REFCOD",
//  105     &ee_wp.refcod,
//  106     &wp.refcod,
//  107     tunsigned_int,
//  108     999,
//  109     0,
//  110     65535,
//  111     0,
//  112     0,
//  113     0,
//  114     sizeof(unsigned int)
//  115   },
//  116   {
//  117     "KEYCOD",
//  118     &ee_wp.keycode,
//  119     &wp.keycode,
//  120     tunsigned_long,
//  121     999,
//  122     0,
//  123     0xFFFFFFFF,
//  124     0,
//  125     0,
//  126     0,
//  127     sizeof(unsigned long)
//  128   },
//  129 
//  130 
//  131 
//  132 };
//  133 

        RSEG `CODE`:CODE:NOROOT(1)
//  134 int get_params_num(void)
get_params_num:
        CODE
//  135 {
//  136   return  (sizeof(dwvar)/sizeof(dwvar[0]));
        LDI     R16, 8
        LDI     R17, 0
        RET
//  137 }
//  138 

        RSEG `CODE`:CODE:NOROOT(1)
//  139 char* get_params_name(unsigned char indx)
get_params_name:
        CODE
//  140 {
//  141   return  dwvar[indx].name;
        LDI     R17, 0
        LDI     R20, 24
        LDI     R21, 0
        RCALL   ?S_EC_MUL_L02
        MOVW    R31:R30, R17:R16
        SUBI    R30, LOW((-(dwvar) & 0xFFFF))
        SBCI    R31, (-(dwvar) & 0xFFFF) >> 8
        LPM     R16, Z+
        LPM     R17, Z
        RET
//  142 }
//  143 
//  144 
//  145 /* ==========================================================
//  146    Преобразовать параметр в строку
//  147    ========================================================== */

        RSEG `CODE`:CODE:NOROOT(1)
//  148 void Param_to_str(unsigned char *buf,int indx)
Param_to_str:
        CODE
//  149 {
        RCALL   ?PROLOGUE6_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        MOVW    R27:R26, R17:R16
//  150   switch (dwvar[indx].vartype)
        MOVW    R17:R16, R19:R18
        LDI     R20, 24
        LDI     R21, 0
        RCALL   ?S_EC_MUL_L02
        LDI     R24, LOW(dwvar)
        LDI     R25, (dwvar) >> 8
        ADD     R24, R16
        ADC     R25, R17
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 6
        LPM     R16, Z
        TST     R16
        BREQ    ??Param_to_str_0
        DEC     R16
        BREQ    ??Param_to_str_0
        DEC     R16
        BREQ    ??Param_to_str_1
        DEC     R16
        BREQ    ??Param_to_str_1
        DEC     R16
        BREQ    ??Param_to_str_2
        DEC     R16
        BREQ    ??Param_to_str_2
        RJMP    ??Param_to_str_3
//  151   {
//  152   case tunsigned_char:
//  153   case tsigned_char:
//  154     *buf++='0';
??Param_to_str_0:
        LDI     R16, 48
        ST      X, R16
//  155     *buf++='x';
        MOVW    R31:R30, R27:R26
        LDI     R16, 120
        STD     Z+1, R16
//  156     *buf++=hex_to_ascii(*(char*)dwvar[indx].val>>4);
        ADIW    R27:R26, 2
        MOVW    R5:R4, R27:R26
        ADIW    R27:R26, 1
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LD      R16, Z
        SWAP    R16
        ANDI    R16, 0x0F
        RCALL   hex_to_ascii
        MOVW    R31:R30, R5:R4
        ST      Z, R16
//  157     *buf++=hex_to_ascii(*(char*)dwvar[indx].val);
        RJMP    ??Param_to_str_4
//  158     *buf++=0;
//  159 //    sprintf((char*)buf,"%d",*((unsigned char*)dwvar[indx].val));
//  160     break;
//  161 //    sprintf((char*)buf,"%d",*((signed char*)dwvar[indx].val));
//  162 //    break;
//  163   case tunsigned_int:
//  164   case tsigned_int:
//  165 //    sprintf((char*)buf,"%d",*((unsigned int*)dwvar[indx].val));
//  166     *buf++='0';
??Param_to_str_1:
        LDI     R16, 48
        ST      X, R16
//  167     *buf++='x';
        MOVW    R31:R30, R27:R26
        LDI     R16, 120
        STD     Z+1, R16
//  168     *buf++=hex_to_ascii(*(int*)dwvar[indx].val>>12);
        ADIW    R27:R26, 2
        MOVW    R5:R4, R27:R26
        ADIW    R27:R26, 1
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LDD     R16, Z+1
        ASR     R16
        ASR     R16
        ASR     R16
        ASR     R16
        RCALL   hex_to_ascii
        MOVW    R31:R30, R5:R4
        ST      Z, R16
//  169     *buf++=hex_to_ascii(*(int*)dwvar[indx].val>>8);
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LDD     R16, Z+1
        RCALL   hex_to_ascii
        ST      X+, R16
//  170     *buf++=hex_to_ascii(*(int*)dwvar[indx].val>>4);
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LD      R16, Z
        LDD     R17, Z+1
        LDI     R20, 4
        RCALL   ?SS_SHR_L02
        RJMP    ??Param_to_str_5
//  171     *buf++=hex_to_ascii(*(int*)dwvar[indx].val);
//  172     *buf++=0;
//  173 
//  174     break;
//  175   case tunsigned_long:
//  176   case tsigned_long:
//  177     *buf++='0';
??Param_to_str_2:
        LDI     R16, 48
        ST      X, R16
//  178     *buf++='x';
        MOVW    R31:R30, R27:R26
        LDI     R16, 120
        STD     Z+1, R16
//  179     *buf++=hex_to_ascii(*(unsigned long*)dwvar[indx].val>>28);
        ADIW    R27:R26, 2
        MOVW    R5:R4, R27:R26
        ADIW    R27:R26, 1
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LDD     R16, Z+3
        LSR     R16
        LSR     R16
        LSR     R16
        LSR     R16
        RCALL   hex_to_ascii
        MOVW    R31:R30, R5:R4
        ST      Z, R16
//  180     *buf++=hex_to_ascii(*(unsigned long*)dwvar[indx].val>>24);
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LDD     R16, Z+3
        RCALL   hex_to_ascii
        ST      X+, R16
//  181     *buf++=hex_to_ascii(*(unsigned long*)dwvar[indx].val>>20);
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        LDI     R20, 20
        RCALL   ?UL_SHR_L03
        RCALL   hex_to_ascii
        ST      X+, R16
//  182     *buf++=hex_to_ascii(*(unsigned long*)dwvar[indx].val>>16);
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LDD     R16, Z+2
        RCALL   hex_to_ascii
        ST      X+, R16
//  183     *buf++=hex_to_ascii(*(unsigned long*)dwvar[indx].val>>12);
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LD      R16, Z
        LDD     R17, Z+1
        LDD     R18, Z+2
        LDD     R19, Z+3
        LDI     R20, 12
        RCALL   ?UL_SHR_L03
        RCALL   hex_to_ascii
        ST      X+, R16
//  184     *buf++=hex_to_ascii(*(unsigned long*)dwvar[indx].val>>8);
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LDD     R16, Z+1
        RCALL   hex_to_ascii
        ST      X+, R16
//  185     *buf++=hex_to_ascii(*(unsigned long*)dwvar[indx].val>>4);
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LD      R16, Z
        LDD     R17, Z+1
        LDI     R20, 4
        RCALL   ?US_SHR_L02
??Param_to_str_5:
        RCALL   hex_to_ascii
        ST      X+, R16
//  186     *buf++=hex_to_ascii(*(unsigned long*)dwvar[indx].val);
??Param_to_str_4:
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        LD      R16, Z
        RCALL   hex_to_ascii
        ST      X+, R16
//  187     *buf++=0;
        LDI     R16, 0
        ST      X, R16
//  188     break;
//  189   case tfloat:
//  190 //    sprintf((char*)buf,"%f",*((float*)dwvar[indx].val));
//  191     break;
//  192   case tdouble:
//  193 //    sprintf((char*)buf,"%f",*((double*)dwvar[indx].val));
//  194     break;
//  195   case tstring:
//  196 //    sprintf((char*)buf,"%s",(char*)(dwvar[indx].val));
//  197     break;
//  198   }
//  199 }
??Param_to_str_3:
        LDI     R30, 6
        RJMP    ?EPILOGUE_B6_L09
//  200 
//  201 /* ==========================================================
//  202    Преобразовать строку в параметр
//  203    ========================================================== */

        RSEG `CODE`:CODE:NOROOT(1)
//  204 void Str_to_param(unsigned char *buf,int indx)
Str_to_param:
        CODE
//  205 {
        RCALL   ?PROLOGUE8_L09
        REQUIRE ?Register_R4_is_cg_reg
        REQUIRE ?Register_R5_is_cg_reg
        REQUIRE ?Register_R6_is_cg_reg
        REQUIRE ?Register_R7_is_cg_reg
        MOVW    R25:R24, R17:R16
//  206   unsigned char uch_tmp;
//  207   signed char sch_tmp;
//  208   unsigned int uin_tmp;
//  209   signed int sin_tmp;
//  210   unsigned long ulg_tmp;
//  211   signed long slg_tmp;
//  212   float f_tmp;
//  213   double d_tmp;
//  214   switch (dwvar[indx].vartype)
        MOVW    R17:R16, R19:R18
        LDI     R20, 24
        LDI     R21, 0
        RCALL   ?S_EC_MUL_L02
        LDI     R26, LOW(dwvar)
        LDI     R27, (dwvar) >> 8
        ADD     R26, R16
        ADC     R27, R17
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 6
        LPM     R16, Z
        LDI     R30, LOW(`?<Jumptable for Str_to_param>_0`)
        LDI     R31, (`?<Jumptable for Str_to_param>_0`) >> 8
        RJMP    ?CV_SWITCH_L06
//  215   {
//  216   case tunsigned_char:
//  217     uch_tmp=strtol((char*)buf,0,0);
??Str_to_param_0:
        LDI     R20, 0
        LDI     R21, 0
        LDI     R18, 0
        LDI     R19, 0
        MOVW    R17:R16, R25:R24
        RCALL   strtol
        MOV     R21, R16
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 15
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R16, R21
        BRCC    ??Str_to_param_1
//  218     if (uch_tmp>((unsigned char)dwvar[indx].max)) uch_tmp=(unsigned char)dwvar[indx].max;
        MOV     R21, R16
??Str_to_param_1:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 11
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R21, R16
        BRCC    ??Str_to_param_2
//  219     if (uch_tmp<((unsigned char)dwvar[indx].min)) uch_tmp=(unsigned char)dwvar[indx].min;
        RJMP    ??Str_to_param_3
//  220     *(unsigned char*)dwvar[indx].val=uch_tmp;
//  221     break;
//  222   case tsigned_char:
//  223     sch_tmp=strtol((char*)buf,0,0);
??Str_to_param_4:
        LDI     R20, 0
        LDI     R21, 0
        LDI     R18, 0
        LDI     R19, 0
        MOVW    R17:R16, R25:R24
        RCALL   strtol
        MOV     R21, R16
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 15
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R16, R21
        BRGE    ??Str_to_param_5
//  224     if (sch_tmp>((signed char)dwvar[indx].max)) sch_tmp=(signed char)dwvar[indx].max;
        MOV     R21, R16
??Str_to_param_5:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 11
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R21, R16
        BRGE    ??Str_to_param_2
//  225     if (sch_tmp<((signed char)dwvar[indx].min)) sch_tmp=(signed char)dwvar[indx].min;
??Str_to_param_3:
        MOV     R21, R16
//  226     *(signed char*)dwvar[indx].val=sch_tmp;
??Str_to_param_2:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 4
        LPM     R26, Z+
        LPM     R27, Z
        ST      X, R21
//  227     break;
        RJMP    ??Str_to_param_6
//  228   case tunsigned_int:
//  229     uin_tmp=strtol((char*)buf,0,0);
??Str_to_param_7:
        LDI     R20, 0
        LDI     R21, 0
        LDI     R18, 0
        LDI     R19, 0
        MOVW    R17:R16, R25:R24
        RCALL   strtol
        MOVW    R23:R22, R17:R16
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 15
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R16, R22
        CPC     R17, R23
        BRCC    ??Str_to_param_8
//  230     if (uin_tmp>((unsigned int)dwvar[indx].max)) uin_tmp=(unsigned int)dwvar[indx].max;
        MOVW    R23:R22, R17:R16
??Str_to_param_8:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 11
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R22, R16
        CPC     R23, R17
        BRCC    ??Str_to_param_9
//  231     if (uin_tmp<((unsigned int)dwvar[indx].min)) uin_tmp=(unsigned int)dwvar[indx].min;
        RJMP    ??Str_to_param_10
//  232     *(unsigned int*)dwvar[indx].val=uin_tmp;
//  233     break;
//  234   case tsigned_int:
//  235     sin_tmp=strtol((char*)buf,0,0);
??Str_to_param_11:
        LDI     R20, 0
        LDI     R21, 0
        LDI     R18, 0
        LDI     R19, 0
        MOVW    R17:R16, R25:R24
        RCALL   strtol
        MOVW    R23:R22, R17:R16
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 15
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R16, R22
        CPC     R17, R23
        BRGE    ??Str_to_param_12
//  236     if (sin_tmp>((signed int)dwvar[indx].max)) sin_tmp=(signed int)dwvar[indx].max;
        MOVW    R23:R22, R17:R16
??Str_to_param_12:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 11
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R22, R16
        CPC     R23, R17
        BRGE    ??Str_to_param_9
//  237     if (sin_tmp<((signed int)dwvar[indx].min)) sin_tmp=(signed int)dwvar[indx].min;
??Str_to_param_10:
        MOVW    R23:R22, R17:R16
//  238     *(signed int*)dwvar[indx].val=sin_tmp;
??Str_to_param_9:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        ST      Z, R22
        STD     Z+1, R23
//  239     break;
        RJMP    ??Str_to_param_6
//  240   case tunsigned_long:
//  241     ulg_tmp=strtol((char*)buf,0,0);
??Str_to_param_13:
        LDI     R20, 0
        LDI     R21, 0
        LDI     R18, 0
        LDI     R19, 0
        MOVW    R17:R16, R25:R24
        RCALL   strtol
        MOVW    R5:R4, R17:R16
        MOVW    R7:R6, R19:R18
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 15
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2UL_L04
        CP      R16, R4
        CPC     R17, R5
        CPC     R18, R6
        CPC     R19, R7
        BRCC    ??Str_to_param_14
//  242     if (ulg_tmp>((unsigned long)dwvar[indx].max)) ulg_tmp=(unsigned long)dwvar[indx].max;
        MOVW    R5:R4, R17:R16
        MOVW    R7:R6, R19:R18
??Str_to_param_14:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 11
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2UL_L04
        CP      R4, R16
        CPC     R5, R17
        CPC     R6, R18
        CPC     R7, R19
        BRCC    ??Str_to_param_15
//  243     if (ulg_tmp<((unsigned long)dwvar[indx].min)) ulg_tmp=(unsigned long)dwvar[indx].min;
        RJMP    ??Str_to_param_16
//  244     *(unsigned long*)dwvar[indx].val=ulg_tmp;
//  245     break;
//  246   case tsigned_long:
//  247     slg_tmp=strtol((char*)buf,0,0);
??Str_to_param_17:
        LDI     R20, 0
        LDI     R21, 0
        LDI     R18, 0
        LDI     R19, 0
        MOVW    R17:R16, R25:R24
        RCALL   strtol
        MOVW    R5:R4, R17:R16
        MOVW    R7:R6, R19:R18
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 15
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R16, R4
        CPC     R17, R5
        CPC     R18, R6
        CPC     R19, R7
        BRGE    ??Str_to_param_18
//  248     if (slg_tmp>((signed long)dwvar[indx].max)) slg_tmp=(signed long)dwvar[indx].max;
        MOVW    R5:R4, R17:R16
        MOVW    R7:R6, R19:R18
??Str_to_param_18:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 11
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        CP      R4, R16
        CPC     R5, R17
        CPC     R6, R18
        CPC     R7, R19
        BRGE    ??Str_to_param_15
//  249     if (slg_tmp<((signed long)dwvar[indx].min)) slg_tmp=(signed long)dwvar[indx].min;
??Str_to_param_16:
        MOVW    R5:R4, R17:R16
        MOVW    R7:R6, R19:R18
//  250     *(signed long*)dwvar[indx].val=slg_tmp;
??Str_to_param_15:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        ST      Z, R4
        STD     Z+1, R5
        STD     Z+2, R6
        STD     Z+3, R7
//  251     break;
        RJMP    ??Str_to_param_6
//  252   case tfloat:
//  253     f_tmp=atof((char*)buf);
??Str_to_param_19:
        MOVW    R17:R16, R25:R24
        RCALL   atof
        MOVW    R1:R0, R17:R16
        MOVW    R3:R2, R19:R18
//  254     if (f_tmp>((float)dwvar[indx].max)) f_tmp=(float)dwvar[indx].max;
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 15
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        MOVW    R21:R20, R1:R0
        MOVW    R23:R22, R3:R2
        RCALL   ?F_CMP_LT_L04
        BRCC    ??Str_to_param_20
        MOVW    R1:R0, R17:R16
        MOVW    R3:R2, R19:R18
//  255     if (f_tmp<((float)dwvar[indx].min)) f_tmp=(float)dwvar[indx].min;
??Str_to_param_20:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 11
        LPM     R20, Z+
        LPM     R21, Z+
        LPM     R22, Z+
        LPM     R23, Z
        MOVW    R17:R16, R1:R0
        MOVW    R19:R18, R3:R2
        RCALL   ?F_CMP_LT_L04
        BRCC    ??Str_to_param_21
        MOVW    R1:R0, R21:R20
        MOVW    R3:R2, R23:R22
//  256     *(float*)dwvar[indx].val=f_tmp;
??Str_to_param_21:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 4
        LPM     R26, Z+
        LPM     R27, Z
        ST      X+, R0
        ST      X+, R1
        ST      X+, R2
        ST      X, R3
//  257     break;
        RJMP    ??Str_to_param_6
//  258   case tdouble:
//  259     d_tmp=atof((char*)buf);
??Str_to_param_22:
        MOVW    R17:R16, R25:R24
        RCALL   atof
        MOVW    R1:R0, R17:R16
        MOVW    R3:R2, R19:R18
//  260     if (d_tmp>((double)dwvar[indx].max)) d_tmp=(double)dwvar[indx].max;
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 15
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        MOVW    R21:R20, R1:R0
        MOVW    R23:R22, R3:R2
        RCALL   ?F_CMP_LT_L04
        BRCC    ??Str_to_param_23
        MOVW    R1:R0, R17:R16
        MOVW    R3:R2, R19:R18
//  261     if (d_tmp<((double)dwvar[indx].min)) d_tmp=(double)dwvar[indx].min;
??Str_to_param_23:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 11
        LPM     R20, Z+
        LPM     R21, Z+
        LPM     R22, Z+
        LPM     R23, Z
        MOVW    R17:R16, R1:R0
        MOVW    R19:R18, R3:R2
        RCALL   ?F_CMP_LT_L04
        BRCC    ??Str_to_param_24
        MOVW    R1:R0, R21:R20
        MOVW    R3:R2, R23:R22
//  262     *(double*)dwvar[indx].val=d_tmp;
??Str_to_param_24:
        MOVW    R31:R30, R27:R26
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        ST      Z, R0
        STD     Z+1, R1
        STD     Z+2, R2
        STD     Z+3, R3
//  263     break;
//  264   }
//  265 }
??Str_to_param_6:
        LDI     R30, 8
        RJMP    ?EPILOGUE_B8_L09

        RSEG `CODE`:CODE:NOROOT(1)
Save_Params_To_EEPROM:
        CODE
        LDI     R30, LOW(wp)
        LDI     R31, (wp) >> 8
        LDI     R16, 106
        LDI     R17, 0
        ST      Z, R16
        STD     Z+1, R17
        LDI     R20, LOW(ee_wp)
        LDI     R21, (ee_wp) >> 8
        LDI     R17, 17
        LDI     R18, 0
        RCALL   ?ML_SRAM_EEPROM_16_16_L07
        LDI     R20, 17
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        LDI     R16, LOW(wp)
        LDI     R17, (wp) >> 8
        RCALL   GetBlockCRC
        LDI     R20, LOW(ee_crc)
        LDI     R21, (ee_crc) >> 8
        RJMP    __eeput16_16
//  266 
//  267 // ==========================================================
//  268 //  Перезаписать в EEPROM установки по умолчанию. Если нет ошибки то возвращает 0
//  269 // ==========================================================

        RSEG `CODE`:CODE:NOROOT(1)
//  270 void Restore_default_settings(void)
Restore_default_settings:
        CODE
//  271 {
        RCALL   ?PROLOGUE5_L09
        REQUIRE ?Register_R4_is_cg_reg
//  272   unsigned int i;
//  273 
//  274   // Загрузить параметры значениями по умолчанию
//  275   for (i=0;i<get_params_num();i++)
        LDI     R26, 0
        LDI     R27, 0
        LDI     R16, 8
        MOV     R4, R16
//  276   {
//  277     switch (dwvar[i].vartype)
??Restore_default_settings_0:
        MOVW    R17:R16, R27:R26
        LDI     R20, 24
        LDI     R21, 0
        RCALL   ?S_EC_MUL_L02
        LDI     R24, LOW(dwvar)
        LDI     R25, (dwvar) >> 8
        ADD     R24, R16
        ADC     R25, R17
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 6
        LPM     R16, Z
        LDI     R30, LOW(`?<Jumptable for Restore_default_settings>_0`)
        LDI     R31, (`?<Jumptable for Restore_default_settings>_0`) >> 8
        RJMP    ?CV_SWITCH_L06
//  278     {
//  279     case tunsigned_char:
//  280       *(unsigned char*)dwvar[i].val=(unsigned char)dwvar[i].defval; break;
//  281     case tsigned_char:
//  282       *(signed char*)dwvar[i].val=(signed char)dwvar[i].defval; break;
??Restore_default_settings_1:
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 7
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        MOV     R18, R16
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        ST      Z, R18
        RJMP    ??Restore_default_settings_2
//  283     case tunsigned_int:
//  284       *(unsigned int*)dwvar[i].val=(unsigned int)dwvar[i].defval; break;
//  285     case tsigned_int:
//  286       *(signed int*)dwvar[i].val=(signed int)dwvar[i].defval; break;
??Restore_default_settings_3:
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 7
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
        MOV     R18, R16
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        ST      Z, R18
        STD     Z+1, R17
        RJMP    ??Restore_default_settings_2
//  287     case tunsigned_long:
//  288       *(unsigned long*)dwvar[i].val=(unsigned long)dwvar[i].defval; break;
??Restore_default_settings_4:
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 7
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2UL_L04
        RJMP    ??Restore_default_settings_5
//  289     case tsigned_long:
//  290       *(signed long*)dwvar[i].val=(signed long)dwvar[i].defval; break;
??Restore_default_settings_6:
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 7
        LPM     R16, Z+
        LPM     R17, Z+
        LPM     R18, Z+
        LPM     R19, Z
        RCALL   ?F2SL_L04
??Restore_default_settings_5:
        MOV     R20, R16
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        ST      Z, R20
        STD     Z+1, R17
        STD     Z+2, R18
        STD     Z+3, R19
        RJMP    ??Restore_default_settings_2
//  291     case tfloat:
//  292       *(float*)dwvar[i].val=dwvar[i].defval; break;
//  293     case tdouble:
//  294       *(double*)dwvar[i].val=dwvar[i].defval; break;
??Restore_default_settings_7:
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 7
        LPM     R20, Z+
        LPM     R21, Z+
        LPM     R22, Z+
        LPM     R23, Z
        MOVW    R31:R30, R25:R24
        ADIW    R31:R30, 4
        LPM     R16, Z+
        LPM     R31, Z
        MOV     R30, R16
        ST      Z, R20
        STD     Z+1, R21
        STD     Z+2, R22
        STD     Z+3, R23
//  295     }
//  296   }
??Restore_default_settings_2:
        ADIW    R27:R26, 1
        DEC     R4
        BREQ    $+2+2
        RJMP    ??Restore_default_settings_0
//  297 
//  298   // Выполнение инициализационных функций параметров
//  299   for (i=0;i<get_params_num();i++)
        LDI     R26, 0
        LDI     R27, 0
        LDI     R24, 8
??Restore_default_settings_8:
        MOVW    R17:R16, R27:R26
        LDI     R20, 24
        LDI     R21, 0
        RCALL   ?S_EC_MUL_L02
        LDI     R30, LOW(dwvar)
        LDI     R31, (dwvar) >> 8
        ADD     R30, R16
        ADC     R31, R17
        ADIW    R31:R30, 21
        LPM     R18, Z+
        LPM     R19, Z
        CPI     R18, 0
        CPC     R19, R21
        BREQ    ??Restore_default_settings_9
//  300   {
//  301     if (dwvar[i].func!=0) dwvar[i].func();
        MOVW    R31:R30, R19:R18
        ICALL
//  302   }
??Restore_default_settings_9:
        ADIW    R27:R26, 1
        DEC     R24
        BRNE    ??Restore_default_settings_8
//  303 
//  304   Save_Params_To_EEPROM();
        RCALL   Save_Params_To_EEPROM
//  305 }
        LDI     R30, 5
        RJMP    ?EPILOGUE_B5_L09
//  306 // ==========================================================
//  307 //  Сохранить всю область рабочих параметров в EEPROM
//  308 // ==========================================================
//  309 void Save_Params_To_EEPROM(void)
//  310 {
//  311   wp.version = PRG_VERSION;
//  312   ee_wp      = wp;
//  313   ee_crc     = GetBlockCRC((unsigned char*)&wp,sizeof(wp));
//  314 
//  315 }
//  316 
//  317 
//  318 // ==========================================================
//  319 //  Восстановить область рабочих параметров из EEPROM
//  320 // ==========================================================

        RSEG `CODE`:CODE:NOROOT(1)
//  321 unsigned char Restore_settings_from_eeprom(void)
Restore_settings_from_eeprom:
        CODE
//  322 {
//  323   wp = ee_wp;
        LDI     R30, LOW(wp)
        LDI     R31, (wp) >> 8
        LDI     R20, LOW(ee_wp)
        LDI     R21, (ee_wp) >> 8
        LDI     R17, 17
        LDI     R18, 0
        RCALL   ?ML_EEPROM_SRAM_16_16_L07
//  324   if (ee_crc != GetBlockCRC((unsigned char*)&wp,sizeof(wp)))
        LDI     R20, 17
        LDI     R21, 0
        LDI     R22, 0
        LDI     R23, 0
        LDI     R16, LOW(wp)
        LDI     R17, (wp) >> 8
        RCALL   GetBlockCRC
        MOVW    R19:R18, R17:R16
        LDI     R20, LOW(ee_crc)
        LDI     R21, (ee_crc) >> 8
        RCALL   __eeget16_16
        CP      R16, R18
        CPC     R17, R19
        BREQ    ??Restore_settings_from_eeprom_0
//  325     return 0;
        LDI     R16, 0
        RET
//  326   else
//  327     return 1;
??Restore_settings_from_eeprom_0:
        LDI     R16, 1
        RET
//  328 }

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "WDTPER">>`:
        DC8 "WDTPER"

        RSEG INITTAB:CODE:NOROOT(0)
        DATA
`?<Segment init: NEAR_I>`:
        DC16    SFE(NEAR_I) - SFB(NEAR_I)
        DC16    SFB(NEAR_I)
        DC16    SFB(NEAR_ID)
        REQUIRE ?need_segment_init

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "WDTDVC">>`:
        DC8 "WDTDVC"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "WDTDVV">>`:
        DC8 "WDTDVV"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "BTRATE">>`:
        DC8 "BTRATE"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "SFLAGS">>`:
        DC8 "SFLAGS"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "PREAMB">>`:
        DC8 "PREAMB"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "REFCOD">>`:
        DC8 "REFCOD"

        RSEG NEAR_ID:CODE:NOROOT(0)
        DATA
`?<Initializer for <Constant "KEYCOD">>`:
        DC8 "KEYCOD"

        RSEG SWITCH:CODE:NOROOT(1)
`?<Jumptable for Str_to_param>_0`:
        DATA
        DB      0
        DB      0
        DW      (??Str_to_param_6) /2
        DW      8
        DW      (??Str_to_param_0) /2
        DW      (??Str_to_param_4) /2
        DW      (??Str_to_param_7) /2
        DW      (??Str_to_param_11) /2
        DW      (??Str_to_param_13) /2
        DW      (??Str_to_param_17) /2
        DW      (??Str_to_param_19) /2
        DW      (??Str_to_param_22) /2

        RSEG SWITCH:CODE:NOROOT(1)
`?<Jumptable for Restore_default_settings>_0`:
        DATA
        DB      0
        DB      0
        DW      (??Restore_default_settings_2) /2
        DW      8
        DW      (??Restore_default_settings_1) /2
        DW      (??Restore_default_settings_1) /2
        DW      (??Restore_default_settings_3) /2
        DW      (??Restore_default_settings_3) /2
        DW      (??Restore_default_settings_4) /2
        DW      (??Restore_default_settings_6) /2
        DW      (??Restore_default_settings_7) /2
        DW      (??Restore_default_settings_7) /2

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "WDTPER">`:
        DS8 7
        REQUIRE `?<Initializer for <Constant "WDTPER">>`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "WDTDVC">`:
        DS8 7
        REQUIRE `?<Initializer for <Constant "WDTDVC">>`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "WDTDVV">`:
        DS8 7
        REQUIRE `?<Initializer for <Constant "WDTDVV">>`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "BTRATE">`:
        DS8 7
        REQUIRE `?<Initializer for <Constant "BTRATE">>`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "SFLAGS">`:
        DS8 7
        REQUIRE `?<Initializer for <Constant "SFLAGS">>`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "PREAMB">`:
        DS8 7
        REQUIRE `?<Initializer for <Constant "PREAMB">>`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "REFCOD">`:
        DS8 7
        REQUIRE `?<Initializer for <Constant "REFCOD">>`

        RSEG NEAR_I:DATA:NOROOT(0)
        REQUIRE `?<Segment init: NEAR_I>`
`?<Constant "KEYCOD">`:
        DS8 7
        REQUIRE `?<Initializer for <Constant "KEYCOD">>`

        END
//  329 
// 
// 1 314 bytes in segment CODE
//    19 bytes in segment EEPROM_N
//     6 bytes in segment INITTAB
//   192 bytes in segment NEAR_F
//    56 bytes in segment NEAR_I
//    56 bytes in segment NEAR_ID
//    17 bytes in segment NEAR_N
//    44 bytes in segment SWITCH
// 
// 1 606 bytes of CODE  memory (+ 6 bytes shared)
//    73 bytes of DATA  memory
//    19 bytes of XDATA memory
//
//Errors: none
//Warnings: none
