///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR      26/Oct/2021  16:53:18
// Copyright 1996-2021 IAR Systems AB.
//
//    Source file  =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\lcd.c
//    Command line =  
//        -f C:\Users\aly\AppData\Local\Temp\EW686B.tmp
//        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\lcd.c
//        --cpu=m8 -ms -o
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\Obj
//        -lCN
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List
//        -lB
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List
//        --initializers_in_flash --debug -DENABLE_BIT_DEFINITIONS -e
//        --eeprom_size 512 --clib -Ohz)
//    Locale       =  Russian_RUS.1251
//    List file    =  
//        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List\lcd.s90
//
///////////////////////////////////////////////////////////////////////////////

        NAME lcd

        RSEG CSTACK:DATA:NOROOT(0)
        RSEG RSTACK:DATA:NOROOT(0)

        PUBWEAK _A_DDRC
        PUBWEAK _A_DDRD
        PUBWEAK _A_PIND
        PUBWEAK _A_PORTC
        PUBWEAK _A_PORTD
        PUBWEAK __?EEARH
        PUBWEAK __?EEARL
        PUBWEAK __?EECR
        PUBWEAK __?EEDR
        PUBLIC lcdBusyWait
        PUBLIC lcdClear
        PUBLIC lcdControlRead
        PUBLIC lcdControlWrite
        PUBLIC lcdDataRead
        PUBLIC lcdDataWrite
        PUBLIC lcdGotoXY
        PUBLIC lcdHome
        PUBLIC lcdInit
        PUBLIC lcdInitHW
        PUBLIC lcdPrintData
        PUBLIC lcdPrintData_P

// D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\lcd.c
//    1 #include <iom8.h>

        ASEGN ABSOLUTE:DATA:NOROOT,035H
// union <unnamed> volatile __io _A_PORTC
_A_PORTC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,034H
// union <unnamed> volatile __io _A_DDRC
_A_DDRC:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,032H
// union <unnamed> volatile __io _A_PORTD
_A_PORTD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,031H
// union <unnamed> volatile __io _A_DDRD
_A_DDRD:
        DS8 1

        ASEGN ABSOLUTE:DATA:NOROOT,030H
// union <unnamed> volatile __io _A_PIND
_A_PIND:
        DS8 1
//    2 #include <ina90.h>
//    3 #include <string.h>
//    4 #include <pgmspace.h>
//    5 #include <stdio.h>
//    6 #include "main.h"
//    7 #include "USART.h"
//    8 #include "Monitor.h"
//    9 #include "Wrk_params.h"
//   10 #include "Timers.h"
//   11 #include "..\PRG_Transmitter\RF_settings.h"
//   12 #include "RF_receiver.h"
//   13 #include "Util.h"
//   14 #include "bin_defines.h"
//   15 #include "lcd.h"
//   16 
//   17 #define LCD_CTRL_PORT PORTC
//   18 #define LCD_CTRL_DDR  DDRC
//   19 
//   20 #define LCD_DATA_POUT PORTD
//   21 #define LCD_DATA_DDR  DDRD
//   22 #define LCD_DATA_PIN  PIND
//   23 
//   24 #define LCD_CTRL_RS   P_RS
//   25 #define LCD_CTRL_RW   P_RW
//   26 #define LCD_CTRL_E    P_E
//   27 
//   28 #define sbi(ADDRESS,BIT)   ((ADDRESS) |= (BIT))
//   29 #define cbi(ADDRESS,BIT)   ((ADDRESS) &= ~(BIT))
//   30 #define outb(ADDRESS,BYTE) ((ADDRESS) = BYTE)
//   31 #define inb(ADDRESS)        (ADDRESS)
//   32 
//   33 
//   34 #define LCD_LINE0_DDRAMADDR 0
//   35 #define LCD_LINE1_DDRAMADDR 40
//   36 #define LCD_LINE2_DDRAMADDR 0
//   37 #define LCD_LINE3_DDRAMADDR 40
//   38 
//   39 #define LCD_DELAY   asm ("nop"); asm ("nop")
//   40 

        RSEG `CODE`:CODE:NOROOT(1)
//   41 void lcdInitHW(void)
lcdInitHW:
        CODE
//   42 {
//   43   // initialize I/O ports
//   44   // if I/O interface is in use
//   45   // initialize LCD control lines
//   46   cbi(LCD_CTRL_PORT, LCD_CTRL_RS);
        CBI     0x15, 0x00
//   47   cbi(LCD_CTRL_PORT, LCD_CTRL_RW);
        CBI     0x15, 0x01
//   48   cbi(LCD_CTRL_PORT, LCD_CTRL_E);
        CBI     0x15, 0x02
//   49   // initialize LCD control lines to output
//   50   sbi(LCD_CTRL_DDR, LCD_CTRL_RS);
        SBI     0x14, 0x00
//   51   sbi(LCD_CTRL_DDR, LCD_CTRL_RW);
        SBI     0x14, 0x01
//   52   sbi(LCD_CTRL_DDR, LCD_CTRL_E);
        SBI     0x14, 0x02
//   53   // initialize LCD data port to input
//   54   // initialize LCD data lines to pull-up
//   55   outb(LCD_DATA_DDR,  inb(LCD_DATA_DDR) & 0x0F);   // set data I/O lines to input (4bit)
        RJMP    ??Subroutine5_0
        REQUIRE _A_PORTC
        REQUIRE _A_DDRC
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
//   56   outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)| 0xF0);   // set pull-ups to on (4bit)
//   57 }
//   58 

        RSEG `CODE`:CODE:NOROOT(1)
//   59 void lcdBusyWait(void)
lcdBusyWait:
        CODE
//   60 {
//   61   // wait until LCD busy bit goes to zero
//   62   // do a read from control register
//   63   cbi(LCD_CTRL_PORT, LCD_CTRL_RS);        // set RS to "control"
        CBI     0x15, 0x00
//   64   outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)  & 0x0F); // set data I/O lines to input (4bit)
        RCALL   ??Subroutine5_0
//   65   outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)| 0xF0); // set pull-ups to on (4bit)
//   66   sbi(LCD_CTRL_PORT, LCD_CTRL_RW);        // set R/W to "read"
??CrossCallReturnLabel_2:
        SBI     0x15, 0x01
//   67   sbi(LCD_CTRL_PORT, LCD_CTRL_E);         // set "E" line
        SBI     0x15, 0x02
//   68   LCD_DELAY;                // wait
        nop
        nop
        RJMP    ??lcdBusyWait_0
//   69   while(inb(LCD_DATA_PIN) & 1<<LCD_BUSY)
//   70   {
//   71     cbi(LCD_CTRL_PORT, LCD_CTRL_E);   // clear "E" line
??lcdBusyWait_1:
        CBI     0x15, 0x02
//   72     LCD_DELAY;                  // wait
        nop
        nop
//   73     LCD_DELAY;                  // wait
        nop
        nop
//   74     sbi(LCD_CTRL_PORT, LCD_CTRL_E);   // set "E" line
        SBI     0x15, 0x02
//   75     LCD_DELAY;                  // wait
        nop
        nop
//   76     LCD_DELAY;                  // wait
        nop
        nop
//   77     cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
        CBI     0x15, 0x02
//   78     LCD_DELAY;                // wait
        nop
        nop
//   79     LCD_DELAY;                // wait
        nop
        nop
//   80     sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
        SBI     0x15, 0x02
//   81     LCD_DELAY;                // wait
        nop
        nop
//   82     LCD_DELAY;                // wait
        nop
        nop
//   83   }
??lcdBusyWait_0:
        SBIC    0x10, 0x07
        RJMP    ??lcdBusyWait_1
//   84   cbi(LCD_CTRL_PORT, LCD_CTRL_E);     // clear "E" line
        CBI     0x15, 0x02
//   85   //  leave data lines in input mode so they can be most easily used for other purposes
//   86 }
        RET
        REQUIRE _A_PORTC
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
        REQUIRE _A_PIND
//   87 

        RSEG `CODE`:CODE:NOROOT(1)
//   88 void lcdControlWrite(unsigned char data)
lcdControlWrite:
        CODE
//   89 {
        MOV     R18, R16
//   90 // write the control byte to the display controller
//   91   lcdBusyWait();              // wait until LCD not busy
        RCALL   lcdBusyWait
//   92   cbi(LCD_CTRL_PORT, LCD_CTRL_RS);      // set RS to "control"
        CBI     0x15, 0x00
//   93   cbi(LCD_CTRL_PORT, LCD_CTRL_RW);      // set R/W to "write"
        RCALL   ?Subroutine1
//   94     // 4 bit write
//   95   sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
//   96   outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)|0xF0); // set data I/O lines to output (4bit)
//   97   outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&0x0F) | (data&0xF0) );  // output data, high 4 bits
//   98   LCD_DELAY;                // wait
??CrossCallReturnLabel_0:
        nop
        nop
//   99   LCD_DELAY;                // wait
        nop
        nop
//  100   cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
        CBI     0x15, 0x02
//  101   LCD_DELAY;                // wait
        nop
        nop
//  102   LCD_DELAY;                // wait
        nop
        nop
//  103   sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
        RCALL   ?Subroutine2
//  104   outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&0x0F) | (data<<4) );  // output data, low 4 bits
//  105   LCD_DELAY;                // wait
??CrossCallReturnLabel_5:
        nop
        nop
//  106   LCD_DELAY;                // wait
        nop
        nop
//  107   cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
        RJMP    ?Subroutine0
        REQUIRE _A_PORTC
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
//  108   //  leave data lines in input mode so they can be most easily used for other purposes
//  109   outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);   // set data I/O lines to input (4bit)
//  110   outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0); // set pull-ups to on (4bit)
//  111 }
//  112 

        RSEG `CODE`:CODE:NOROOT(1)
//  113 unsigned char lcdControlRead(void)
lcdControlRead:
        CODE
//  114 {
//  115 // read the control byte from the display controller
//  116   register unsigned char data;
//  117   lcdBusyWait();        // wait until LCD not busy
        RCALL   lcdBusyWait
//  118   outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);   // set data I/O lines to input (4bit)
        RCALL   ??Subroutine5_0
//  119   outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0); // set pull-ups to on (4bit)
//  120   cbi(LCD_CTRL_PORT, LCD_CTRL_RS);    // set RS to "control"
??CrossCallReturnLabel_3:
        CBI     0x15, 0x00
//  121   sbi(LCD_CTRL_PORT, LCD_CTRL_RW);    // set R/W to "read"
        SBI     0x15, 0x01
//  122   // 4 bit read
//  123   sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
        SBI     0x15, 0x02
//  124   LCD_DELAY;            // wait
        nop
        nop
//  125   LCD_DELAY;            // wait
        nop
        nop
//  126   data = inb(LCD_DATA_PIN)&0xF0;  // input data, high 4 bits
        IN      R16, 0x10
//  127   cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
        CBI     0x15, 0x02
//  128   LCD_DELAY;            // wait
        nop
        nop
//  129   LCD_DELAY;            // wait
        nop
        nop
//  130   sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
        SBI     0x15, 0x02
//  131   LCD_DELAY;            // wait
        nop
        nop
//  132   LCD_DELAY;            // wait
        nop
        nop
//  133   data |= inb(LCD_DATA_PIN)>>4; // input data, low 4 bits
        RJMP    ?Subroutine3
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
        REQUIRE _A_PORTC
        REQUIRE _A_PIND
//  134   cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
//  135   //  leave data lines in input mode so they can be most easily used for other purposes
//  136   return data;
//  137 }
//  138 

        RSEG `CODE`:CODE:NOROOT(1)
//  139 void lcdDataWrite(unsigned char data)
lcdDataWrite:
        CODE
//  140 {
        MOV     R18, R16
//  141 // write a data byte to the display
//  142   lcdBusyWait();              // wait until LCD not busy
        RCALL   lcdBusyWait
//  143   sbi(LCD_CTRL_PORT, LCD_CTRL_RS);    // set RS to "data"
        SBI     0x15, 0x00
//  144   cbi(LCD_CTRL_PORT, LCD_CTRL_RW);    // set R/W to "write"
        RCALL   ?Subroutine1
//  145   // 4 bit write
//  146   sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
//  147   outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)|0xF0); // set data I/O lines to output (4bit)
//  148   outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&0x0F) | (data&0xF0) );  // output data, high 4 bits
//  149   LCD_DELAY;                // wait
??CrossCallReturnLabel_1:
        nop
        nop
//  150   LCD_DELAY;                // wait
        nop
        nop
//  151   cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
        CBI     0x15, 0x02
//  152   LCD_DELAY;                // wait
        nop
        nop
//  153   LCD_DELAY;                // wait
        nop
        nop
//  154   sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
        RCALL   ?Subroutine2
//  155   outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&0x0F) | (data<<4) );  // output data, low 4 bits
//  156   LCD_DELAY;                // wait
??CrossCallReturnLabel_6:
        nop
        nop
//  157   LCD_DELAY;                // wait
        nop
        nop
//  158   cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
        RJMP    ?Subroutine0
        REQUIRE _A_PORTC
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
//  159   //  leave data lines in input mode so they can be most easily used for other purposes
//  160   outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);   // set data I/O lines to input (4bit)
//  161   outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0); // set pull-ups to on (4bit)
//  162 }

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine2:
        SBI     0x15, 0x02
        IN      R16, 0x12
        ANDI    R16, 0x0F
        SWAP    R18
        ANDI    R18, 0xF0
        OR      R16, R18
        REQUIRE ?Subroutine4
        ;               // Fall through to label ?Subroutine4

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine4:
        OUT     0x12, R16
        RET

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine1:
        CBI     0x15, 0x01
        SBI     0x15, 0x02
        IN      R16, 0x11
        ORI     R16, 0xF0
        OUT     0x11, R16
        IN      R17, 0x12
        ANDI    R17, 0x0F
        MOV     R16, R18
        ANDI    R16, 0xF0
        OR      R17, R16
        OUT     0x12, R17
        RET

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine0:
        CBI     0x15, 0x02
        REQUIRE ??Subroutine5_0
        ;               // Fall through to label ??Subroutine5_0

        RSEG `CODE`:CODE:NOROOT(1)
??Subroutine5_0:
        IN      R16, 0x11
        ANDI    R16, 0x0F
        OUT     0x11, R16
        IN      R16, 0x12
        ORI     R16, 0xF0
        RJMP    ?Subroutine4
//  163 

        RSEG `CODE`:CODE:NOROOT(1)
//  164 unsigned char lcdDataRead(void)
lcdDataRead:
        CODE
//  165 {
//  166 // read a data byte from the display
//  167   register unsigned char data;
//  168   lcdBusyWait();        // wait until LCD not busy
        RCALL   lcdBusyWait
//  169   outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);   // set data I/O lines to input (4bit)
        RCALL   ??Subroutine5_0
//  170   outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0); // set pull-ups to on (4bit)
//  171   sbi(LCD_CTRL_PORT, LCD_CTRL_RS);    // set RS to "data"
??CrossCallReturnLabel_4:
        SBI     0x15, 0x00
//  172   sbi(LCD_CTRL_PORT, LCD_CTRL_RW);    // set R/W to "read"
        SBI     0x15, 0x01
//  173   // 4 bit read
//  174   sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
        SBI     0x15, 0x02
//  175   LCD_DELAY;                // wait
        nop
        nop
//  176   LCD_DELAY;                // wait
        nop
        nop
//  177   data = inb(LCD_DATA_PIN)&0xF0;  // input data, high 4 bits
        IN      R16, 0x10
//  178   cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
        CBI     0x15, 0x02
//  179   LCD_DELAY;                // wait
        nop
        nop
//  180   LCD_DELAY;                // wait
        nop
        nop
//  181   sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
        SBI     0x15, 0x02
//  182   LCD_DELAY;                // wait
        nop
        nop
//  183   LCD_DELAY;                // wait
        nop
        nop
//  184   data |= inb(LCD_DATA_PIN)>>4;     // input data, low 4 bits
        REQUIRE ?Subroutine3
        REQUIRE _A_DDRD
        REQUIRE _A_PORTD
        REQUIRE _A_PORTC
        REQUIRE _A_PIND
        ;               // Fall through to label ?Subroutine3
//  185   cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
//  186   //  leave data lines in input mode so they can be most easily used for other purposes
//  187   return data;
//  188 }

        RSEG `CODE`:CODE:NOROOT(1)
?Subroutine3:
        IN      R17, 0x10
        CBI     0x15, 0x02
        ANDI    R16, 0xF0
        SWAP    R17
        ANDI    R17, 0x0F
        OR      R16, R17
        RET
//  189 
//  190 
//  191 
//  192 /*************************************************************/
//  193 /********************* PUBLIC FUNCTIONS **********************/
//  194 /*************************************************************/
//  195 

        RSEG `CODE`:CODE:NOROOT(1)
//  196 void lcdInit()
lcdInit:
        CODE
//  197 {
//  198   // initialize hardware
//  199   lcdInitHW();
        RCALL   lcdInitHW
//  200   // LCD function set
//  201   lcdControlWrite(LCD_FUNCTION_DEFAULT);
        LDI     R16, 40
        RCALL   lcdControlWrite
//  202   // clear LCD
//  203   lcdControlWrite(1<<LCD_CLR);
        LDI     R16, 1
        RCALL   lcdControlWrite
//  204   // set entry mode
//  205   lcdControlWrite(1<<LCD_ENTRY_MODE | 1<<LCD_ENTRY_INC);
        LDI     R16, 6
        RCALL   lcdControlWrite
//  206   // set display to on
//  207   //lcdControlWrite(1<<LCD_ON_CTRL | 1<<LCD_ON_DISPLAY | 1<<LCD_ON_BLINK);
//  208   lcdControlWrite(1<<LCD_ON_CTRL | 1<<LCD_ON_DISPLAY );
        LDI     R16, 12
        RCALL   lcdControlWrite
//  209   // move cursor to home
//  210   lcdControlWrite(1<<LCD_HOME);
        LDI     R16, 2
        RCALL   lcdControlWrite
//  211   // set data address to 0
//  212   lcdControlWrite(1<<LCD_DDRAM | 0x00);
        LDI     R16, 128
        RJMP    lcdControlWrite
//  213 }
//  214 

        RSEG `CODE`:CODE:NOROOT(1)
//  215 void lcdHome(void)
lcdHome:
        CODE
//  216 {
//  217   // move cursor to home
//  218   lcdControlWrite(1<<LCD_HOME);
        LDI     R16, 2
        RJMP    lcdControlWrite
//  219 }
//  220 

        RSEG `CODE`:CODE:NOROOT(1)
//  221 void lcdClear(void)
lcdClear:
        CODE
//  222 {
//  223   // clear LCD
//  224   lcdControlWrite(1<<LCD_CLR);
        LDI     R16, 1
        RJMP    lcdControlWrite
//  225 }
//  226 

        RSEG `CODE`:CODE:NOROOT(1)
//  227 void lcdGotoXY(unsigned char x, unsigned char y)
lcdGotoXY:
        CODE
//  228 {
//  229   register unsigned char DDRAMAddr;
//  230 
//  231   // remap lines into proper order
//  232   switch(y)
        DEC     R17
        BREQ    ??lcdGotoXY_0
        SUBI    R17, 2
        BRNE    ??lcdGotoXY_1
//  233   {
//  234   case 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; break;
//  235   case 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; break;
//  236   case 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; break;
//  237   case 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; break;
??lcdGotoXY_0:
        SUBI    R16, 216
//  238   default: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
//  239   }
//  240 
//  241   // set data address
//  242   lcdControlWrite(1<<LCD_DDRAM | DDRAMAddr);
??lcdGotoXY_1:
        ORI     R16, 0x80
        RJMP    lcdControlWrite
//  243 }
//  244 
//  245 

        RSEG `CODE`:CODE:NOROOT(1)
//  246 void lcdPrintData(char* data, unsigned char nBytes)
lcdPrintData:
        CODE
//  247 {
        MOVW    R23:R22, R17:R16
        MOV     R19, R18
//  248   register unsigned char i;
//  249 
//  250   // check to make sure we have a good pointer
//  251   if (!data) return;
        OR      R16, R23
        BREQ    ??lcdPrintData_0
//  252 
//  253   // print data
//  254   for(i=0; i<nBytes; i++)
        LDI     R20, 0
        LDI     R21, 0
        RJMP    ??lcdPrintData_1
//  255   {
//  256     lcdDataWrite(data[i]);
??lcdPrintData_2:
        MOVW    R31:R30, R23:R22
        ADD     R30, R20
        ADC     R31, R21
        LD      R16, Z
        RCALL   lcdDataWrite
//  257   }
        INC     R20
??lcdPrintData_1:
        CP      R20, R19
        BRCS    ??lcdPrintData_2
//  258 }
??lcdPrintData_0:
        RET
//  259 

        RSEG `CODE`:CODE:NOROOT(1)
//  260 void lcdPrintData_P(char __flash* data)
lcdPrintData_P:
        CODE
//  261 {
        MOVW    R31:R30, R17:R16
        RJMP    ??lcdPrintData_P_0
//  262   unsigned char ch;
//  263 
//  264   // print data
//  265   do
//  266   {
//  267     ch = *data++;
//  268     if (ch==0) break;
//  269     lcdDataWrite(ch);
??lcdPrintData_P_1:
        RCALL   lcdDataWrite
//  270   }
//  271   while (1);
??lcdPrintData_P_0:
        LPM     R16, Z+
        TST     R16
        BRNE    ??lcdPrintData_P_1
//  272 }
        RET

        ASEGN ABSOLUTE:DATA:NOROOT,01cH
__?EECR:

        ASEGN ABSOLUTE:DATA:NOROOT,01dH
__?EEDR:

        ASEGN ABSOLUTE:DATA:NOROOT,01eH
__?EEARL:

        ASEGN ABSOLUTE:DATA:NOROOT,01fH
__?EEARH:

        END
//  273 
//  274 
//  275 
// 
//   5 bytes in segment ABSOLUTE
// 396 bytes in segment CODE
// 
// 396 bytes of CODE memory
//   0 bytes of DATA memory (+ 5 bytes shared)
//
//Errors: none
//Warnings: none
