###############################################################################
#
# IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR       26/Oct/2021  16:53:18
# Copyright 1996-2021 IAR Systems AB.
#
#    Source file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Util.c
#    Command line =  
#        -f C:\Users\aly\AppData\Local\Temp\EW6864.tmp
#        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Util.c
#        --cpu=m8 -ms -o
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\Obj
#        -lCN
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List
#        -lB
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List
#        --initializers_in_flash --debug -DENABLE_BIT_DEFINITIONS -e
#        --eeprom_size 512 --clib -Ohz)
#    Locale       =  Russian_RUS.1251
#    List file    =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List\Util.lst
#    Object file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\Obj\Util.r90
#
###############################################################################

D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Util.c
      1          #include  "main.h"
      2          #include  <stdlib.h>
      3          
      4          // ==========================================================
      5          //  Проверка соответствия символа шестнадцатеричному представлению
      6          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
      7          unsigned char is_hex_digit(unsigned char c)
   \                     is_hex_digit:
      8          {
      9              if ((c >= '0' && c <= '9') ||
     10                  (c >= 'a' && c <= 'f') ||
     11                  (c >= 'A' && c <= 'F')) return (1);
   \   00000000   2F10               MOV     R17, R16
   \   00000002   5310               SUBI    R17, 48
   \   00000004   301A               CPI     R17, 10
   \   00000006   F038               BRCS    ??is_hex_digit_0
   \   00000008   2F10               MOV     R17, R16
   \   0000000A   5611               SUBI    R17, 97
   \   0000000C   3016               CPI     R17, 6
   \   0000000E   F018               BRCS    ??is_hex_digit_0
   \   00000010   5401               SUBI    R16, 65
   \   00000012   3006               CPI     R16, 6
   \   00000014   F410               BRCC    ??is_hex_digit_1
   \                     ??is_hex_digit_0:
   \   00000016   E001               LDI     R16, 1
   \   00000018   9508               RET
     12              return (0);
   \                     ??is_hex_digit_1:
   \   0000001A   E000               LDI     R16, 0
   \   0000001C   9508               RET
     13          } 
     14          
     15          // ==========================================================
     16          //  Преобразование символа в шестнадцатеричное представление
     17          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     18          unsigned char ascii_to_hex(unsigned char c)
   \                     ascii_to_hex:
     19          {
     20              if (c >= '0' && c <= '9')      return ( c - '0' ) & 0x0f;
   \   00000000   2F10               MOV     R17, R16
   \   00000002   5310               SUBI    R17, 48
   \   00000004   301A               CPI     R17, 10
   \   00000006   F028               BRCS    ??ascii_to_hex_0
     21              else if (c >= 'a' && c <= 'f') return ( c - 'a' + 10 ) & 0x0f;
   \   00000008   2F10               MOV     R17, R16
   \   0000000A   5611               SUBI    R17, 97
   \   0000000C   3016               CPI     R17, 6
   \   0000000E   F418               BRCC    ??ascii_to_hex_1
   \   00000010   5507               SUBI    R16, 87
   \                     ??ascii_to_hex_0:
   \   00000012   700F               ANDI    R16, 0x0F
   \   00000014   9508               RET
     22              else                           return ( c - 'A' + 10 ) & 0x0f;
   \                     ??ascii_to_hex_1:
   \   00000016   5307               SUBI    R16, 55
   \   00000018   CFFC               RJMP    ??ascii_to_hex_0
     23          } 
     24          
     25          // ==========================================================
     26          //  Преобразование байта в ASCII 
     27          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     28          unsigned char hex_to_ascii(unsigned char c)
   \                     hex_to_ascii:
     29          {
     30              c = c & 0xf;
   \   00000000   700F               ANDI    R16, 0x0F
     31              if (c <= 9) return (c + 0x30);
   \   00000002   300A               CPI     R16, 10
   \   00000004   F410               BRCC    ??hex_to_ascii_0
   \   00000006   5D00               SUBI    R16, 208
   \   00000008   9508               RET
     32              return (c + 'A' - 10);
   \                     ??hex_to_ascii_0:
   \   0000000A   5C09               SUBI    R16, 201
   \   0000000C   9508               RET
     33          } 
     34          
     35          // ==========================================================
     36          //  Преобразовать не символьные байты в точку
     37          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     38          unsigned char write_ascii(unsigned char c)
   \                     write_ascii:
     39          {
     40              if (c >= 0x20) return (c);
   \   00000000   3200               CPI     R16, 32
   \   00000002   F408               BRCC    ??write_ascii_0
     41              return ('.');
   \   00000004   E20E               LDI     R16, 46
   \                     ??write_ascii_0:
   \   00000006   9508               RET
     42          } 
     43          
     44          
     45          
     46          
     47          // ==========================================================
     48          //  Расчет контрольной суммы по стандарту CRC CCITT 
     49          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     50          unsigned int GetCRC(unsigned int CRC,unsigned char b)
   \                     GetCRC:
     51          {
     52          #define POLI 0x1021 // CRC-16/CITT
     53            unsigned char i;
     54            CRC=CRC ^ (b << 8);
   \   00000000   2712               EOR     R17, R18
     55            for (i=0;i<8;i++)
   \   00000002   E028               LDI     R18, 8
     56            {
     57              if ((CRC & 0x8000) != 0) 
   \                     ??GetCRC_0:
   \   00000004   01A8               MOVW    R21:R20, R17:R16
   \   00000006   0F44               LSL     R20
   \   00000008   1F55               ROL     R21
   \   0000000A   FB17               BST     R17, 7
   \   0000000C   018A               MOVW    R17:R16, R21:R20
   \   0000000E   F426               BRTC    ??GetCRC_1
     58              {
     59                CRC=(CRC << 1) ^ POLI; 
   \   00000010   E231               LDI     R19, 33
   \   00000012   2703               EOR     R16, R19
   \   00000014   E130               LDI     R19, 16
   \   00000016   2713               EOR     R17, R19
     60              }
     61              else
     62              {
     63                CRC=(CRC << 1);
     64              }   
     65            } 
   \                     ??GetCRC_1:
   \   00000018   952A               DEC     R18
   \   0000001A   F7A1               BRNE    ??GetCRC_0
     66            return CRC;
   \   0000001C   9508               RET
     67          }
     68          
     69          // ==========================================================
     70          //  Расчет контрольной суммы блока данных
     71          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     72          unsigned int GetBlockCRC(unsigned char* b,long len)
   \                     GetBlockCRC:
     73          {
   \   00000000   ....               RCALL   ?PROLOGUE6_L09
   \   00000002                      REQUIRE ?Register_R4_is_cg_reg
   \   00000002                      REQUIRE ?Register_R5_is_cg_reg
   \   00000002   0128               MOVW    R5:R4, R17:R16
   \   00000004   010A               MOVW    R1:R0, R21:R20
     74            long i;
     75            unsigned int CRC=0xFFFF;
   \   00000006   EF0F               LDI     R16, 255
   \   00000008   EF1F               LDI     R17, 255
     76            
     77            for (i=0;i<len;i++)
   \   0000000A   E080               LDI     R24, 0
   \   0000000C   E090               LDI     R25, 0
   \   0000000E   E0A0               LDI     R26, 0
   \   00000010   E0B0               LDI     R27, 0
   \   00000012   C009               RJMP    ??GetBlockCRC_0
     78            {
     79               CRC=GetCRC(CRC, *(b+i)); 
   \                     ??GetBlockCRC_1:
   \   00000014   01F2               MOVW    R31:R30, R5:R4
   \   00000016   0FE8               ADD     R30, R24
   \   00000018   1FF9               ADC     R31, R25
   \   0000001A   8120               LD      R18, Z
   \   0000001C   ....               RCALL   GetCRC
     80            }
   \   0000001E   5F8F               SUBI    R24, 255
   \   00000020   4F9F               SBCI    R25, 255
   \   00000022   4FAF               SBCI    R26, 255
   \   00000024   4FBF               SBCI    R27, 255
   \                     ??GetBlockCRC_0:
   \   00000026   1580               CP      R24, R0
   \   00000028   0591               CPC     R25, R1
   \   0000002A   07A6               CPC     R26, R22
   \   0000002C   07B7               CPC     R27, R23
   \   0000002E   F394               BRLT    ??GetBlockCRC_1
     81            return CRC;
   \   00000030   E0E6               LDI     R30, 6
   \   00000032   ....               RJMP    ?EPILOGUE_B6_L09
     82          }
     83          
     84          
     85          // ==========================================================
     86          //  Перевод беззнакового целого числа (unsigned long) в строку
     87          //  buf   - указатель на буфер приемник строки
     88          //  ln    - максимальная длина строки
     89          //  ul    - преобразуемое число
     90          //  base  - база исчисления: 10 - десятичная, 16 - шестнадцатеричная, 2 - двоичная и т.д.  
     91          //  Возвращает количество символов в строке 
     92          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
     93          int Num_to_str(unsigned char *buf,int ln,unsigned long ul,unsigned char base)
   \                     Num_to_str:
     94          {
   \   00000000   ....               RCALL   ?PROLOGUE7_L09
   \   00000002                      REQUIRE ?Register_R4_is_cg_reg
   \   00000002                      REQUIRE ?Register_R5_is_cg_reg
   \   00000002                      REQUIRE ?Register_R6_is_cg_reg
   \   00000002   9728               SBIW    R29:R28, 8
   \   00000004   0128               MOVW    R5:R4, R17:R16
   \   00000006   01D9               MOVW    R27:R26, R19:R18
     95            int    n;          // Счетчик позиции в буфере    
     96            ldiv_t res;        // Результат целочисленного деления
     97            unsigned char b;
     98            int i;
     99            
    100            n=0;
   \   00000008   E080               LDI     R24, 0
   \   0000000A   E090               LDI     R25, 0
   \   0000000C   846F               LDD     R6, Y+15
   \   0000000E   C007               RJMP    ??Num_to_str_0
    101            for (;;)                            
    102            {                                   
    103              res=ldiv(ul,base);                 
    104              *(buf+n)=hex_to_ascii(res.rem);       
    105              n++;                              
    106              if (ln!=0) 
    107              {                       
    108                if (n>=ln) break;             
   \                     ??Num_to_str_1:
   \   00000010   178A               CP      R24, R26
   \   00000012   079B               CPC     R25, R27
   \   00000014   F4FC               BRGE    ??Num_to_str_2
    109              }  
    110              else                    
    111              {          
    112                if (res.quot==0) break;         
    113              }  
    114              ul=res.quot;                      
   \                     ??Num_to_str_3:
   \   00000016   8148               LD      R20, Y
   \   00000018   8159               LDD     R21, Y+1
   \   0000001A   816A               LDD     R22, Y+2
   \   0000001C   817B               LDD     R23, Y+3
   \                     ??Num_to_str_0:
   \   0000001E   E010               LDI     R17, 0
   \   00000020   931A               ST      -Y, R17
   \   00000022   931A               ST      -Y, R17
   \   00000024   931A               ST      -Y, R17
   \   00000026   926A               ST      -Y, R6
   \   00000028   018E               MOVW    R17:R16, R29:R28
   \   0000002A   5F0C               SUBI    R16, 252
   \   0000002C   4F1F               SBCI    R17, 255
   \   0000002E   ....               RCALL   ldiv
   \   00000030   810C               LDD     R16, Y+4
   \   00000032   ....               RCALL   hex_to_ascii
   \   00000034   01F2               MOVW    R31:R30, R5:R4
   \   00000036   0FE8               ADD     R30, R24
   \   00000038   1FF9               ADC     R31, R25
   \   0000003A   8300               ST      Z, R16
   \   0000003C   9601               ADIW    R25:R24, 1
   \   0000003E   2F0A               MOV     R16, R26
   \   00000040   2B0B               OR      R16, R27
   \   00000042   F731               BRNE    ??Num_to_str_1
   \   00000044   8108               LD      R16, Y
   \   00000046   8119               LDD     R17, Y+1
   \   00000048   812A               LDD     R18, Y+2
   \   0000004A   813B               LDD     R19, Y+3
   \   0000004C   2B01               OR      R16, R17
   \   0000004E   2B02               OR      R16, R18
   \   00000050   2B03               OR      R16, R19
   \   00000052   F709               BRNE    ??Num_to_str_3
    115            }              
    116          
    117            // Переписать буфер в обратной последовательности
    118            for (i=0;i<(n / 2);i++)
   \                     ??Num_to_str_2:
   \   00000054   E0A0               LDI     R26, 0
   \   00000056   E0B0               LDI     R27, 0
   \   00000058   0192               MOVW    R19:R18, R5:R4
   \   0000005A   0F28               ADD     R18, R24
   \   0000005C   1F39               ADC     R19, R25
   \   0000005E   C015               RJMP    ??Num_to_str_4
    119            {
    120              b=*(buf+i);
   \                     ??Num_to_str_5:
   \   00000060   01A2               MOVW    R21:R20, R5:R4
   \   00000062   0F4A               ADD     R20, R26
   \   00000064   1F5B               ADC     R21, R27
   \   00000066   01FA               MOVW    R31:R30, R21:R20
   \   00000068   8000               LD      R0, Z
    121              *(buf+i)=*(buf+n-i-1);
   \   0000006A   01BD               MOVW    R23:R22, R27:R26
   \   0000006C   9571               NEG     R23
   \   0000006E   9561               NEG     R22
   \   00000070   4070               SBCI    R23, 0
   \   00000072   0189               MOVW    R17:R16, R19:R18
   \   00000074   0F06               ADD     R16, R22
   \   00000076   1F17               ADC     R17, R23
   \   00000078   5001               SUBI    R16, 1
   \   0000007A   4010               SBCI    R17, 0
   \   0000007C   01F8               MOVW    R31:R30, R17:R16
   \   0000007E   8160               LD      R22, Z
   \   00000080   01FA               MOVW    R31:R30, R21:R20
   \   00000082   8360               ST      Z, R22
    122              *(buf+n-i-1)=b; 
   \   00000084   01F8               MOVW    R31:R30, R17:R16
   \   00000086   8200               ST      Z, R0
    123            }
   \   00000088   9611               ADIW    R27:R26, 1
   \                     ??Num_to_str_4:
   \   0000008A   E042               LDI     R20, 2
   \   0000008C   E050               LDI     R21, 0
   \   0000008E   018C               MOVW    R17:R16, R25:R24
   \   00000090   ....               RCALL   ?SS_DIVMOD_L02
   \   00000092   17A0               CP      R26, R16
   \   00000094   07B1               CPC     R27, R17
   \   00000096   F324               BRLT    ??Num_to_str_5
    124              
    125            *(buf+n)=0; // Закончить строку нулем 
   \   00000098   01F9               MOVW    R31:R30, R19:R18
   \   0000009A   E000               LDI     R16, 0
   \   0000009C   8300               ST      Z, R16
    126            return n;
   \   0000009E   018C               MOVW    R17:R16, R25:R24
   \   000000A0   9628               ADIW    R29:R28, 8
   \   000000A2   E0E8               LDI     R30, 8
   \   000000A4   ....               RJMP    ?EPILOGUE_B7_L09
    127          }   
    128          
    129          // ==========================================================
    130          //  Преобразует строку в беззнаковое целое число 
    131          //  *buf - указатель на буфер в котором находиться строка
    132          //  base - база исчисления: 10 - десятичная, 16 - шестнадцатеричная, 2 - двоичная и т.д.  
    133          //  Возвращает  число
    134          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
    135          unsigned long Str_to_num(unsigned char *buf, unsigned char base)
   \                     Str_to_num:
    136          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
   \   00000002   2E32               MOV     R3, R18
    137            unsigned long b=0;  
   \   00000004   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_8:
   \   00000006   C00E               RJMP    ??Str_to_num_0
    138            while (*buf!=0)
    139            {
    140              b=b*base + ascii_to_hex(*buf);
   \                     ??Str_to_num_1:
   \   00000008   2D03               MOV     R16, R3
   \   0000000A   E010               LDI     R17, 0
   \   0000000C   E020               LDI     R18, 0
   \   0000000E   E030               LDI     R19, 0
   \   00000010   ....               RCALL   ?L_EC_MUL_L03
   \   00000012   01A8               MOVW    R21:R20, R17:R16
   \   00000014   01B9               MOVW    R23:R22, R19:R18
   \   00000016   9101               LD      R16, Z+
   \   00000018   ....               RCALL   ascii_to_hex
   \   0000001A   E010               LDI     R17, 0
   \   0000001C   0F40               ADD     R20, R16
   \   0000001E   1F51               ADC     R21, R17
   \   00000020   1F61               ADC     R22, R17
   \   00000022   1F71               ADC     R23, R17
    141              buf++;
    142            }   
   \                     ??Str_to_num_0:
   \   00000024   8100               LD      R16, Z
   \   00000026   2300               TST     R16
   \   00000028   F779               BRNE    ??Str_to_num_1
    143            return b; 
   \   0000002A   018A               MOVW    R17:R16, R21:R20
   \   0000002C   019B               MOVW    R19:R18, R23:R22
   \   0000002E   9508               RET
    144            
    145          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   ....               RCALL   ?Subroutine9
   \                     ??CrossCallReturnLabel_16:
   \   00000002   E060               LDI     R22, 0
   \   00000004   E070               LDI     R23, 0
   \   00000006   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   00000000   E040               LDI     R20, 0
   \   00000002   E050               LDI     R21, 0
   \   00000004   9508               RET
    146          

   \                                 In  segment CODE, align 2, keep-with-next
    147          unsigned char Str_to_byte(unsigned char *buf)
   \                     Str_to_byte:
    148          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
    149            return (ascii_to_hex(buf[0])<<4) + ascii_to_hex(buf[1]);
   \   00000002   8100               LD      R16, Z
   \   00000004   ....               RCALL   ascii_to_hex
   \   00000006   9502               SWAP    R16
   \   00000008   7F00               ANDI    R16, 0xF0
   \   0000000A   2F20               MOV     R18, R16
   \   0000000C   8101               LDD     R16, Z+1
   \   0000000E   ....               RCALL   ascii_to_hex
   \   00000010   0F02               ADD     R16, R18
   \   00000012   9508               RET
    150          } 
    151          
    152          
    153          /* ========================================================
    154             Выравнивание строки вправо
    155             ========================================================*/

   \                                 In  segment CODE, align 2, keep-with-next
    156          void Right_align_str(unsigned char *buf, int buf_len)
   \                     Right_align_str:
    157          {
   \   00000000   ....               RCALL   ?PROLOGUE4_L09
   \   00000002   01A8               MOVW    R21:R20, R17:R16
   \   00000004   01B9               MOVW    R23:R22, R19:R18
    158            int l=0;
   \   00000006   E080               LDI     R24, 0
   \   00000008   E090               LDI     R25, 0
   \   0000000A   C001               RJMP    ??Right_align_str_0
    159            int i;
    160            while (*(buf+l)!=0) l++; // Найдем длину строки в буфере
   \                     ??Right_align_str_1:
   \   0000000C   9601               ADIW    R25:R24, 1
   \                     ??Right_align_str_0:
   \   0000000E   018A               MOVW    R17:R16, R21:R20
   \   00000010   0F08               ADD     R16, R24
   \   00000012   1F19               ADC     R17, R25
   \   00000014   01F8               MOVW    R31:R30, R17:R16
   \   00000016   8120               LD      R18, Z
   \   00000018   2322               TST     R18
   \   0000001A   F7C1               BRNE    ??Right_align_str_1
    161            if (l<buf_len)
   \   0000001C   1786               CP      R24, R22
   \   0000001E   0797               CPC     R25, R23
   \   00000020   F4DC               BRGE    ??Right_align_str_2
    162            {
    163              for (i=0;i<l;i++) 
   \   00000022   E020               LDI     R18, 0
   \   00000024   E030               LDI     R19, 0
   \   00000026   0F46               ADD     R20, R22
   \   00000028   1F57               ADC     R21, R23
   \   0000002A   C010               RJMP    ??Right_align_str_3
    164              {
    165                *(buf+buf_len-1-i)=*(buf+l-1-i);
   \                     ??Right_align_str_4:
   \   0000002C   01B9               MOVW    R23:R22, R19:R18
   \   0000002E   9571               NEG     R23
   \   00000030   9561               NEG     R22
   \   00000032   4070               SBCI    R23, 0
   \   00000034   01F8               MOVW    R31:R30, R17:R16
   \   00000036   0FE6               ADD     R30, R22
   \   00000038   1FF7               ADC     R31, R23
   \   0000003A   9002               LD      R0, -Z
   \   0000003C   01DA               MOVW    R27:R26, R21:R20
   \   0000003E   0FA6               ADD     R26, R22
   \   00000040   1FB7               ADC     R27, R23
   \   00000042   920E               ST      -X, R0
    166                *(buf+l-1-i)=' ';
   \   00000044   E260               LDI     R22, 32
   \   00000046   8360               ST      Z, R22
    167              }
   \   00000048   5F2F               SUBI    R18, 255
   \   0000004A   4F3F               SBCI    R19, 255
   \                     ??Right_align_str_3:
   \   0000004C   1728               CP      R18, R24
   \   0000004E   0739               CPC     R19, R25
   \   00000050   F36C               BRLT    ??Right_align_str_4
    168              *(buf+buf_len)=0; 
   \   00000052   01FA               MOVW    R31:R30, R21:R20
   \   00000054   E000               LDI     R16, 0
   \   00000056   8300               ST      Z, R16
    169            } 
    170          } 
   \                     ??Right_align_str_2:
   \   00000058   E0E4               LDI     R30, 4
   \   0000005A   ....               RJMP    ?EPILOGUE_B4_L09
    171          
    172          // ==========================================================
    173          //  Преобразование числа в строковое представление. Возвращает указатель на конец занятого буфера 
    174          // ==========================================================

   \                                 In  segment CODE, align 2, keep-with-next
    175          unsigned char *float_conversion(float value,   // Преобразуемая величина
   \                     float_conversion:
    176                                        short nr_of_digits,    // Общее количество цифр для представления числа 
    177                                                               // Если число меньше 1, то не считая предварительных нулей 
    178                                        unsigned char *buf,     
    179                                        unsigned char format_flag,    // 'E' или 'e'
    180                                        unsigned char g_flag,         // 1 - представлять в формате с фиксированной точкой
    181                                        unsigned char alternate_flag) // 1 - не убирать не значащие нули
    182          {
   \   00000000   ....               RCALL   ?PROLOGUE16_L09
   \   00000002                      REQUIRE ?Register_R4_is_cg_reg
   \   00000002                      REQUIRE ?Register_R5_is_cg_reg
   \   00000002                      REQUIRE ?Register_R6_is_cg_reg
   \   00000002                      REQUIRE ?Register_R7_is_cg_reg
   \   00000002                      REQUIRE ?Register_R8_is_cg_reg
   \   00000002                      REQUIRE ?Register_R9_is_cg_reg
   \   00000002                      REQUIRE ?Register_R10_is_cg_reg
   \   00000002                      REQUIRE ?Register_R11_is_cg_reg
   \   00000002                      REQUIRE ?Register_R12_is_cg_reg
   \   00000002                      REQUIRE ?Register_R13_is_cg_reg
   \   00000002                      REQUIRE ?Register_R14_is_cg_reg
   \   00000002                      REQUIRE ?Register_R15_is_cg_reg
   \   00000002   ....               RCALL   ?Subroutine10
   \                     ??CrossCallReturnLabel_17:
   \   00000004   017A               MOVW    R15:R14, R21:R20
   \   00000006   015B               MOVW    R11:R10, R23:R22
    183            unsigned char *cp, *buf_pointer;
    184            short n, i, dec_point_pos, integral_10_log;
    185          
    186            buf_pointer = buf;
   \   00000008   016B               MOVW    R13:R12, R23:R22
    187            integral_10_log = 0;
   \   0000000A   2488               CLR     R8
   \   0000000C   2499               CLR     R9
    188            // Показать знак числа
    189            if (value<0)
   \   0000000E   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_9:
   \   00000010   ....               RCALL   ?F_CMP_LT_L04
   \   00000012   F420               BRCC    ??CrossCallReturnLabel_23
    190            {
    191              value=-value;
   \   00000014   58B0               SUBI    R27, 128
    192              *buf_pointer++ = '-';
   \   00000016   01F6               MOVW    R31:R30, R13:R12
   \   00000018   E20D               LDI     R16, 45
   \   0000001A   ....               RCALL   ??Subroutine11_0
    193            } 
    194            
    195            if (value >= 1)
   \                     ??CrossCallReturnLabel_23:
   \   0000001C   2F08               MOV     R16, R24
   \   0000001E   2F3B               MOV     R19, R27
   \   00000020   E860               LDI     R22, 128
   \   00000022   E37F               LDI     R23, 63
   \   00000024   ....               RCALL   ?F_CMP_GE_L04
   \   00000026   F128               BRCS    ??float_conversion_0
    196            {
    197              // Вычисляем количество десятков в экспоненте
    198              while (value >= 1e11)        
    199              {
    200                value /= 1e10;
    201                integral_10_log += 10;
    202              }
    203              // Вычисляем количество единиц в экспоненте
    204              while (value >= 10)
    205              {
    206                value /= 10;
    207                integral_10_log++;
    208              }
    209            }
    210            else if (value)            
   \   00000028   2F0B               MOV     R16, R27
   \   0000002A   0F00               LSL     R16
   \   0000002C   2B08               OR      R16, R24
   \   0000002E   2B09               OR      R16, R25
   \   00000030   2B0A               OR      R16, R26
   \   00000032   F5C1               BRNE    ??float_conversion_1
    211            {
    212              // Вычисляем количество десятков в знаменателе экспоненты
    213              while (value <= 1e-10)        
    214              {
    215                value *= 1e10;
    216                integral_10_log -= 10;
    217              }
    218              // Вычисляем количество единиц в знаменателе экспоненты
    219              while (value < 1)
    220              {
    221                value *= 10;
    222                integral_10_log--;
    223              }
    224            }
    225            
    226            if (g_flag)
   \                     ??float_conversion_2:
   \   00000034   8909               LDD     R16, Y+17
   \   00000036   2300               TST     R16
   \   00000038   F409               BRNE    $+2+2
   \   0000003A   C048               RJMP    ??float_conversion_3
    227            {
    228              if (integral_10_log < nr_of_digits && integral_10_log >= -4)
   \   0000003C   148E               CP      R8, R14
   \   0000003E   049F               CPC     R9, R15
   \   00000040   F44C               BRGE    ??float_conversion_4
   \   00000042   EF0C               LDI     R16, 252
   \   00000044   1680               CP      R8, R16
   \   00000046   EF0F               LDI     R16, 255
   \   00000048   0690               CPC     R9, R16
   \   0000004A   F024               BRLT    ??float_conversion_4
    229              {
    230                format_flag = 0;
   \   0000004C   E000               LDI     R16, 0
   \   0000004E   8B08               STD     Y+16, R16
    231                nr_of_digits = nr_of_digits - integral_10_log;
   \   00000050   18E8               SUB     R14, R8
   \   00000052   08F9               SBC     R15, R9
    232              }
    233              nr_of_digits--;
   \                     ??float_conversion_4:
   \   00000054   EF0F               LDI     R16, 255
   \   00000056   0EE0               ADD     R14, R16
   \   00000058   1EF0               ADC     R15, R16
    234              if (alternate_flag)
   \   0000005A   890A               LDD     R16, Y+18
   \   0000005C   2300               TST     R16
   \   0000005E   F1A1               BREQ    ??float_conversion_5
    235              {
    236                g_flag = 0;         /* %#G - No removal of trailing zeros */
   \   00000060   E000               LDI     R16, 0
   \   00000062   8B09               STD     Y+17, R16
   \   00000064   C033               RJMP    ??float_conversion_3
    237              }
   \                     ??float_conversion_6:
   \   00000066   ....               RCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_10:
   \   00000068   ....               RCALL   ?Subroutine7
   \                     ??CrossCallReturnLabel_21:
   \   0000006A   E00A               LDI     R16, 10
   \   0000006C   0E80               ADD     R8, R16
   \   0000006E   E000               LDI     R16, 0
   \   00000070   1E90               ADC     R9, R16
   \                     ??float_conversion_0:
   \   00000072   ....               RCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_4:
   \   00000074   EB47               LDI     R20, 183
   \   00000076   E453               LDI     R21, 67
   \   00000078   EB6A               LDI     R22, 186
   \   0000007A   E571               LDI     R23, 81
   \   0000007C   ....               RCALL   ?F_CMP_GE_L04
   \   0000007E   F398               BRCS    ??float_conversion_6
   \                     ??float_conversion_7:
   \   00000080   ....               RCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_14:
   \   00000082   E260               LDI     R22, 32
   \   00000084   E471               LDI     R23, 65
   \   00000086   ....               RCALL   ?F_CMP_GE_L04
   \   00000088   F6A8               BRCC    ??float_conversion_2
   \   0000008A   ....               RCALL   ?Subroutine7
   \                     ??CrossCallReturnLabel_22:
   \   0000008C   E001               LDI     R16, 1
   \   0000008E   0E80               ADD     R8, R16
   \   00000090   E000               LDI     R16, 0
   \   00000092   1E90               ADC     R9, R16
   \   00000094   CFF5               RJMP    ??float_conversion_7
   \                     ??float_conversion_8:
   \   00000096   ....               RCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_11:
   \   00000098   ....               RCALL   ?F_MUL_L04
   \   0000009A   ....               RCALL   ?Subroutine10
   \                     ??CrossCallReturnLabel_18:
   \   0000009C   EF06               LDI     R16, 246
   \   0000009E   0E80               ADD     R8, R16
   \   000000A0   EF0F               LDI     R16, 255
   \   000000A2   1E90               ADC     R9, R16
   \                     ??float_conversion_1:
   \   000000A4   ....               RCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_5:
   \   000000A6   E040               LDI     R20, 0
   \   000000A8   EE57               LDI     R21, 231
   \   000000AA   ED6B               LDI     R22, 219
   \   000000AC   E27E               LDI     R23, 46
   \   000000AE   ....               RCALL   ?F_CMP_LT_L04
   \   000000B0   F390               BRCS    ??float_conversion_8
   \                     ??float_conversion_9:
   \   000000B2   ....               RCALL   ?Subroutine3
   \                     ??CrossCallReturnLabel_15:
   \   000000B4   E860               LDI     R22, 128
   \   000000B6   E37F               LDI     R23, 63
   \   000000B8   ....               RCALL   ?F_CMP_LT_L04
   \   000000BA   F008               BRCS    $+2+2
   \   000000BC   CFBB               RJMP    ??float_conversion_2
   \   000000BE   ....               RCALL   ?Subroutine0
   \                     ??CrossCallReturnLabel_19:
   \   000000C0   EF0F               LDI     R16, 255
   \   000000C2   0E80               ADD     R8, R16
   \   000000C4   1E90               ADC     R9, R16
   \   000000C6   CFF5               RJMP    ??float_conversion_9
    238              else
    239              {
    240                alternate_flag = 1;  /* %G - Removal of trailing zeros */
   \                     ??float_conversion_5:
   \   000000C8   E001               LDI     R16, 1
   \   000000CA   8B0A               STD     Y+18, R16
    241              }
    242            }
    243            
    244            if (format_flag)        /* %e or %E */
   \                     ??float_conversion_3:
   \   000000CC   8908               LDD     R16, Y+16
   \   000000CE   2300               TST     R16
   \   000000D0   F019               BREQ    ??float_conversion_10
    245            {
    246              // Для представления с экспонентой
    247              dec_point_pos = 0;
   \   000000D2   2466               CLR     R6
   \   000000D4   2477               CLR     R7
   \   000000D6   C04C               RJMP    ??CrossCallReturnLabel_26
    248            }
    249            else
    250            {
    251              if (integral_10_log < 0)       
   \                     ??float_conversion_10:
   \   000000D8   2099               TST     R9
   \   000000DA   F522               BRPL    ??float_conversion_11
    252              {
    253                // Для чисел меньших по абсолютному значению чем 1 в представлении без экспоненты
    254                *buf_pointer++ = '0';
   \   000000DC   ....               RCALL   ?Subroutine6
    255                if ((n = nr_of_digits) || alternate_flag)
   \                     ??CrossCallReturnLabel_29:
   \   000000DE   0127               MOVW    R5:R4, R15:R14
   \   000000E0   2D0E               MOV     R16, R14
   \   000000E2   2905               OR      R16, R5
   \   000000E4   F419               BRNE    ??float_conversion_12
   \   000000E6   890A               LDD     R16, Y+18
   \   000000E8   2300               TST     R16
   \   000000EA   F011               BREQ    ??CrossCallReturnLabel_24
    256                {
    257                  *buf_pointer++ = '.';
   \                     ??float_conversion_12:
   \   000000EC   E20E               LDI     R16, 46
   \   000000EE   ....               RCALL   ??Subroutine11_0
    258                }
    259                i = 0;
   \                     ??CrossCallReturnLabel_24:
   \   000000F0   2466               CLR     R6
   \   000000F2   2477               CLR     R7
   \   000000F4   C004               RJMP    ??float_conversion_13
    260                while (--i > integral_10_log && nr_of_digits)
    261                {
    262                  *buf_pointer++ = '0';
   \                     ??float_conversion_14:
   \   000000F6   ....               RCALL   ?Subroutine6
    263                  nr_of_digits--;
   \                     ??CrossCallReturnLabel_30:
   \   000000F8   EF0F               LDI     R16, 255
   \   000000FA   0EE0               ADD     R14, R16
   \   000000FC   1EF0               ADC     R15, R16
    264                }
   \                     ??float_conversion_13:
   \   000000FE   EF0F               LDI     R16, 255
   \   00000100   0E60               ADD     R6, R16
   \   00000102   1E70               ADC     R7, R16
   \   00000104   1486               CP      R8, R6
   \   00000106   0497               CPC     R9, R7
   \   00000108   F41C               BRGE    ??float_conversion_15
   \   0000010A   2D0E               MOV     R16, R14
   \   0000010C   290F               OR      R16, R15
   \   0000010E   F799               BRNE    ??float_conversion_14
    265                if (integral_10_log < (-n - 1))
   \                     ??float_conversion_15:
   \   00000110   9440               COM     R4
   \   00000112   9450               COM     R5
   \   00000114   1484               CP      R8, R4
   \   00000116   0495               CPC     R9, R5
   \   00000118   F40C               BRGE    $+2+2
   \   0000011A   C075               RJMP    ??float_conversion_16
    266                {
    267                  goto CLEAN_UP;     /* Nothing more to do */
    268                }
    269                dec_point_pos = 1;
   \   0000011C   2477               CLR     R7
   \   0000011E   2466               CLR     R6
   \   00000120   9463               INC     R6
   \   00000122   C026               RJMP    ??CrossCallReturnLabel_26
    270              }
    271              else
    272              {
    273                // Для чисел больших по абсолютному значению чем 1 в представлении без экспоненты
    274                dec_point_pos = - integral_10_log;
   \                     ??float_conversion_11:
   \   00000124   0134               MOVW    R7:R6, R9:R8
   \   00000126   9471               NEG     R7
   \   00000128   9461               NEG     R6
   \   0000012A   E000               LDI     R16, 0
   \   0000012C   0A70               SBC     R7, R16
   \   0000012E   C020               RJMP    ??CrossCallReturnLabel_26
    275              }
    276            }
    277          
    278            i = dec_point_pos;
    279            while (i <= nr_of_digits )
    280            {
    281              n = (short)value;
   \                     ??float_conversion_17:
   \   00000130   ....               RCALL   ?F2SL_L04
   \   00000132   2E40               MOV     R4, R16
    282              value = value - n;          /* n=Digit value=Remainder */
    283              value = value * 10;         /* Prepare for next shot */
   \   00000134   2F21               MOV     R18, R17
   \   00000136   0F22               LSL     R18
   \   00000138   0B22               SBC     R18, R18
   \   0000013A   2F32               MOV     R19, R18
   \   0000013C   ....               RCALL   ?SL2F_L04
   \   0000013E   01A8               MOVW    R21:R20, R17:R16
   \   00000140   01B9               MOVW    R23:R22, R19:R18
   \   00000142   ....               RCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_6:
   \   00000144   ....               RCALL   ?F_SUB_L04
   \   00000146   ....               RCALL   ?Subroutine9
   \                     ??CrossCallReturnLabel_12:
   \   00000148   ....               RCALL   ?Subroutine0
    284              *buf_pointer++ = n + '0';
   \                     ??CrossCallReturnLabel_20:
   \   0000014A   2D04               MOV     R16, R4
   \   0000014C   5D00               SUBI    R16, 208
   \   0000014E   01F6               MOVW    R31:R30, R13:R12
   \   00000150   ....               RCALL   ??Subroutine11_0
    285              if ( ! i++ && (nr_of_digits || alternate_flag))
   \                     ??CrossCallReturnLabel_25:
   \   00000152   0193               MOVW    R19:R18, R7:R6
   \   00000154   E001               LDI     R16, 1
   \   00000156   0E60               ADD     R6, R16
   \   00000158   E000               LDI     R16, 0
   \   0000015A   1E70               ADC     R7, R16
   \   0000015C   2B23               OR      R18, R19
   \   0000015E   F441               BRNE    ??CrossCallReturnLabel_26
   \   00000160   2D0E               MOV     R16, R14
   \   00000162   290F               OR      R16, R15
   \   00000164   F419               BRNE    ??float_conversion_18
   \   00000166   890A               LDD     R16, Y+18
   \   00000168   2300               TST     R16
   \   0000016A   F011               BREQ    ??CrossCallReturnLabel_26
    286              {
    287                *buf_pointer++ = '.';
   \                     ??float_conversion_18:
   \   0000016C   E20E               LDI     R16, 46
   \   0000016E   ....               RCALL   ??Subroutine11_0
    288              }
    289            } // while
   \                     ??CrossCallReturnLabel_26:
   \   00000170   14E6               CP      R14, R6
   \   00000172   04F7               CPC     R15, R7
   \   00000174   ....               RCALL   ?Subroutine4
   \                     ??CrossCallReturnLabel_7:
   \   00000176   F6E4               BRGE    ??float_conversion_17
    290            
    291            if (value >= 5)    /* Rounding possible */
   \   00000178   ....               RCALL   ?Subroutine9
   \                     ??CrossCallReturnLabel_13:
   \   0000017A   EA60               LDI     R22, 160
   \   0000017C   E470               LDI     R23, 64
   \   0000017E   ....               RCALL   ?F_CMP_GE_L04
   \   00000180   F008               BRCS    $+2+2
   \   00000182   C041               RJMP    ??float_conversion_16
    292            {
    293              n = 1;    /* Carry */
   \   00000184   2444               CLR     R4
   \   00000186   9443               INC     R4
    294              cp = buf_pointer - 1;
   \   00000188   01C6               MOVW    R25:R24, R13:R12
   \   0000018A   9701               SBIW    R25:R24, 1
    295              do
    296              {
    297                if (*cp != '.')
   \                     ??float_conversion_19:
   \   0000018C   01FC               MOVW    R31:R30, R25:R24
   \   0000018E   8100               LD      R16, Z
   \   00000190   320E               CPI     R16, 46
   \   00000192   F051               BREQ    ??float_conversion_20
    298                  if ( (*cp += n) == ('9' + 1) )
   \   00000194   0D04               ADD     R16, R4
   \   00000196   8300               ST      Z, R16
   \   00000198   330A               CPI     R16, 58
   \   0000019A   F429               BRNE    ??float_conversion_21
    299                  {
    300                    *cp = '0';
   \   0000019C   E300               LDI     R16, 48
   \   0000019E   8300               ST      Z, R16
    301                    n = 1;
   \   000001A0   2444               CLR     R4
   \   000001A2   9443               INC     R4
   \   000001A4   C001               RJMP    ??float_conversion_20
    302                  }
    303                  else
    304                  {
    305                    n = 0;
   \                     ??float_conversion_21:
   \   000001A6   2444               CLR     R4
    306                  }
    307              } while (cp-- > buf);
   \                     ??float_conversion_20:
   \   000001A8   9701               SBIW    R25:R24, 1
   \   000001AA   16AE               CP      R10, R30
   \   000001AC   06BF               CPC     R11, R31
   \   000001AE   F370               BRCS    ??float_conversion_19
    308              if (n)
   \   000001B0   FA40               BST     R4, 0
   \   000001B2   F54E               BRTC    ??float_conversion_16
    309              {
    310                if (format_flag)        /* %e or %E */
   \   000001B4   8908               LDD     R16, Y+16
   \   000001B6   2300               TST     R16
   \   000001B8   F0B1               BREQ    ??float_conversion_22
    311                {
    312                  cp = buf_pointer;
   \   000001BA   01C6               MOVW    R25:R24, R13:R12
   \   000001BC   C002               RJMP    ??float_conversion_23
    313                  while (cp > buf)
    314                  {
    315                    if (*(cp - 1) == '.')
    316                    {
    317                      *cp = *(cp - 2);
    318                      cp--;
    319                    }
    320                    else
    321                    {
    322                      *cp = *(cp - 1);
   \                     ??float_conversion_24:
   \   000001BE   8300               ST      Z, R16
    323                    }
    324                    cp--;
   \                     ??float_conversion_25:
   \   000001C0   9701               SBIW    R25:R24, 1
   \                     ??float_conversion_23:
   \   000001C2   16A8               CP      R10, R24
   \   000001C4   06B9               CPC     R11, R25
   \   000001C6   F458               BRCC    ??float_conversion_26
   \   000001C8   01FC               MOVW    R31:R30, R25:R24
   \   000001CA   9102               LD      R16, -Z
   \   000001CC   320E               CPI     R16, 46
   \   000001CE   01FC               MOVW    R31:R30, R25:R24
   \   000001D0   F7B1               BRNE    ??float_conversion_24
   \   000001D2   9732               SBIW    R31:R30, 2
   \   000001D4   8100               LD      R16, Z
   \   000001D6   01FC               MOVW    R31:R30, R25:R24
   \   000001D8   8300               ST      Z, R16
   \   000001DA   9701               SBIW    R25:R24, 1
   \   000001DC   CFF1               RJMP    ??float_conversion_25
    325                  }
    326                  integral_10_log++;
   \                     ??float_conversion_26:
   \   000001DE   E001               LDI     R16, 1
   \   000001E0   0E80               ADD     R8, R16
   \   000001E2   1E94               ADC     R9, R20
   \   000001E4   C00D               RJMP    ??float_conversion_27
    327                }
    328                else
    329                {
    330                  cp = ++buf_pointer;
   \                     ??float_conversion_22:
   \   000001E6   E001               LDI     R16, 1
   \   000001E8   0EC0               ADD     R12, R16
   \   000001EA   1ED4               ADC     R13, R20
   \   000001EC   01C6               MOVW    R25:R24, R13:R12
   \   000001EE   C005               RJMP    ??float_conversion_28
    331                  while (cp > buf)
    332                  {
    333                    *cp = *(cp - 1);
   \                     ??float_conversion_29:
   \   000001F0   01FC               MOVW    R31:R30, R25:R24
   \   000001F2   9102               LD      R16, -Z
   \   000001F4   01FC               MOVW    R31:R30, R25:R24
   \   000001F6   8300               ST      Z, R16
    334                    cp--;
   \   000001F8   9701               SBIW    R25:R24, 1
    335                  }
   \                     ??float_conversion_28:
   \   000001FA   16A8               CP      R10, R24
   \   000001FC   06B9               CPC     R11, R25
   \   000001FE   F3C0               BRCS    ??float_conversion_29
    336                }
    337                *buf = '1';
   \                     ??float_conversion_27:
   \   00000200   01F5               MOVW    R31:R30, R11:R10
   \   00000202   E301               LDI     R16, 49
   \   00000204   8300               ST      Z, R16
    338              }
    339            }
    340          CLEAN_UP:
    341            if (g_flag)            /* %G - Remove trailing zeros */
   \                     ??float_conversion_16:
   \   00000206   8909               LDD     R16, Y+17
   \   00000208   2300               TST     R16
   \   0000020A   F421               BRNE    ??float_conversion_30
   \   0000020C   C00C               RJMP    ??float_conversion_31
    342            {
    343              while (*(buf_pointer - 1) == '0')
    344              {
    345                buf_pointer--;
   \                     ??float_conversion_32:
   \   0000020E   EF0F               LDI     R16, 255
   \   00000210   0EC0               ADD     R12, R16
   \   00000212   1ED0               ADC     R13, R16
    346              }
   \                     ??float_conversion_30:
   \   00000214   01F6               MOVW    R31:R30, R13:R12
   \   00000216   9102               LD      R16, -Z
   \   00000218   3300               CPI     R16, 48
   \   0000021A   F3C9               BREQ    ??float_conversion_32
    347              if (*(buf_pointer - 1) == '.')
   \   0000021C   320E               CPI     R16, 46
   \   0000021E   F419               BRNE    ??float_conversion_31
    348              {
    349                buf_pointer--;
   \   00000220   EF0F               LDI     R16, 255
   \   00000222   0EC0               ADD     R12, R16
   \   00000224   1ED0               ADC     R13, R16
    350              }
    351            }
    352            if (format_flag)        /* %e or %E */
   \                     ??float_conversion_31:
   \   00000226   8908               LDD     R16, Y+16
   \   00000228   2300               TST     R16
   \   0000022A   F1C1               BREQ    ??float_conversion_33
    353            {
    354              *buf_pointer++ = format_flag;
   \   0000022C   01F6               MOVW    R31:R30, R13:R12
   \   0000022E   9301               ST      Z+, R16
    355              if (integral_10_log < 0)
   \   00000230   2099               TST     R9
   \   00000232   F43A               BRPL    ??float_conversion_34
    356              {
    357                *buf_pointer++ = '-';
   \   00000234   E20D               LDI     R16, 45
   \   00000236   ....               RCALL   ??Subroutine11_0
    358                integral_10_log = -integral_10_log;
   \                     ??CrossCallReturnLabel_27:
   \   00000238   9491               NEG     R9
   \   0000023A   9481               NEG     R8
   \   0000023C   E000               LDI     R16, 0
   \   0000023E   0A90               SBC     R9, R16
   \   00000240   C002               RJMP    ??CrossCallReturnLabel_28
    359              }
    360              else
    361              {
    362                *buf_pointer++ = '+';
   \                     ??float_conversion_34:
   \   00000242   E20B               LDI     R16, 43
   \   00000244   ....               RCALL   ??Subroutine11_0
    363              }
    364              n = 0;
   \                     ??CrossCallReturnLabel_28:
   \   00000246   2444               CLR     R4
   \   00000248   2455               CLR     R5
    365              buf_pointer +=3;
   \   0000024A   E003               LDI     R16, 3
   \   0000024C   0EC0               ADD     R12, R16
   \   0000024E   1CD4               ADC     R13, R4
    366              do
    367              {
    368                n++;
   \                     ??float_conversion_35:
   \   00000250   E001               LDI     R16, 1
   \   00000252   0E40               ADD     R4, R16
   \   00000254   E000               LDI     R16, 0
   \   00000256   1E50               ADC     R5, R16
    369                *buf_pointer++ = (integral_10_log % 10) + '0'; // Запись в буфер цифр экспоненты
   \   00000258   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_2:
   \   0000025A   5D40               SUBI    R20, 208
   \   0000025C   01F6               MOVW    R31:R30, R13:R12
   \   0000025E   9341               ST      Z+, R20
   \   00000260   016F               MOVW    R13:R12, R31:R30
    370                integral_10_log /= 10;
   \   00000262   ....               RCALL   ?Subroutine2
    371              } while ( integral_10_log || n < 2 );
   \                     ??CrossCallReturnLabel_3:
   \   00000264   0148               MOVW    R9:R8, R17:R16
   \   00000266   2B01               OR      R16, R17
   \   00000268   F799               BRNE    ??float_conversion_35
   \   0000026A   E002               LDI     R16, 2
   \   0000026C   1640               CP      R4, R16
   \   0000026E   E000               LDI     R16, 0
   \   00000270   0650               CPC     R5, R16
   \   00000272   F374               BRLT    ??float_conversion_35
    372              for ( i = n ; n > 0 ; n-- )
   \   00000274   0132               MOVW    R7:R6, R5:R4
   \   00000276   01C2               MOVW    R25:R24, R5:R4
    373                *(buf_pointer - 4 - i + n) = *(buf_pointer - n);
   \                     ??float_conversion_36:
   \   00000278   0182               MOVW    R17:R16, R5:R4
   \   0000027A   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_0:
   \   0000027C   8120               LD      R18, Z
   \   0000027E   0183               MOVW    R17:R16, R7:R6
   \   00000280   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   00000282   0DE4               ADD     R30, R4
   \   00000284   1DF5               ADC     R31, R5
   \   00000286   9734               SBIW    R31:R30, 4
   \   00000288   8320               ST      Z, R18
   \   0000028A   EF0F               LDI     R16, 255
   \   0000028C   0E40               ADD     R4, R16
   \   0000028E   1E50               ADC     R5, R16
   \   00000290   9701               SBIW    R25:R24, 1
   \   00000292   F791               BRNE    ??float_conversion_36
    374              buf_pointer -= 3;
   \   00000294   EF0D               LDI     R16, 253
   \   00000296   0EC0               ADD     R12, R16
   \   00000298   EF0F               LDI     R16, 255
   \   0000029A   1ED0               ADC     R13, R16
    375            }
    376            *buf_pointer=0;
   \                     ??float_conversion_33:
   \   0000029C   01F6               MOVW    R31:R30, R13:R12
   \   0000029E   E000               LDI     R16, 0
   \   000002A0   8300               ST      Z, R16
    377            return buf_pointer;
   \   000002A2   0186               MOVW    R17:R16, R13:R12
   \   000002A4   E1E3               LDI     R30, 19
   \   000002A6   ....               RJMP    ?EPILOGUE_B16_L09
    378          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   EF49               LDI     R20, 249
   \   00000002   E052               LDI     R21, 2
   \   00000004   E165               LDI     R22, 21
   \   00000006   E570               LDI     R23, 80
   \   00000008   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   ....               RCALL   ?F_DIV_L04
   \   00000002                      REQUIRE ?Subroutine10
   \   00000002                      ;               // Fall through to label ?Subroutine10

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   00000000   01C8               MOVW    R25:R24, R17:R16
   \   00000002   01D9               MOVW    R27:R26, R19:R18
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   01F6               MOVW    R31:R30, R13:R12
   \   00000002   E300               LDI     R16, 48
   \   00000004                      REQUIRE ??Subroutine11_0
   \   00000004                      ;               // Fall through to label ??Subroutine11_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine11_0:
   \   00000000   9301               ST      Z+, R16
   \   00000002   016F               MOVW    R13:R12, R31:R30
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   018C               MOVW    R17:R16, R25:R24
   \   00000002   019D               MOVW    R19:R18, R27:R26
   \   00000004   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   018C               MOVW    R17:R16, R25:R24
   \   00000002   019D               MOVW    R19:R18, R27:R26
   \   00000004                      REQUIRE ?Subroutine9
   \   00000004                      ;               // Fall through to label ?Subroutine9

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   E04A               LDI     R20, 10
   \   00000002   E050               LDI     R21, 0
   \   00000004   0184               MOVW    R17:R16, R9:R8
   \   00000006   ....               RJMP    ?SS_DIVMOD_L02

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   9511               NEG     R17
   \   00000002   9501               NEG     R16
   \   00000004   4010               SBCI    R17, 0
   \   00000006   01F6               MOVW    R31:R30, R13:R12
   \   00000008   0FE0               ADD     R30, R16
   \   0000000A   1FF1               ADC     R31, R17
   \   0000000C   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   E260               LDI     R22, 32
   \   00000002   E471               LDI     R23, 65
   \   00000004   ....               RCALL   ?F_MUL_L04
   \   00000006   ....               RJMP    ?Subroutine10

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      6      2   GetBlockCRC
        6      2   -> GetCRC
      0      2   GetCRC
     20      2   Num_to_str
       16      2   -> hex_to_ascii
       16      2   -> ldiv
       16      2 ?SS_DIVMOD_L02
      4      2   Right_align_str
      0      2   Str_to_byte
        0      2   -> ascii_to_hex
      0      2   Str_to_num
        0      2   -> ascii_to_hex
        0      2 ?L_EC_MUL_L03
      0      2   ascii_to_hex
     19      2   float_conversion
       19      2 ?F2SL_L04
       19      2 ?F_CMP_GE_L04
       19      2 ?F_CMP_LT_L04
       19      4 ?F_DIV_L04
       19      2 ?F_MUL_L04
       19      4 ?F_MUL_L04
       19      2 ?F_SUB_L04
       19      2 ?SL2F_L04
       19      2 ?SS_DIVMOD_L02
      0      2   hex_to_ascii
      0      2   is_hex_digit
      0      2   write_ascii


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ??Subroutine11_0
       8  ?Subroutine0
      14  ?Subroutine1
       6  ?Subroutine10
       8  ?Subroutine2
       4  ?Subroutine3
       6  ?Subroutine4
       8  ?Subroutine5
       4  ?Subroutine6
       2  ?Subroutine7
      10  ?Subroutine8
       6  ?Subroutine9
      52  GetBlockCRC
      30  GetCRC
     166  Num_to_str
      92  Right_align_str
      20  Str_to_byte
      48  Str_to_num
      26  ascii_to_hex
     680  float_conversion
      14  hex_to_ascii
      30  is_hex_digit
       8  write_ascii

 
 1 248 bytes in segment CODE
 
 1 248 bytes of CODE memory

Errors: none
Warnings: none
