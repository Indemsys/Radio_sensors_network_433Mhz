###############################################################################
#
# IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR       26/Oct/2021  16:53:18
# Copyright 1996-2021 IAR Systems AB.
#
#    Source file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\lcd.c
#    Command line =  
#        -f C:\Users\aly\AppData\Local\Temp\EW686B.tmp
#        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\lcd.c
#        --cpu=m8 -ms -o
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\Obj
#        -lCN
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List
#        -lB
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List
#        --initializers_in_flash --debug -DENABLE_BIT_DEFINITIONS -e
#        --eeprom_size 512 --clib -Ohz)
#    Locale       =  Russian_RUS.1251
#    List file    =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List\lcd.lst
#    Object file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\Obj\lcd.r90
#
###############################################################################

D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\lcd.c
      1          #include <iom8.h>

   \                                 In  segment ABSOLUTE, at 0x35
   \   union <unnamed> volatile __io _A_PORTC
   \                     _A_PORTC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x34
   \   union <unnamed> volatile __io _A_DDRC
   \                     _A_DDRC:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x32
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x31
   \   union <unnamed> volatile __io _A_DDRD
   \                     _A_DDRD:
   \   00000000                      DS8 1

   \                                 In  segment ABSOLUTE, at 0x30
   \   union <unnamed> volatile __io _A_PIND
   \                     _A_PIND:
   \   00000000                      DS8 1
      2          #include <ina90.h>
      3          #include <string.h>
      4          #include <pgmspace.h>
      5          #include <stdio.h>
      6          #include "main.h"
      7          #include "USART.h"
      8          #include "Monitor.h"
      9          #include "Wrk_params.h"
     10          #include "Timers.h"
     11          #include "..\PRG_Transmitter\RF_settings.h"
     12          #include "RF_receiver.h"
     13          #include "Util.h"
     14          #include "bin_defines.h"
     15          #include "lcd.h"
     16          
     17          #define LCD_CTRL_PORT PORTC
     18          #define LCD_CTRL_DDR  DDRC
     19          
     20          #define LCD_DATA_POUT PORTD
     21          #define LCD_DATA_DDR  DDRD
     22          #define LCD_DATA_PIN  PIND
     23          
     24          #define LCD_CTRL_RS   P_RS
     25          #define LCD_CTRL_RW   P_RW
     26          #define LCD_CTRL_E    P_E
     27          
     28          #define sbi(ADDRESS,BIT)   ((ADDRESS) |= (BIT))
     29          #define cbi(ADDRESS,BIT)   ((ADDRESS) &= ~(BIT))
     30          #define outb(ADDRESS,BYTE) ((ADDRESS) = BYTE)
     31          #define inb(ADDRESS)        (ADDRESS)
     32          
     33          
     34          #define LCD_LINE0_DDRAMADDR 0
     35          #define LCD_LINE1_DDRAMADDR 40
     36          #define LCD_LINE2_DDRAMADDR 0
     37          #define LCD_LINE3_DDRAMADDR 40
     38          
     39          #define LCD_DELAY   asm ("nop"); asm ("nop")
     40          

   \                                 In  segment CODE, align 2, keep-with-next
     41          void lcdInitHW(void)
   \                     lcdInitHW:
     42          {
     43            // initialize I/O ports
     44            // if I/O interface is in use
     45            // initialize LCD control lines
     46            cbi(LCD_CTRL_PORT, LCD_CTRL_RS);
   \   00000000   98A8               CBI     0x15, 0x00
     47            cbi(LCD_CTRL_PORT, LCD_CTRL_RW);
   \   00000002   98A9               CBI     0x15, 0x01
     48            cbi(LCD_CTRL_PORT, LCD_CTRL_E);
   \   00000004   98AA               CBI     0x15, 0x02
     49            // initialize LCD control lines to output
     50            sbi(LCD_CTRL_DDR, LCD_CTRL_RS);
   \   00000006   9AA0               SBI     0x14, 0x00
     51            sbi(LCD_CTRL_DDR, LCD_CTRL_RW);
   \   00000008   9AA1               SBI     0x14, 0x01
     52            sbi(LCD_CTRL_DDR, LCD_CTRL_E);
   \   0000000A   9AA2               SBI     0x14, 0x02
     53            // initialize LCD data port to input
     54            // initialize LCD data lines to pull-up
     55            outb(LCD_DATA_DDR,  inb(LCD_DATA_DDR) & 0x0F);   // set data I/O lines to input (4bit)
   \   0000000C   ....               RJMP    ??Subroutine5_0
   \   0000000E                      REQUIRE _A_PORTC
   \   0000000E                      REQUIRE _A_DDRC
   \   0000000E                      REQUIRE _A_DDRD
   \   0000000E                      REQUIRE _A_PORTD
     56            outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)| 0xF0);   // set pull-ups to on (4bit)
     57          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   BB02               OUT     0x12, R16
   \   00000002   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine5_0:
   \   00000000   B301               IN      R16, 0x11
   \   00000002   700F               ANDI    R16, 0x0F
   \   00000004   BB01               OUT     0x11, R16
   \   00000006   B302               IN      R16, 0x12
   \   00000008   6F00               ORI     R16, 0xF0
   \   0000000A   ....               RJMP    ?Subroutine4
     58          

   \                                 In  segment CODE, align 2, keep-with-next
     59          void lcdBusyWait(void)
   \                     lcdBusyWait:
     60          {
     61            // wait until LCD busy bit goes to zero
     62            // do a read from control register
     63            cbi(LCD_CTRL_PORT, LCD_CTRL_RS);        // set RS to "control"
   \   00000000   98A8               CBI     0x15, 0x00
     64            outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)  & 0x0F); // set data I/O lines to input (4bit)
   \   00000002   ....               RCALL   ??Subroutine5_0
     65            outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)| 0xF0); // set pull-ups to on (4bit)
     66            sbi(LCD_CTRL_PORT, LCD_CTRL_RW);        // set R/W to "read"
   \                     ??CrossCallReturnLabel_2:
   \   00000004   9AA9               SBI     0x15, 0x01
     67            sbi(LCD_CTRL_PORT, LCD_CTRL_E);         // set "E" line
   \   00000006   9AAA               SBI     0x15, 0x02
     68            LCD_DELAY;                // wait
   \   00000008   0000               nop
   \   0000000A   0000               nop
   \   0000000C   C014               RJMP    ??lcdBusyWait_0
     69            while(inb(LCD_DATA_PIN) & 1<<LCD_BUSY)
     70            {
     71              cbi(LCD_CTRL_PORT, LCD_CTRL_E);   // clear "E" line
   \                     ??lcdBusyWait_1:
   \   0000000E   98AA               CBI     0x15, 0x02
     72              LCD_DELAY;                  // wait
   \   00000010   0000               nop
   \   00000012   0000               nop
     73              LCD_DELAY;                  // wait
   \   00000014   0000               nop
   \   00000016   0000               nop
     74              sbi(LCD_CTRL_PORT, LCD_CTRL_E);   // set "E" line
   \   00000018   9AAA               SBI     0x15, 0x02
     75              LCD_DELAY;                  // wait
   \   0000001A   0000               nop
   \   0000001C   0000               nop
     76              LCD_DELAY;                  // wait
   \   0000001E   0000               nop
   \   00000020   0000               nop
     77              cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
   \   00000022   98AA               CBI     0x15, 0x02
     78              LCD_DELAY;                // wait
   \   00000024   0000               nop
   \   00000026   0000               nop
     79              LCD_DELAY;                // wait
   \   00000028   0000               nop
   \   0000002A   0000               nop
     80              sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
   \   0000002C   9AAA               SBI     0x15, 0x02
     81              LCD_DELAY;                // wait
   \   0000002E   0000               nop
   \   00000030   0000               nop
     82              LCD_DELAY;                // wait
   \   00000032   0000               nop
   \   00000034   0000               nop
     83            }
   \                     ??lcdBusyWait_0:
   \   00000036   9987               SBIC    0x10, 0x07
   \   00000038   CFEA               RJMP    ??lcdBusyWait_1
     84            cbi(LCD_CTRL_PORT, LCD_CTRL_E);     // clear "E" line
   \   0000003A   98AA               CBI     0x15, 0x02
     85            //  leave data lines in input mode so they can be most easily used for other purposes
     86          }
   \   0000003C   9508               RET
   \   0000003E                      REQUIRE _A_PORTC
   \   0000003E                      REQUIRE _A_DDRD
   \   0000003E                      REQUIRE _A_PORTD
   \   0000003E                      REQUIRE _A_PIND
     87          

   \                                 In  segment CODE, align 2, keep-with-next
     88          void lcdControlWrite(unsigned char data)
   \                     lcdControlWrite:
     89          {
   \   00000000   2F20               MOV     R18, R16
     90          // write the control byte to the display controller
     91            lcdBusyWait();              // wait until LCD not busy
   \   00000002   ....               RCALL   lcdBusyWait
     92            cbi(LCD_CTRL_PORT, LCD_CTRL_RS);      // set RS to "control"
   \   00000004   98A8               CBI     0x15, 0x00
     93            cbi(LCD_CTRL_PORT, LCD_CTRL_RW);      // set R/W to "write"
   \   00000006   ....               RCALL   ?Subroutine1
     94              // 4 bit write
     95            sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
     96            outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)|0xF0); // set data I/O lines to output (4bit)
     97            outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&0x0F) | (data&0xF0) );  // output data, high 4 bits
     98            LCD_DELAY;                // wait
   \                     ??CrossCallReturnLabel_0:
   \   00000008   0000               nop
   \   0000000A   0000               nop
     99            LCD_DELAY;                // wait
   \   0000000C   0000               nop
   \   0000000E   0000               nop
    100            cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
   \   00000010   98AA               CBI     0x15, 0x02
    101            LCD_DELAY;                // wait
   \   00000012   0000               nop
   \   00000014   0000               nop
    102            LCD_DELAY;                // wait
   \   00000016   0000               nop
   \   00000018   0000               nop
    103            sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
   \   0000001A   ....               RCALL   ?Subroutine2
    104            outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&0x0F) | (data<<4) );  // output data, low 4 bits
    105            LCD_DELAY;                // wait
   \                     ??CrossCallReturnLabel_5:
   \   0000001C   0000               nop
   \   0000001E   0000               nop
    106            LCD_DELAY;                // wait
   \   00000020   0000               nop
   \   00000022   0000               nop
    107            cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
   \   00000024   ....               RJMP    ?Subroutine0
   \   00000026                      REQUIRE _A_PORTC
   \   00000026                      REQUIRE _A_DDRD
   \   00000026                      REQUIRE _A_PORTD
    108            //  leave data lines in input mode so they can be most easily used for other purposes
    109            outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);   // set data I/O lines to input (4bit)
    110            outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0); // set pull-ups to on (4bit)
    111          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   9AAA               SBI     0x15, 0x02
   \   00000002   B302               IN      R16, 0x12
   \   00000004   700F               ANDI    R16, 0x0F
   \   00000006   9522               SWAP    R18
   \   00000008   7F20               ANDI    R18, 0xF0
   \   0000000A   2B02               OR      R16, R18
   \   0000000C                      REQUIRE ?Subroutine4
   \   0000000C                      ;               // Fall through to label ?Subroutine4

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   98A9               CBI     0x15, 0x01
   \   00000002   9AAA               SBI     0x15, 0x02
   \   00000004   B301               IN      R16, 0x11
   \   00000006   6F00               ORI     R16, 0xF0
   \   00000008   BB01               OUT     0x11, R16
   \   0000000A   B312               IN      R17, 0x12
   \   0000000C   701F               ANDI    R17, 0x0F
   \   0000000E   2F02               MOV     R16, R18
   \   00000010   7F00               ANDI    R16, 0xF0
   \   00000012   2B10               OR      R17, R16
   \   00000014   BB12               OUT     0x12, R17
   \   00000016   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   98AA               CBI     0x15, 0x02
   \   00000002                      REQUIRE ??Subroutine5_0
   \   00000002                      ;               // Fall through to label ??Subroutine5_0
    112          

   \                                 In  segment CODE, align 2, keep-with-next
    113          unsigned char lcdControlRead(void)
   \                     lcdControlRead:
    114          {
    115          // read the control byte from the display controller
    116            register unsigned char data;
    117            lcdBusyWait();        // wait until LCD not busy
   \   00000000   ....               RCALL   lcdBusyWait
    118            outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);   // set data I/O lines to input (4bit)
   \   00000002   ....               RCALL   ??Subroutine5_0
    119            outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0); // set pull-ups to on (4bit)
    120            cbi(LCD_CTRL_PORT, LCD_CTRL_RS);    // set RS to "control"
   \                     ??CrossCallReturnLabel_3:
   \   00000004   98A8               CBI     0x15, 0x00
    121            sbi(LCD_CTRL_PORT, LCD_CTRL_RW);    // set R/W to "read"
   \   00000006   9AA9               SBI     0x15, 0x01
    122            // 4 bit read
    123            sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
   \   00000008   9AAA               SBI     0x15, 0x02
    124            LCD_DELAY;            // wait
   \   0000000A   0000               nop
   \   0000000C   0000               nop
    125            LCD_DELAY;            // wait
   \   0000000E   0000               nop
   \   00000010   0000               nop
    126            data = inb(LCD_DATA_PIN)&0xF0;  // input data, high 4 bits
   \   00000012   B300               IN      R16, 0x10
    127            cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
   \   00000014   98AA               CBI     0x15, 0x02
    128            LCD_DELAY;            // wait
   \   00000016   0000               nop
   \   00000018   0000               nop
    129            LCD_DELAY;            // wait
   \   0000001A   0000               nop
   \   0000001C   0000               nop
    130            sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
   \   0000001E   9AAA               SBI     0x15, 0x02
    131            LCD_DELAY;            // wait
   \   00000020   0000               nop
   \   00000022   0000               nop
    132            LCD_DELAY;            // wait
   \   00000024   0000               nop
   \   00000026   0000               nop
    133            data |= inb(LCD_DATA_PIN)>>4; // input data, low 4 bits
   \   00000028   ....               RJMP    ?Subroutine3
   \   0000002A                      REQUIRE _A_DDRD
   \   0000002A                      REQUIRE _A_PORTD
   \   0000002A                      REQUIRE _A_PORTC
   \   0000002A                      REQUIRE _A_PIND
    134            cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
    135            //  leave data lines in input mode so they can be most easily used for other purposes
    136            return data;
    137          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   B310               IN      R17, 0x10
   \   00000002   98AA               CBI     0x15, 0x02
   \   00000004   7F00               ANDI    R16, 0xF0
   \   00000006   9512               SWAP    R17
   \   00000008   701F               ANDI    R17, 0x0F
   \   0000000A   2B01               OR      R16, R17
   \   0000000C   9508               RET
    138          

   \                                 In  segment CODE, align 2, keep-with-next
    139          void lcdDataWrite(unsigned char data)
   \                     lcdDataWrite:
    140          {
   \   00000000   2F20               MOV     R18, R16
    141          // write a data byte to the display
    142            lcdBusyWait();              // wait until LCD not busy
   \   00000002   ....               RCALL   lcdBusyWait
    143            sbi(LCD_CTRL_PORT, LCD_CTRL_RS);    // set RS to "data"
   \   00000004   9AA8               SBI     0x15, 0x00
    144            cbi(LCD_CTRL_PORT, LCD_CTRL_RW);    // set R/W to "write"
   \   00000006   ....               RCALL   ?Subroutine1
    145            // 4 bit write
    146            sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
    147            outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)|0xF0); // set data I/O lines to output (4bit)
    148            outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&0x0F) | (data&0xF0) );  // output data, high 4 bits
    149            LCD_DELAY;                // wait
   \                     ??CrossCallReturnLabel_1:
   \   00000008   0000               nop
   \   0000000A   0000               nop
    150            LCD_DELAY;                // wait
   \   0000000C   0000               nop
   \   0000000E   0000               nop
    151            cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
   \   00000010   98AA               CBI     0x15, 0x02
    152            LCD_DELAY;                // wait
   \   00000012   0000               nop
   \   00000014   0000               nop
    153            LCD_DELAY;                // wait
   \   00000016   0000               nop
   \   00000018   0000               nop
    154            sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
   \   0000001A   ....               RCALL   ?Subroutine2
    155            outb(LCD_DATA_POUT, (inb(LCD_DATA_POUT)&0x0F) | (data<<4) );  // output data, low 4 bits
    156            LCD_DELAY;                // wait
   \                     ??CrossCallReturnLabel_6:
   \   0000001C   0000               nop
   \   0000001E   0000               nop
    157            LCD_DELAY;                // wait
   \   00000020   0000               nop
   \   00000022   0000               nop
    158            cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
   \   00000024   ....               RJMP    ?Subroutine0
   \   00000026                      REQUIRE _A_PORTC
   \   00000026                      REQUIRE _A_DDRD
   \   00000026                      REQUIRE _A_PORTD
    159            //  leave data lines in input mode so they can be most easily used for other purposes
    160            outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);   // set data I/O lines to input (4bit)
    161            outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0); // set pull-ups to on (4bit)
    162          }
    163          

   \                                 In  segment CODE, align 2, keep-with-next
    164          unsigned char lcdDataRead(void)
   \                     lcdDataRead:
    165          {
    166          // read a data byte from the display
    167            register unsigned char data;
    168            lcdBusyWait();        // wait until LCD not busy
   \   00000000   ....               RCALL   lcdBusyWait
    169            outb(LCD_DATA_DDR, inb(LCD_DATA_DDR)&0x0F);   // set data I/O lines to input (4bit)
   \   00000002   ....               RCALL   ??Subroutine5_0
    170            outb(LCD_DATA_POUT, inb(LCD_DATA_POUT)|0xF0); // set pull-ups to on (4bit)
    171            sbi(LCD_CTRL_PORT, LCD_CTRL_RS);    // set RS to "data"
   \                     ??CrossCallReturnLabel_4:
   \   00000004   9AA8               SBI     0x15, 0x00
    172            sbi(LCD_CTRL_PORT, LCD_CTRL_RW);    // set R/W to "read"
   \   00000006   9AA9               SBI     0x15, 0x01
    173            // 4 bit read
    174            sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
   \   00000008   9AAA               SBI     0x15, 0x02
    175            LCD_DELAY;                // wait
   \   0000000A   0000               nop
   \   0000000C   0000               nop
    176            LCD_DELAY;                // wait
   \   0000000E   0000               nop
   \   00000010   0000               nop
    177            data = inb(LCD_DATA_PIN)&0xF0;  // input data, high 4 bits
   \   00000012   B300               IN      R16, 0x10
    178            cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
   \   00000014   98AA               CBI     0x15, 0x02
    179            LCD_DELAY;                // wait
   \   00000016   0000               nop
   \   00000018   0000               nop
    180            LCD_DELAY;                // wait
   \   0000001A   0000               nop
   \   0000001C   0000               nop
    181            sbi(LCD_CTRL_PORT, LCD_CTRL_E); // set "E" line
   \   0000001E   9AAA               SBI     0x15, 0x02
    182            LCD_DELAY;                // wait
   \   00000020   0000               nop
   \   00000022   0000               nop
    183            LCD_DELAY;                // wait
   \   00000024   0000               nop
   \   00000026   0000               nop
    184            data |= inb(LCD_DATA_PIN)>>4;     // input data, low 4 bits
   \   00000028                      REQUIRE ?Subroutine3
   \   00000028                      REQUIRE _A_DDRD
   \   00000028                      REQUIRE _A_PORTD
   \   00000028                      REQUIRE _A_PORTC
   \   00000028                      REQUIRE _A_PIND
   \   00000028                      ;               // Fall through to label ?Subroutine3
    185            cbi(LCD_CTRL_PORT, LCD_CTRL_E); // clear "E" line
    186            //  leave data lines in input mode so they can be most easily used for other purposes
    187            return data;
    188          }
    189          
    190          
    191          
    192          /*************************************************************/
    193          /********************* PUBLIC FUNCTIONS **********************/
    194          /*************************************************************/
    195          

   \                                 In  segment CODE, align 2, keep-with-next
    196          void lcdInit()
   \                     lcdInit:
    197          {
    198            // initialize hardware
    199            lcdInitHW();
   \   00000000   ....               RCALL   lcdInitHW
    200            // LCD function set
    201            lcdControlWrite(LCD_FUNCTION_DEFAULT);
   \   00000002   E208               LDI     R16, 40
   \   00000004   ....               RCALL   lcdControlWrite
    202            // clear LCD
    203            lcdControlWrite(1<<LCD_CLR);
   \   00000006   E001               LDI     R16, 1
   \   00000008   ....               RCALL   lcdControlWrite
    204            // set entry mode
    205            lcdControlWrite(1<<LCD_ENTRY_MODE | 1<<LCD_ENTRY_INC);
   \   0000000A   E006               LDI     R16, 6
   \   0000000C   ....               RCALL   lcdControlWrite
    206            // set display to on
    207            //lcdControlWrite(1<<LCD_ON_CTRL | 1<<LCD_ON_DISPLAY | 1<<LCD_ON_BLINK);
    208            lcdControlWrite(1<<LCD_ON_CTRL | 1<<LCD_ON_DISPLAY );
   \   0000000E   E00C               LDI     R16, 12
   \   00000010   ....               RCALL   lcdControlWrite
    209            // move cursor to home
    210            lcdControlWrite(1<<LCD_HOME);
   \   00000012   E002               LDI     R16, 2
   \   00000014   ....               RCALL   lcdControlWrite
    211            // set data address to 0
    212            lcdControlWrite(1<<LCD_DDRAM | 0x00);
   \   00000016   E800               LDI     R16, 128
   \   00000018   ....               RJMP    lcdControlWrite
    213          }
    214          

   \                                 In  segment CODE, align 2, keep-with-next
    215          void lcdHome(void)
   \                     lcdHome:
    216          {
    217            // move cursor to home
    218            lcdControlWrite(1<<LCD_HOME);
   \   00000000   E002               LDI     R16, 2
   \   00000002   ....               RJMP    lcdControlWrite
    219          }
    220          

   \                                 In  segment CODE, align 2, keep-with-next
    221          void lcdClear(void)
   \                     lcdClear:
    222          {
    223            // clear LCD
    224            lcdControlWrite(1<<LCD_CLR);
   \   00000000   E001               LDI     R16, 1
   \   00000002   ....               RJMP    lcdControlWrite
    225          }
    226          

   \                                 In  segment CODE, align 2, keep-with-next
    227          void lcdGotoXY(unsigned char x, unsigned char y)
   \                     lcdGotoXY:
    228          {
    229            register unsigned char DDRAMAddr;
    230          
    231            // remap lines into proper order
    232            switch(y)
   \   00000000   951A               DEC     R17
   \   00000002   F011               BREQ    ??lcdGotoXY_0
   \   00000004   5012               SUBI    R17, 2
   \   00000006   F409               BRNE    ??lcdGotoXY_1
    233            {
    234            case 0: DDRAMAddr = LCD_LINE0_DDRAMADDR+x; break;
    235            case 1: DDRAMAddr = LCD_LINE1_DDRAMADDR+x; break;
    236            case 2: DDRAMAddr = LCD_LINE2_DDRAMADDR+x; break;
    237            case 3: DDRAMAddr = LCD_LINE3_DDRAMADDR+x; break;
   \                     ??lcdGotoXY_0:
   \   00000008   5D08               SUBI    R16, 216
    238            default: DDRAMAddr = LCD_LINE0_DDRAMADDR+x;
    239            }
    240          
    241            // set data address
    242            lcdControlWrite(1<<LCD_DDRAM | DDRAMAddr);
   \                     ??lcdGotoXY_1:
   \   0000000A   6800               ORI     R16, 0x80
   \   0000000C   ....               RJMP    lcdControlWrite
    243          }
    244          
    245          

   \                                 In  segment CODE, align 2, keep-with-next
    246          void lcdPrintData(char* data, unsigned char nBytes)
   \                     lcdPrintData:
    247          {
   \   00000000   01B8               MOVW    R23:R22, R17:R16
   \   00000002   2F32               MOV     R19, R18
    248            register unsigned char i;
    249          
    250            // check to make sure we have a good pointer
    251            if (!data) return;
   \   00000004   2B07               OR      R16, R23
   \   00000006   F059               BREQ    ??lcdPrintData_0
    252          
    253            // print data
    254            for(i=0; i<nBytes; i++)
   \   00000008   E040               LDI     R20, 0
   \   0000000A   E050               LDI     R21, 0
   \   0000000C   C006               RJMP    ??lcdPrintData_1
    255            {
    256              lcdDataWrite(data[i]);
   \                     ??lcdPrintData_2:
   \   0000000E   01FB               MOVW    R31:R30, R23:R22
   \   00000010   0FE4               ADD     R30, R20
   \   00000012   1FF5               ADC     R31, R21
   \   00000014   8100               LD      R16, Z
   \   00000016   ....               RCALL   lcdDataWrite
    257            }
   \   00000018   9543               INC     R20
   \                     ??lcdPrintData_1:
   \   0000001A   1743               CP      R20, R19
   \   0000001C   F3C0               BRCS    ??lcdPrintData_2
    258          }
   \                     ??lcdPrintData_0:
   \   0000001E   9508               RET
    259          

   \                                 In  segment CODE, align 2, keep-with-next
    260          void lcdPrintData_P(char __flash* data)
   \                     lcdPrintData_P:
    261          {
   \   00000000   01F8               MOVW    R31:R30, R17:R16
   \   00000002   C001               RJMP    ??lcdPrintData_P_0
    262            unsigned char ch;
    263          
    264            // print data
    265            do
    266            {
    267              ch = *data++;
    268              if (ch==0) break;
    269              lcdDataWrite(ch);
   \                     ??lcdPrintData_P_1:
   \   00000004   ....               RCALL   lcdDataWrite
    270            }
    271            while (1);
   \                     ??lcdPrintData_P_0:
   \   00000006   9105               LPM     R16, Z+
   \   00000008   2300               TST     R16
   \   0000000A   F7E1               BRNE    ??lcdPrintData_P_1
    272          }
   \   0000000C   9508               RET
    273          
    274          
    275          

   Maximum stack usage in bytes:

   RSTACK Function
   ------ --------
      2   lcdBusyWait
      2   lcdClear
        2   -> lcdControlWrite
      2   lcdControlRead
        2   -> lcdBusyWait
      2   lcdControlWrite
        2   -> lcdBusyWait
      2   lcdDataRead
        2   -> lcdBusyWait
      2   lcdDataWrite
        2   -> lcdBusyWait
      2   lcdGotoXY
        2   -> lcdControlWrite
      2   lcdHome
        2   -> lcdControlWrite
      2   lcdInit
        2   -> lcdControlWrite
        2   -> lcdInitHW
      2   lcdInitHW
      2   lcdPrintData
        2   -> lcdDataWrite
      2   lcdPrintData_P
        2   -> lcdDataWrite


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      12  ??Subroutine5_0
       2  ?Subroutine0
      24  ?Subroutine1
      12  ?Subroutine2
      14  ?Subroutine3
       4  ?Subroutine4
       1  _A_DDRC
       1  _A_DDRD
       1  _A_PIND
       1  _A_PORTC
       1  _A_PORTD
      62  lcdBusyWait
       4  lcdClear
      42  lcdControlRead
      38  lcdControlWrite
      40  lcdDataRead
      38  lcdDataWrite
      14  lcdGotoXY
       4  lcdHome
      26  lcdInit
      14  lcdInitHW
      32  lcdPrintData
      14  lcdPrintData_P

 
   5 bytes in segment ABSOLUTE
 396 bytes in segment CODE
 
 396 bytes of CODE memory
   0 bytes of DATA memory (+ 5 bytes shared)

Errors: none
Warnings: none
