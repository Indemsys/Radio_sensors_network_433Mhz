###############################################################################
#
# IAR C/C++ Compiler V7.30.4.1668 for Microchip AVR       26/Oct/2021  16:53:18
# Copyright 1996-2021 IAR Systems AB.
#
#    Source file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\modbus.c
#    Command line =  
#        -f C:\Users\aly\AppData\Local\Temp\EW6869.tmp
#        (D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\modbus.c
#        --cpu=m8 -ms -o
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\Obj
#        -lCN
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List
#        -lB
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List
#        --initializers_in_flash --debug -DENABLE_BIT_DEFINITIONS -e
#        --eeprom_size 512 --clib -Ohz)
#    Locale       =  Russian_RUS.1251
#    List file    =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\List\modbus.lst
#    Object file  =  
#        D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\Debug\Obj\modbus.r90
#
###############################################################################

D:\Embedded\Projects\OpenSource\Radio_network_433Mhz\PRG_Receiver\modbus.c
      1          #include <iom8.h>
      2          #include <ina90.h>
      3          #include <string.h>
      4          #include <pgmspace.h>
      5          #include <stdio.h>
      6          #include "main.h"
      7          #include "USART.h"
      8          #include "Monitor.h"
      9          #include "Wrk_params.h"
     10          #include "Timers.h"
     11          #include "..\PRG_Transmitter\RF_settings.h"
     12          #include "RF_receiver.h"
     13          #include "Util.h"
     14          #include "bin_defines.h"
     15          #include "lcd.h"
     16          #include "rc4.h"
     17          #include "modbus.h"
     18          
     19          extern D1W_device    nodes_temperatures[MAX_NODES][MAX_DEVICES];
     20          extern unsigned int  nodes_an_inputs[MAX_NODES][MAX_AN_IN]; // Массив состояний аналоговых входов
     21          extern char strbuf[INBUF_LEN];
     22          extern __no_init TPARAMS wp;
     23          
     24          #define STATE_IDLE   0
     25          #define STATE_DATA   1
     26          #define STATE_END    2
     27          

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
     28          static   unsigned char  state=STATE_IDLE;
     29          volatile unsigned int   modb_timeout;
   \                     modb_timeout:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 1
   \   00000005                      DS8 1
     30          static   unsigned int   scnt; // Промежуточный счетчик поступающих байт

   \                                 In  segment NEAR_Z, align 1, keep-with-next
   \   00000000                      REQUIRE `?<Segment init: NEAR_Z>`
   \   00000000                      DS8 1
     31          static   unsigned char  addr; // Адрес полученный из пакета
     32          static   unsigned char  fnum; // Номер функции полученный из пакета
     33          
     34          
     35          
     36          void ascii_mode_task(char ch);
     37          void Read_hld_reg(void);
     38          void Preset_single_register(void);
     39          void Preset_multiple_registers(void);
     40          void Read_EEPROM_reg(void);
     41          void Preset_EEPROM_reg(void);
     42          void Read_reg_type(void);
     43          void Send_read_response(unsigned char *pval,unsigned char nm);
     44          void Send_exception_code(unsigned char exceptc);
     45          unsigned char get_lrc(unsigned char *buf,unsigned int len);
     46          void reset_timeout(void);
     47          

   \                                 In  segment NEAR_F, align 1, keep-with-next
     48          __flash TMODB_tcmd modbus_cmd[]=
   \                     modbus_cmd:
   \   00000000   0003               DC8 3, 0
   \   00000002   ....               DC16 Read_hld_reg/2
   \   00000004   0006               DC8 6, 0
   \   00000006   ....               DC16 Preset_single_register/2
   \   00000008   0110               DC8 16, 1
   \   0000000A   ....               DC16 Preset_multiple_registers/2
   \   0000000C   0041               DC8 65, 0
   \   0000000E   ....               DC16 Read_EEPROM_reg/2
   \   00000010   0042               DC8 66, 0
   \   00000012   ....               DC16 Preset_EEPROM_reg/2
   \   00000014   0043               DC8 67, 0
   \   00000016   ....               DC16 Read_reg_type/2
     49          {
     50            {
     51              3,   // чтение регистра хранения
     52              0,
     53              (void (*)(void)) Read_hld_reg
     54            },
     55            {
     56              6,   // запись регистра хранения
     57              0,
     58              (void (*)(void)) Preset_single_register
     59            },
     60            {
     61              16,   // запись n-регистров хранения
     62              1,
     63              (void (*)(void)) Preset_multiple_registers
     64            },
     65            {
     66              65,   // чтение регистра из EEPROM
     67              0,
     68              (void (*)(void)) Read_EEPROM_reg
     69            },
     70            {
     71              66,   // запись регистра в EEPROM
     72              0,
     73              (void (*)(void)) Preset_EEPROM_reg
     74            },
     75            {
     76              67,   // Чтение типа и длинны регистра хранения
     77              0,
     78              (void (*)(void)) Read_reg_type
     79            },
     80          
     81          };
     82          
     83          #define SIZE_CMD_ARR (sizeof(modbus_cmd)/sizeof(modbus_cmd[0]))
     84          // MODBUS exception codes
     85          #define ILLEGAL_FUNCTION      1
     86          #define ILLEGAL_DATA_ADDRESS  2
     87          #define ILLEGAL_DATA_VALUE    3
     88          #define SLAVE_DEVICES_FAILURE 4
     89          
     90          
     91          

   \                                 In  segment CODE, align 2, keep-with-next
     92          void modbus_task(char ch)
   \                     modbus_task:
     93          {
     94            ascii_mode_task(ch);
   \   00000000   ....               RJMP    ascii_mode_task
     95          }
     96          
     97          
     98          /*--------------------------------------------------------------------------------------
     99             Обработчик MODBUS протокола в режиме ASCII
    100          
    101               +-----+------+------+------+-----+-----+
    102               ¦старт¦адрес ¦ ф-ия ¦данные¦ LRC ¦конец¦
    103               +-----+------+------+------+-----+-----+
    104               ¦1 сим¦2 сим ¦2 сим ¦n сим ¦2 сим¦2 сим¦
    105               ¦   : ¦      ¦      ¦      ¦     ¦CR LF¦
    106               +-----+------+------+------+-----+-----+
    107          
    108          Пример: :010301000003B8
    109          
    110                  :010301000001BA 
    111          
    112                  :010303000006B3 - прочитать 6-ть каналов АЦП с датчика 0 
    113          
    114            --------------------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
    115          void ascii_mode_task(char ch)
   \                     ascii_mode_task:
    116          {
   \   00000000   ....               RCALL   ?PROLOGUE4_L09
   \   00000002   2F20               MOV     R18, R16
    117            unsigned int  i;
    118            unsigned char lrc;
    119            
    120            
    121            if (modb_timeout == 0) state = STATE_IDLE;
   \   00000004   ....               LDI     R26, LOW(modb_timeout)
   \   00000006   ....               LDI     R27, (modb_timeout) >> 8
   \   00000008   910D               LD      R16, X+
   \   0000000A   911C               LD      R17, X
   \   0000000C   9711               SBIW    R27:R26, 1
   \   0000000E   2B01               OR      R16, R17
   \   00000010   F421               BRNE    ??ascii_mode_task_0
   \   00000012   E000               LDI     R16, 0
   \   00000014   9300....           STS     (modb_timeout + 4), R16
   \   00000018   C00E               RJMP    ??ascii_mode_task_1
   \                     ??ascii_mode_task_0:
   \   0000001A   01FD               MOVW    R31:R30, R27:R26
   \   0000001C   8142               LDD     R20, Z+2
   \   0000001E   8153               LDD     R21, Z+3
   \   00000020   ....               RCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_13:
   \   00000022   0F04               ADD     R16, R20
   \   00000024   1F15               ADC     R17, R21
   \   00000026   8134               LDD     R19, Z+4
   \   00000028   2333               TST     R19
   \   0000002A   F029               BREQ    ??ascii_mode_task_1
   \   0000002C   953A               DEC     R19
   \   0000002E   F099               BREQ    ??ascii_mode_task_2
   \   00000030   953A               DEC     R19
   \   00000032   F121               BREQ    ??ascii_mode_task_3
   \   00000034   C060               RJMP    ??ascii_mode_task_4
    122          
    123            switch (state)
    124            {
    125            case STATE_IDLE:
    126              if (ch == ':')
   \                     ??ascii_mode_task_1:
   \   00000036   332A               CPI     R18, 58
   \   00000038   F009               BREQ    $+2+2
   \   0000003A   C05D               RJMP    ??ascii_mode_task_4
    127              {
    128                reset_timeout();
   \   0000003C   E100               LDI     R16, 16
   \   0000003E   E217               LDI     R17, 39
   \   00000040   930D               ST      X+, R16
   \   00000042   931C               ST      X, R17
   \   00000044   9711               SBIW    R27:R26, 1
    129                state = STATE_DATA;
   \   00000046   E001               LDI     R16, 1
   \   00000048   9300....           STS     (modb_timeout + 4), R16
    130                scnt = 0;
   \   0000004C   01FD               MOVW    R31:R30, R27:R26
   \   0000004E   E000               LDI     R16, 0
   \   00000050   8302               STD     Z+2, R16
   \   00000052   8303               STD     Z+3, R16
   \   00000054   C050               RJMP    ??ascii_mode_task_4
    131              }
    132              break;
    133            case STATE_DATA:
    134              reset_timeout();
   \                     ??ascii_mode_task_2:
   \   00000056   ....               RCALL   ?Subroutine4
    135              if (ch == 0x0D)
   \                     ??CrossCallReturnLabel_9:
   \   00000058   302D               CPI     R18, 13
   \   0000005A   F419               BRNE    ??ascii_mode_task_5
    136              {
    137                state = STATE_END;
   \   0000005C   E002               LDI     R16, 2
   \   0000005E   8304               STD     Z+4, R16
    138                break;
   \   00000060   C04A               RJMP    ??ascii_mode_task_4
    139              }
    140              strbuf[scnt] = ch;
   \                     ??ascii_mode_task_5:
   \   00000062   01F8               MOVW    R31:R30, R17:R16
   \   00000064   8320               ST      Z, R18
    141              scnt++;
    142              if (scnt > INBUF_LEN)
   \   00000066   01FD               MOVW    R31:R30, R27:R26
   \   00000068   8102               LDD     R16, Z+2
   \   0000006A   8113               LDD     R17, Z+3
   \   0000006C   5F0F               SUBI    R16, 255
   \   0000006E   4F1F               SBCI    R17, 255
   \   00000070   8302               STD     Z+2, R16
   \   00000072   8313               STD     Z+3, R17
   \   00000074   3605               CPI     R16, 101
   \   00000076   4010               SBCI    R17, 0
   \   00000078   F1F0               BRCS    ??ascii_mode_task_4
   \   0000007A   C03A               RJMP    ??ascii_mode_task_6
    143              {
    144                state = STATE_IDLE;
    145                break;
    146              }
    147          
    148              break;
    149            case STATE_END:
    150              reset_timeout();
   \                     ??ascii_mode_task_3:
   \   0000007C   ....               RCALL   ?Subroutine4
    151          
    152              if (ch == 0x0A)
   \                     ??CrossCallReturnLabel_10:
   \   0000007E   302A               CPI     R18, 10
   \   00000080   F5B9               BRNE    ??ascii_mode_task_6
    153              {
    154                strbuf[scnt] = 0;
   \   00000082   01F8               MOVW    R31:R30, R17:R16
   \   00000084   E020               LDI     R18, 0
   \   00000086   8320               ST      Z, R18
    155                lrc = Str_to_byte((unsigned char *)&strbuf[scnt-2]);
   \   00000088   5002               SUBI    R16, 2
   \   0000008A   4010               SBCI    R17, 0
   \   0000008C   ....               RCALL   Str_to_byte
   \   0000008E   2E00               MOV     R0, R16
    156                // Проверим контрольную сумму
    157                if (lrc!=get_lrc((unsigned char *)strbuf,scnt-2))
   \   00000090   01FD               MOVW    R31:R30, R27:R26
   \   00000092   8122               LDD     R18, Z+2
   \   00000094   8133               LDD     R19, Z+3
   \   00000096   5022               SUBI    R18, 2
   \   00000098   4030               SBCI    R19, 0
   \   0000009A   ....               RCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_5:
   \   0000009C   1600               CP      R0, R16
   \   0000009E   F541               BRNE    ??ascii_mode_task_6
    158                {
    159                  state = STATE_IDLE;
    160                  break;
    161                }
    162                else
    163                {
    164                  addr =  Str_to_byte((unsigned char *)&strbuf[0]); //Str_to_num((unsigned char *)strbuf, 16);
   \   000000A0   ....               RCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_14:
   \   000000A2   ....               RCALL   Str_to_byte
    165                  // Проверим адрес
    166                  if ((addr!=0) && (addr!=wp.devaddr))
   \   000000A4   2300               TST     R16
   \   000000A6   F021               BREQ    ??ascii_mode_task_7
   \   000000A8   9110....           LDS     R17, (wp + 12)
   \   000000AC   1701               CP      R16, R17
   \   000000AE   F501               BRNE    ??ascii_mode_task_6
    167                  {
    168                    state = STATE_IDLE;
    169                    break;
    170                  }
    171                  else
    172                  {
    173                    // Проверим функцию
    174                    fnum = Str_to_byte((unsigned char *)&strbuf[2]);
   \                     ??ascii_mode_task_7:
   \   000000B0   ....               LDI     R16, LOW((strbuf + 2))
   \   000000B2   ....               LDI     R17, HIGH((strbuf + 2))
   \   000000B4   ....               RCALL   Str_to_byte
   \   000000B6   2F10               MOV     R17, R16
   \   000000B8   9300....           STS     (modb_timeout + 5), R16
    175                    for (i=0;i<SIZE_CMD_ARR;i++)
   \   000000BC   E080               LDI     R24, 0
   \   000000BE   E090               LDI     R25, 0
   \   000000C0   E006               LDI     R16, 6
    176                    {
    177                      if  (modbus_cmd[i].id == fnum)
   \                     ??ascii_mode_task_8:
   \   000000C2   019C               MOVW    R19:R18, R25:R24
   \   000000C4   0F22               LSL     R18
   \   000000C6   1F33               ROL     R19
   \   000000C8   0F22               LSL     R18
   \   000000CA   1F33               ROL     R19
   \   000000CC   ....               LDI     R30, LOW(modbus_cmd)
   \   000000CE   ....               LDI     R31, (modbus_cmd) >> 8
   \   000000D0   0FE2               ADD     R30, R18
   \   000000D2   1FF3               ADC     R31, R19
   \   000000D4   9124               LPM     R18, Z
   \   000000D6   1721               CP      R18, R17
   \   000000D8   F431               BRNE    ??ascii_mode_task_9
    178                      {
    179                        // Функция найдена выполняем
    180                        modbus_cmd[i].func();
   \   000000DA   9632               ADIW    R31:R30, 2
   \   000000DC   9105               LPM     R16, Z+
   \   000000DE   91F4               LPM     R31, Z
   \   000000E0   2FE0               MOV     R30, R16
   \   000000E2   9509               ICALL
    181                        state = STATE_IDLE;
   \   000000E4   C005               RJMP    ??ascii_mode_task_6
    182                        return;
    183                      }
    184                    }
   \                     ??ascii_mode_task_9:
   \   000000E6   9601               ADIW    R25:R24, 1
   \   000000E8   950A               DEC     R16
   \   000000EA   F759               BRNE    ??ascii_mode_task_8
    185                    Send_exception_code(ILLEGAL_FUNCTION);
   \   000000EC   E001               LDI     R16, 1
   \   000000EE   ....               RCALL   Send_exception_code
    186          
    187                  }
    188                }
    189                state = STATE_IDLE;
    190                break;
    191              }
    192              state = STATE_IDLE;
   \                     ??ascii_mode_task_6:
   \   000000F0   E000               LDI     R16, 0
   \   000000F2   9300....           STS     (modb_timeout + 4), R16
    193          
    194          
    195              break;
    196          
    197          
    198            }
    199          
    200          
    201          }
   \                     ??ascii_mode_task_4:
   \   000000F6                      REQUIRE ?Subroutine9
   \   000000F6                      ;               // Fall through to label ?Subroutine9

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   00000000   E0E4               LDI     R30, 4
   \   00000002   ....               RJMP    ?EPILOGUE_B4_L09

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   ....               RCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_17:
   \   00000002   ....               RJMP    get_lrc

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   00000000   ....               LDI     R16, LOW(strbuf)
   \   00000002   ....               LDI     R17, (strbuf) >> 8
   \   00000004   9508               RET
    202          
    203          

   \                                 In  segment CODE, align 2, keep-with-next
    204          unsigned char get_lrc(unsigned char *buf,unsigned int len)
   \                     get_lrc:
    205          {
    206            unsigned char lrc = 0 ;
   \   00000000   E040               LDI     R20, 0
   \   00000002   C004               RJMP    ??get_lrc_0
    207            while (len--) lrc += *buf++ ;
   \                     ??get_lrc_1:
   \   00000004   01F8               MOVW    R31:R30, R17:R16
   \   00000006   9151               LD      R21, Z+
   \   00000008   018F               MOVW    R17:R16, R31:R30
   \   0000000A   0F45               ADD     R20, R21
   \                     ??get_lrc_0:
   \   0000000C   01B9               MOVW    R23:R22, R19:R18
   \   0000000E   5021               SUBI    R18, 1
   \   00000010   4030               SBCI    R19, 0
   \   00000012   2B67               OR      R22, R23
   \   00000014   F7B9               BRNE    ??get_lrc_1
    208            return (unsigned char)(-lrc);
   \   00000016   9541               NEG     R20
   \   00000018   2F04               MOV     R16, R20
   \   0000001A   9508               RET
    209          }
    210          
    211          

   \                                 In  segment CODE, align 2, keep-with-next
    212          void reset_timeout(void)
   \                     reset_timeout:
    213          {
    214             modb_timeout = MODB_TIMEOUT;
   \   00000000   ....               LDI     R30, LOW(modb_timeout)
   \   00000002   ....               LDI     R31, (modb_timeout) >> 8
   \   00000004   E100               LDI     R16, 16
   \   00000006   E217               LDI     R17, 39
   \   00000008   8300               ST      Z, R16
   \   0000000A   8311               STD     Z+1, R17
    215          }
   \   0000000C   9508               RET
    216          
    217          
    218          
    219          
    220          
    221          
    222          /*--------------------------------------------------------------------------------------
    223            Чтение внутренних переменных из устройства
    224          
    225            Интерпретация поля данных
    226               +----------------+-------------------------+
    227               ¦стартовый адрес ¦ количество читаемых     |
    228               |                |  2-х байтных регистров  |
    229               +----------------+-------------------------+
    230               ¦   4 сим        ¦       4 сим             |
    231               ¦                ¦                         |
    232               +----------------+-------------------------+
    233          
    234          
    235               Интерпретация стартового адреса:
    236          
    237               Старший байт указывает тип данных: 1 - идентификаторы температурных датчиков
    238                                                  2 - значения температуры с температурных датчиков
    239                                                  3 - значения АЦП с удадленных датчиков
    240          
    241               Младший байт указывает индексы данных в двумерных массивах:
    242                 Старший полубайт указывает номер удаленного узла (датчика)
    243                 Младший полубайт указывает номер температурного датчика в узле или номер аналогового входа
    244            --------------------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
    245          void Read_hld_reg(void)
   \                     Read_hld_reg:
    246          {
   \   00000000   ....               RCALL   ?PROLOGUE5_L09
   \   00000002                      REQUIRE ?Register_R4_is_cg_reg
    247            unsigned int  nm;
    248            unsigned char type, dev, chan;
    249            unsigned char *pval;
    250          
    251            nm   = Str_to_byte((unsigned char *)&strbuf[10])*2; // Вычислим количество байт для передачи
   \   00000002   ....               LDI     R16, LOW((strbuf + 10))
   \   00000004   ....               LDI     R17, HIGH((strbuf + 10))
   \   00000006   ....               RCALL   Str_to_byte
   \   00000008   E012               LDI     R17, 2
   \   0000000A   9F01               MUL     R16, R17
   \   0000000C   2C40               MOV     R4, R0
    252          
    253          
    254            type =  Str_to_byte((unsigned char *)&strbuf[4]);
   \   0000000E   ....               LDI     R16, LOW((strbuf + 4))
   \   00000010   ....               LDI     R17, HIGH((strbuf + 4))
   \   00000012   ....               RCALL   Str_to_byte
   \   00000014   2FB0               MOV     R27, R16
    255            dev  = (Str_to_byte((unsigned char *)&strbuf[6]) >> 4) & 0x000F;
   \   00000016   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_12:
   \   00000018   9502               SWAP    R16
   \   0000001A   700F               ANDI    R16, 0x0F
   \   0000001C   2FA0               MOV     R26, R16
    256            chan =  Str_to_byte((unsigned char *)&strbuf[6]) & 0x000F;
   \   0000001E   ....               RCALL   ?Subroutine5
   \                     ??CrossCallReturnLabel_11:
   \   00000020   700F               ANDI    R16, 0x0F
   \   00000022   2F20               MOV     R18, R16
    257            switch (type)
   \   00000024   2F0A               MOV     R16, R26
   \   00000026   E010               LDI     R17, 0
   \   00000028   E248               LDI     R20, 40
   \   0000002A   E050               LDI     R21, 0
   \   0000002C   ....               RCALL   ?S_EC_MUL_L02
   \   0000002E   ....               LDI     R22, LOW(nodes_temperatures)
   \   00000030   ....               LDI     R23, (nodes_temperatures) >> 8
   \   00000032   0F60               ADD     R22, R16
   \   00000034   1F71               ADC     R23, R17
   \   00000036   2F02               MOV     R16, R18
   \   00000038   E010               LDI     R17, 0
   \   0000003A   E04A               LDI     R20, 10
   \   0000003C   ....               RCALL   ?S_EC_MUL_L02
   \   0000003E   0F60               ADD     R22, R16
   \   00000040   1F71               ADC     R23, R17
   \   00000042   95BA               DEC     R27
   \   00000044   F029               BREQ    ??Read_hld_reg_0
   \   00000046   95BA               DEC     R27
   \   00000048   F049               BREQ    ??Read_hld_reg_1
   \   0000004A   95BA               DEC     R27
   \   0000004C   F071               BREQ    ??Read_hld_reg_2
   \   0000004E   C01D               RJMP    ??Read_hld_reg_3
    258            {
    259            case 1:
    260              if (dev  >= MAX_NODES)   return;
   \                     ??Read_hld_reg_0:
   \   00000050   30A4               CPI     R26, 4
   \   00000052   F4F0               BRCC    ??Read_hld_reg_4
    261              if (chan >= MAX_DEVICES) return;
   \   00000054   3024               CPI     R18, 4
   \   00000056   F4E0               BRCC    ??Read_hld_reg_4
    262              pval = nodes_temperatures[dev][chan].id;
   \   00000058   01CB               MOVW    R25:R24, R23:R22
    263              break;
   \   0000005A   C017               RJMP    ??Read_hld_reg_3
    264            case 2:
    265              if (dev  >= MAX_NODES)   return;
   \                     ??Read_hld_reg_1:
   \   0000005C   30A4               CPI     R26, 4
   \   0000005E   F4C0               BRCC    ??Read_hld_reg_4
    266              if (chan >= MAX_DEVICES) return;
   \   00000060   3024               CPI     R18, 4
   \   00000062   F4B0               BRCC    ??Read_hld_reg_4
    267              pval = (unsigned char*)&nodes_temperatures[dev][chan].temperature;
   \   00000064   01CB               MOVW    R25:R24, R23:R22
   \   00000066   9608               ADIW    R25:R24, 8
    268              break;
   \   00000068   C010               RJMP    ??Read_hld_reg_3
    269            case 3:
    270              if (dev  >= MAX_NODES)   return;
   \                     ??Read_hld_reg_2:
   \   0000006A   30A4               CPI     R26, 4
   \   0000006C   F488               BRCC    ??Read_hld_reg_4
    271              if (chan >= MAX_AN_IN)   return;
   \   0000006E   3026               CPI     R18, 6
   \   00000070   F478               BRCC    ??Read_hld_reg_4
    272              pval = (unsigned char*)&nodes_an_inputs[dev][chan];
   \   00000072   2F0A               MOV     R16, R26
   \   00000074   E010               LDI     R17, 0
   \   00000076   E04C               LDI     R20, 12
   \   00000078   ....               RCALL   ?S_EC_MUL_L02
   \   0000007A   ....               LDI     R24, LOW(nodes_an_inputs)
   \   0000007C   ....               LDI     R25, (nodes_an_inputs) >> 8
   \   0000007E   0F80               ADD     R24, R16
   \   00000080   1F91               ADC     R25, R17
   \   00000082   E002               LDI     R16, 2
   \   00000084   9F20               MUL     R18, R16
   \   00000086   0D80               ADD     R24, R0
   \   00000088   1F95               ADC     R25, R21
    273              break;
    274            }
    275          
    276            Send_read_response(pval,nm);
   \                     ??Read_hld_reg_3:
   \   0000008A   2D24               MOV     R18, R4
   \   0000008C   018C               MOVW    R17:R16, R25:R24
   \   0000008E   ....               RCALL   Send_read_response
    277          
    278          }
   \                     ??Read_hld_reg_4:
   \   00000090   E0E5               LDI     R30, 5
   \   00000092   ....               RJMP    ?EPILOGUE_B5_L09

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   00000000   ....               LDI     R16, LOW((strbuf + 6))
   \   00000002   ....               LDI     R17, HIGH((strbuf + 6))
   \   00000004   ....               RJMP    Str_to_byte
    279          
    280          
    281          

   \                                 In  segment CODE, align 2, keep-with-next
    282          void Preset_single_register(void)
   \                     Preset_single_register:
    283          {
    284          
    285          }
   \   00000000   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    286          void Preset_multiple_registers(void)
   \                     Preset_multiple_registers:
    287          {
    288          
    289          }
   \   00000000   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    290          void Read_EEPROM_reg(void)
   \                     Read_EEPROM_reg:
    291          {
    292          
    293          
    294          }
   \   00000000   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    295          void Preset_EEPROM_reg(void)
   \                     Preset_EEPROM_reg:
    296          {
    297          
    298          
    299          }
   \   00000000   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
    300          void Read_reg_type(void)
   \                     Read_reg_type:
    301          {
    302          
    303          }
   \   00000000   9508               RET
    304          
    305          
    306          /*--------------------------------------------------------------------------------------
    307            Передача пакета на запрос чтения
    308            --------------------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
    309          void Send_read_response(unsigned char *pval,unsigned char nm)
   \                     Send_read_response:
    310          {
   \   00000000   ....               RCALL   ?PROLOGUE4_L09
   \   00000002   01D8               MOVW    R27:R26, R17:R16
   \   00000004   2F82               MOV     R24, R18
    311            unsigned char lrc;
    312            unsigned char i;
    313            unsigned char b;
    314            USART_Transmit(':');
   \   00000006   E30A               LDI     R16, 58
   \   00000008   ....               RCALL   USART_Transmit
    315            Num_to_str((unsigned char *)strbuf,   2,wp.devaddr,16);
   \   0000000A   ....               RCALL   ?Subroutine0
    316            Num_to_str((unsigned char *)&strbuf[2],2,fnum,16);
    317            Num_to_str((unsigned char *)&strbuf[4],2,nm,16);
    318            for (i=0;i<nm;i++)
   \                     ??CrossCallReturnLabel_0:
   \   0000000C   E090               LDI     R25, 0
   \   0000000E   C008               RJMP    ??Send_read_response_0
    319            {
    320              b = *(pval++);
   \                     ??Send_read_response_1:
   \   00000010   914D               LD      R20, X+
    321              Num_to_str((unsigned char *)&strbuf[6+i*2],2,b,16);
   \   00000012   ....               RCALL   ??Subroutine10_0
    322            }
   \                     ??CrossCallReturnLabel_25:
   \   00000014   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_3:
   \   00000016   9F92               MUL     R25, R18
   \   00000018   0D00               ADD     R16, R0
   \   0000001A   1D11               ADC     R17, R1
   \   0000001C   ....               RCALL   Num_to_str
   \   0000001E   9593               INC     R25
   \                     ??Send_read_response_0:
   \   00000020   1798               CP      R25, R24
   \   00000022   F3B0               BRCS    ??Send_read_response_1
    323            lrc = get_lrc((unsigned char *)strbuf,nm+6);
   \   00000024   2F28               MOV     R18, R24
   \   00000026   E030               LDI     R19, 0
   \   00000028   5F2A               SUBI    R18, 250
   \   0000002A   4F3F               SBCI    R19, 255
   \   0000002C   ....               RCALL   ?Subroutine2
    324            Num_to_str((unsigned char *)&strbuf[6+nm*2],2,lrc,16);
   \                     ??CrossCallReturnLabel_4:
   \   0000002E   E012               LDI     R17, 2
   \   00000030   9F81               MUL     R24, R17
   \   00000032   ....               LDI     R26, LOW(strbuf)
   \   00000034   ....               LDI     R27, (strbuf) >> 8
   \   00000036   0DA0               ADD     R26, R0
   \   00000038   1DB1               ADC     R27, R1
   \   0000003A   E110               LDI     R17, 16
   \   0000003C   931A               ST      -Y, R17
   \   0000003E   2F40               MOV     R20, R16
   \   00000040   ....               RCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_18:
   \   00000042   018D               MOVW    R17:R16, R27:R26
   \   00000044   5F0A               SUBI    R16, 250
   \   00000046   4F1F               SBCI    R17, 255
   \   00000048   ....               RCALL   Num_to_str
    325            strbuf[8+nm*2]  = 0x0D;
   \   0000004A   01FD               MOVW    R31:R30, R27:R26
   \   0000004C   ....               RCALL   ?Subroutine3
    326            strbuf[9+nm*2]  = 0x0A;
    327            strbuf[10+nm*2] = 0;
    328            USART_sendstr(strbuf);
   \                     ??CrossCallReturnLabel_8:
   \   0000004E   ....               RCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_15:
   \   00000050   ....               RCALL   USART_sendstr
    329          }
   \   00000052   ....               RJMP    ?Subroutine9

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   E00D               LDI     R16, 13
   \   00000002   8700               STD     Z+8, R16
   \   00000004   E00A               LDI     R16, 10
   \   00000006   8701               STD     Z+9, R16
   \   00000008   E000               LDI     R16, 0
   \   0000000A   8702               STD     Z+10, R16
   \   0000000C   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   ....               RCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_22:
   \   00000002   ....               LDI     R16, LOW((strbuf + 6))
   \   00000004   ....               LDI     R17, HIGH((strbuf + 6))
   \   00000006   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   00000000   E050               LDI     R21, 0
   \   00000002   E060               LDI     R22, 0
   \   00000004   E070               LDI     R23, 0
   \   00000006   E022               LDI     R18, 2
   \   00000008   E030               LDI     R19, 0
   \   0000000A   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   ....               RCALL   ??Subroutine10_0
   \                     ??CrossCallReturnLabel_26:
   \   00000002   9140....           LDS     R20, (wp + 12)
   \   00000006   ....               RCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_19:
   \   00000008   ....               RCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_16:
   \   0000000A   ....               RCALL   ?Subroutine7
   \                     ??CrossCallReturnLabel_23:
   \   0000000C   9140....           LDS     R20, (modb_timeout + 5)
   \   00000010   ....               RCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_20:
   \   00000012   ....               LDI     R16, LOW((strbuf + 2))
   \   00000014   ....               LDI     R17, HIGH((strbuf + 2))
   \   00000016   ....               RCALL   ?Subroutine7
   \                     ??CrossCallReturnLabel_24:
   \   00000018   2F48               MOV     R20, R24
   \   0000001A   ....               RCALL   ?Subroutine8
   \                     ??CrossCallReturnLabel_21:
   \   0000001C   ....               LDI     R16, LOW((strbuf + 4))
   \   0000001E   ....               LDI     R17, HIGH((strbuf + 4))
   \   00000020   ....               RJMP    Num_to_str

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   00000000   ....               RCALL   Num_to_str
   \   00000002                      REQUIRE ??Subroutine10_0
   \   00000002                      ;               // Fall through to label ??Subroutine10_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine10_0:
   \   00000000   E100               LDI     R16, 16
   \   00000002   930A               ST      -Y, R16
   \   00000004   9508               RET
    330          
    331          /*--------------------------------------------------------------------------------------
    332            Функци выдачи кода исключения
    333            --------------------------------------------------------------------------------------*/

   \                                 In  segment CODE, align 2, keep-with-next
    334          void Send_exception_code(unsigned char exceptc)
   \                     Send_exception_code:
    335          {
   \   00000000   938A               ST      -Y, R24
   \   00000002   2F80               MOV     R24, R16
    336            unsigned char lrc;
    337            USART_Transmit(':');
   \   00000004   E30A               LDI     R16, 58
   \   00000006   ....               RCALL   USART_Transmit
    338            fnum |=0x80;
   \   00000008   ....               LDI     R30, LOW(modb_timeout)
   \   0000000A   ....               LDI     R31, (modb_timeout) >> 8
   \   0000000C   8105               LDD     R16, Z+5
   \   0000000E   6800               ORI     R16, 0x80
   \   00000010   8305               STD     Z+5, R16
    339          
    340            Num_to_str((unsigned char *)strbuf,   2,wp.devaddr,16);
   \   00000012   ....               RCALL   ?Subroutine0
    341            Num_to_str((unsigned char *)&strbuf[2],2,fnum,16);
    342            Num_to_str((unsigned char *)&strbuf[4],2,exceptc,16);
    343            lrc = get_lrc((unsigned char *)strbuf,6);
   \                     ??CrossCallReturnLabel_1:
   \   00000014   E026               LDI     R18, 6
   \   00000016   E030               LDI     R19, 0
   \   00000018   ....               RCALL   ?Subroutine2
    344            Num_to_str((unsigned char *)&strbuf[6],2,lrc,16);
   \                     ??CrossCallReturnLabel_6:
   \   0000001A   E110               LDI     R17, 16
   \   0000001C   931A               ST      -Y, R17
   \   0000001E   2F40               MOV     R20, R16
   \   00000020   ....               RCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   00000022   ....               RCALL   Num_to_str
    345            strbuf[8]  = 0x0D;
   \   00000024   ....               LDI     R30, LOW(strbuf)
   \   00000026   ....               LDI     R31, (strbuf) >> 8
   \   00000028   ....               RCALL   ?Subroutine3
    346            strbuf[9]  = 0x0A;
    347            strbuf[10] = 0;
    348            USART_sendstr(strbuf);
   \                     ??CrossCallReturnLabel_7:
   \   0000002A   018F               MOVW    R17:R16, R31:R30
   \   0000002C   ....               RCALL   USART_sendstr
    349          }
   \   0000002E   9189               LD      R24, Y+
   \   00000030   9508               RET

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   00000000   E140               LDI     R20, 16
   \   00000002   E257               LDI     R21, 39
   \   00000004   934D               ST      X+, R20
   \   00000006   935C               ST      X, R21
   \   00000008   9711               SBIW    R27:R26, 1
   \   0000000A   9508               RET

   Maximum stack usage in bytes:

   CSTACK RSTACK Function
   ------ ------ --------
      0      2   Preset_EEPROM_reg
      0      2   Preset_multiple_registers
      0      2   Preset_single_register
      0      2   Read_EEPROM_reg
      5      2   Read_hld_reg
        5      2   -> Send_read_response
        5      2   -> Str_to_byte
        5      2 ?S_EC_MUL_L02
      0      2   Read_reg_type
      2      2   Send_exception_code
        1      2   -> Num_to_str
        1      6   -> Num_to_str
        1      2   -> USART_Transmit
        1      2   -> USART_sendstr
        1      2   -> get_lrc
      5      2   Send_read_response
        4      2   -> Num_to_str
        4      6   -> Num_to_str
        4      2   -> USART_Transmit
        4      2   -> USART_sendstr
        4      2   -> get_lrc
      4      2   ascii_mode_task
        4      2   -- Indirect call
        4      2   -> Send_exception_code
        4      2   -> Str_to_byte
        4      2   -> get_lrc
      0      2   get_lrc
      0      2   modbus_task
        0      2   -> ascii_mode_task
      0      2   reset_timeout


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ??Subroutine10_0
      34  ?Subroutine0
       8  ?Subroutine1
       4  ?Subroutine2
      14  ?Subroutine3
      12  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
       2  ?Subroutine7
      12  ?Subroutine8
       4  ?Subroutine9
       2  Preset_EEPROM_reg
       2  Preset_multiple_registers
       2  Preset_single_register
       2  Read_EEPROM_reg
     148  Read_hld_reg
       2  Read_reg_type
      50  Send_exception_code
      84  Send_read_response
       1  addr
     246  ascii_mode_task
      28  get_lrc
       6  modb_timeout
          scnt
          state
          fnum
      24  modbus_cmd
       2  modbus_task
      14  reset_timeout
       6  -- Other

 
 690 bytes in segment CODE
   6 bytes in segment INITTAB
  24 bytes in segment NEAR_F
   7 bytes in segment NEAR_Z
 
 714 bytes of CODE memory (+ 6 bytes shared)
   7 bytes of DATA memory

Errors: none
Warnings: none
